/* automatically generated by rust-bindgen 0.60.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const __GNUC_VA_LIST: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_ONLY_VERS_1050: u32 = 1;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_EXTSN: &[u8; 14usize] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_VERS_1050: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __has_ptrcheck: u32 = 0;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const __DARWIN_CLK_TCK: u32 = 100;
pub const CHAR_BIT: u32 = 8;
pub const MB_LEN_MAX: u32 = 6;
pub const CLK_TCK: u32 = 100;
pub const SCHAR_MAX: u32 = 127;
pub const SCHAR_MIN: i32 = -128;
pub const UCHAR_MAX: u32 = 255;
pub const CHAR_MAX: u32 = 127;
pub const CHAR_MIN: i32 = -128;
pub const USHRT_MAX: u32 = 65535;
pub const SHRT_MAX: u32 = 32767;
pub const SHRT_MIN: i32 = -32768;
pub const UINT_MAX: u32 = 4294967295;
pub const INT_MAX: u32 = 2147483647;
pub const INT_MIN: i32 = -2147483648;
pub const ULONG_MAX: i32 = -1;
pub const LONG_MAX: u64 = 9223372036854775807;
pub const LONG_MIN: i64 = -9223372036854775808;
pub const ULLONG_MAX: i32 = -1;
pub const LLONG_MAX: u64 = 9223372036854775807;
pub const LLONG_MIN: i64 = -9223372036854775808;
pub const LONG_BIT: u32 = 64;
pub const SSIZE_MAX: u64 = 9223372036854775807;
pub const WORD_BIT: u32 = 32;
pub const SIZE_T_MAX: i32 = -1;
pub const UQUAD_MAX: i32 = -1;
pub const QUAD_MAX: u64 = 9223372036854775807;
pub const QUAD_MIN: i64 = -9223372036854775808;
pub const ARG_MAX: u32 = 1048576;
pub const CHILD_MAX: u32 = 266;
pub const GID_MAX: u32 = 2147483647;
pub const LINK_MAX: u32 = 32767;
pub const MAX_CANON: u32 = 1024;
pub const MAX_INPUT: u32 = 1024;
pub const NAME_MAX: u32 = 255;
pub const NGROUPS_MAX: u32 = 16;
pub const UID_MAX: u32 = 2147483647;
pub const OPEN_MAX: u32 = 10240;
pub const PATH_MAX: u32 = 1024;
pub const PIPE_BUF: u32 = 512;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const CHARCLASS_NAME_MAX: u32 = 14;
pub const COLL_WEIGHTS_MAX: u32 = 2;
pub const EQUIV_CLASS_MAX: u32 = 2;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 255;
pub const NZERO: u32 = 20;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_EQUIV_CLASS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_KEYS_MAX: u32 = 512;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_SS_REPL_MAX: u32 = 4;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TRACE_EVENT_NAME_MAX: u32 = 30;
pub const _POSIX_TRACE_NAME_MAX: u32 = 8;
pub const _POSIX_TRACE_SYS_MAX: u32 = 8;
pub const _POSIX_TRACE_USER_EVENT_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const OFF_MIN: i64 = -9223372036854775808;
pub const OFF_MAX: u64 = 9223372036854775807;
pub const PASS_MAX: u32 = 128;
pub const NL_ARGMAX: u32 = 9;
pub const NL_LANGMAX: u32 = 14;
pub const NL_MSGMAX: u32 = 32767;
pub const NL_NMAX: u32 = 1;
pub const NL_SETMAX: u32 = 255;
pub const NL_TEXTMAX: u32 = 2048;
pub const _XOPEN_IOV_MAX: u32 = 16;
pub const IOV_MAX: u32 = 1024;
pub const _XOPEN_NAME_MAX: u32 = 255;
pub const _XOPEN_PATH_MAX: u32 = 1024;
pub const __API_TO_BE_DEPRECATED: u32 = 100000;
pub const __MAC_10_0: u32 = 1000;
pub const __MAC_10_1: u32 = 1010;
pub const __MAC_10_2: u32 = 1020;
pub const __MAC_10_3: u32 = 1030;
pub const __MAC_10_4: u32 = 1040;
pub const __MAC_10_5: u32 = 1050;
pub const __MAC_10_6: u32 = 1060;
pub const __MAC_10_7: u32 = 1070;
pub const __MAC_10_8: u32 = 1080;
pub const __MAC_10_9: u32 = 1090;
pub const __MAC_10_10: u32 = 101000;
pub const __MAC_10_10_2: u32 = 101002;
pub const __MAC_10_10_3: u32 = 101003;
pub const __MAC_10_11: u32 = 101100;
pub const __MAC_10_11_2: u32 = 101102;
pub const __MAC_10_11_3: u32 = 101103;
pub const __MAC_10_11_4: u32 = 101104;
pub const __MAC_10_12: u32 = 101200;
pub const __MAC_10_12_1: u32 = 101201;
pub const __MAC_10_12_2: u32 = 101202;
pub const __MAC_10_12_4: u32 = 101204;
pub const __MAC_10_13: u32 = 101300;
pub const __MAC_10_13_1: u32 = 101301;
pub const __MAC_10_13_2: u32 = 101302;
pub const __MAC_10_13_4: u32 = 101304;
pub const __MAC_10_14: u32 = 101400;
pub const __MAC_10_14_1: u32 = 101401;
pub const __MAC_10_14_4: u32 = 101404;
pub const __MAC_10_14_6: u32 = 101406;
pub const __MAC_10_15: u32 = 101500;
pub const __MAC_10_15_1: u32 = 101501;
pub const __MAC_10_15_4: u32 = 101504;
pub const __MAC_10_16: u32 = 101600;
pub const __MAC_11_0: u32 = 110000;
pub const __MAC_11_1: u32 = 110100;
pub const __MAC_11_3: u32 = 110300;
pub const __MAC_11_4: u32 = 110400;
pub const __MAC_11_5: u32 = 110500;
pub const __MAC_11_6: u32 = 110600;
pub const __MAC_12_0: u32 = 120000;
pub const __MAC_12_1: u32 = 120100;
pub const __MAC_12_2: u32 = 120200;
pub const __MAC_12_3: u32 = 120300;
pub const __IPHONE_2_0: u32 = 20000;
pub const __IPHONE_2_1: u32 = 20100;
pub const __IPHONE_2_2: u32 = 20200;
pub const __IPHONE_3_0: u32 = 30000;
pub const __IPHONE_3_1: u32 = 30100;
pub const __IPHONE_3_2: u32 = 30200;
pub const __IPHONE_4_0: u32 = 40000;
pub const __IPHONE_4_1: u32 = 40100;
pub const __IPHONE_4_2: u32 = 40200;
pub const __IPHONE_4_3: u32 = 40300;
pub const __IPHONE_5_0: u32 = 50000;
pub const __IPHONE_5_1: u32 = 50100;
pub const __IPHONE_6_0: u32 = 60000;
pub const __IPHONE_6_1: u32 = 60100;
pub const __IPHONE_7_0: u32 = 70000;
pub const __IPHONE_7_1: u32 = 70100;
pub const __IPHONE_8_0: u32 = 80000;
pub const __IPHONE_8_1: u32 = 80100;
pub const __IPHONE_8_2: u32 = 80200;
pub const __IPHONE_8_3: u32 = 80300;
pub const __IPHONE_8_4: u32 = 80400;
pub const __IPHONE_9_0: u32 = 90000;
pub const __IPHONE_9_1: u32 = 90100;
pub const __IPHONE_9_2: u32 = 90200;
pub const __IPHONE_9_3: u32 = 90300;
pub const __IPHONE_10_0: u32 = 100000;
pub const __IPHONE_10_1: u32 = 100100;
pub const __IPHONE_10_2: u32 = 100200;
pub const __IPHONE_10_3: u32 = 100300;
pub const __IPHONE_11_0: u32 = 110000;
pub const __IPHONE_11_1: u32 = 110100;
pub const __IPHONE_11_2: u32 = 110200;
pub const __IPHONE_11_3: u32 = 110300;
pub const __IPHONE_11_4: u32 = 110400;
pub const __IPHONE_12_0: u32 = 120000;
pub const __IPHONE_12_1: u32 = 120100;
pub const __IPHONE_12_2: u32 = 120200;
pub const __IPHONE_12_3: u32 = 120300;
pub const __IPHONE_12_4: u32 = 120400;
pub const __IPHONE_13_0: u32 = 130000;
pub const __IPHONE_13_1: u32 = 130100;
pub const __IPHONE_13_2: u32 = 130200;
pub const __IPHONE_13_3: u32 = 130300;
pub const __IPHONE_13_4: u32 = 130400;
pub const __IPHONE_13_5: u32 = 130500;
pub const __IPHONE_13_6: u32 = 130600;
pub const __IPHONE_13_7: u32 = 130700;
pub const __IPHONE_14_0: u32 = 140000;
pub const __IPHONE_14_1: u32 = 140100;
pub const __IPHONE_14_2: u32 = 140200;
pub const __IPHONE_14_3: u32 = 140300;
pub const __IPHONE_14_5: u32 = 140500;
pub const __IPHONE_14_6: u32 = 140600;
pub const __IPHONE_14_7: u32 = 140700;
pub const __IPHONE_14_8: u32 = 140800;
pub const __IPHONE_15_0: u32 = 150000;
pub const __IPHONE_15_1: u32 = 150100;
pub const __IPHONE_15_2: u32 = 150200;
pub const __IPHONE_15_3: u32 = 150300;
pub const __IPHONE_15_4: u32 = 150400;
pub const __TVOS_9_0: u32 = 90000;
pub const __TVOS_9_1: u32 = 90100;
pub const __TVOS_9_2: u32 = 90200;
pub const __TVOS_10_0: u32 = 100000;
pub const __TVOS_10_0_1: u32 = 100001;
pub const __TVOS_10_1: u32 = 100100;
pub const __TVOS_10_2: u32 = 100200;
pub const __TVOS_11_0: u32 = 110000;
pub const __TVOS_11_1: u32 = 110100;
pub const __TVOS_11_2: u32 = 110200;
pub const __TVOS_11_3: u32 = 110300;
pub const __TVOS_11_4: u32 = 110400;
pub const __TVOS_12_0: u32 = 120000;
pub const __TVOS_12_1: u32 = 120100;
pub const __TVOS_12_2: u32 = 120200;
pub const __TVOS_12_3: u32 = 120300;
pub const __TVOS_12_4: u32 = 120400;
pub const __TVOS_13_0: u32 = 130000;
pub const __TVOS_13_2: u32 = 130200;
pub const __TVOS_13_3: u32 = 130300;
pub const __TVOS_13_4: u32 = 130400;
pub const __TVOS_14_0: u32 = 140000;
pub const __TVOS_14_1: u32 = 140100;
pub const __TVOS_14_2: u32 = 140200;
pub const __TVOS_14_3: u32 = 140300;
pub const __TVOS_14_5: u32 = 140500;
pub const __TVOS_14_6: u32 = 140600;
pub const __TVOS_14_7: u32 = 140700;
pub const __TVOS_15_0: u32 = 150000;
pub const __TVOS_15_1: u32 = 150100;
pub const __TVOS_15_2: u32 = 150200;
pub const __TVOS_15_3: u32 = 150300;
pub const __TVOS_15_4: u32 = 150400;
pub const __WATCHOS_1_0: u32 = 10000;
pub const __WATCHOS_2_0: u32 = 20000;
pub const __WATCHOS_2_1: u32 = 20100;
pub const __WATCHOS_2_2: u32 = 20200;
pub const __WATCHOS_3_0: u32 = 30000;
pub const __WATCHOS_3_1: u32 = 30100;
pub const __WATCHOS_3_1_1: u32 = 30101;
pub const __WATCHOS_3_2: u32 = 30200;
pub const __WATCHOS_4_0: u32 = 40000;
pub const __WATCHOS_4_1: u32 = 40100;
pub const __WATCHOS_4_2: u32 = 40200;
pub const __WATCHOS_4_3: u32 = 40300;
pub const __WATCHOS_5_0: u32 = 50000;
pub const __WATCHOS_5_1: u32 = 50100;
pub const __WATCHOS_5_2: u32 = 50200;
pub const __WATCHOS_5_3: u32 = 50300;
pub const __WATCHOS_6_0: u32 = 60000;
pub const __WATCHOS_6_1: u32 = 60100;
pub const __WATCHOS_6_2: u32 = 60200;
pub const __WATCHOS_7_0: u32 = 70000;
pub const __WATCHOS_7_1: u32 = 70100;
pub const __WATCHOS_7_2: u32 = 70200;
pub const __WATCHOS_7_3: u32 = 70300;
pub const __WATCHOS_7_4: u32 = 70400;
pub const __WATCHOS_7_5: u32 = 70500;
pub const __WATCHOS_7_6: u32 = 70600;
pub const __WATCHOS_8_0: u32 = 80000;
pub const __WATCHOS_8_1: u32 = 80100;
pub const __WATCHOS_8_3: u32 = 80300;
pub const __WATCHOS_8_4: u32 = 80400;
pub const __WATCHOS_8_5: u32 = 80500;
pub const MAC_OS_X_VERSION_10_0: u32 = 1000;
pub const MAC_OS_X_VERSION_10_1: u32 = 1010;
pub const MAC_OS_X_VERSION_10_2: u32 = 1020;
pub const MAC_OS_X_VERSION_10_3: u32 = 1030;
pub const MAC_OS_X_VERSION_10_4: u32 = 1040;
pub const MAC_OS_X_VERSION_10_5: u32 = 1050;
pub const MAC_OS_X_VERSION_10_6: u32 = 1060;
pub const MAC_OS_X_VERSION_10_7: u32 = 1070;
pub const MAC_OS_X_VERSION_10_8: u32 = 1080;
pub const MAC_OS_X_VERSION_10_9: u32 = 1090;
pub const MAC_OS_X_VERSION_10_10: u32 = 101000;
pub const MAC_OS_X_VERSION_10_10_2: u32 = 101002;
pub const MAC_OS_X_VERSION_10_10_3: u32 = 101003;
pub const MAC_OS_X_VERSION_10_11: u32 = 101100;
pub const MAC_OS_X_VERSION_10_11_2: u32 = 101102;
pub const MAC_OS_X_VERSION_10_11_3: u32 = 101103;
pub const MAC_OS_X_VERSION_10_11_4: u32 = 101104;
pub const MAC_OS_X_VERSION_10_12: u32 = 101200;
pub const MAC_OS_X_VERSION_10_12_1: u32 = 101201;
pub const MAC_OS_X_VERSION_10_12_2: u32 = 101202;
pub const MAC_OS_X_VERSION_10_12_4: u32 = 101204;
pub const MAC_OS_X_VERSION_10_13: u32 = 101300;
pub const MAC_OS_X_VERSION_10_13_1: u32 = 101301;
pub const MAC_OS_X_VERSION_10_13_2: u32 = 101302;
pub const MAC_OS_X_VERSION_10_13_4: u32 = 101304;
pub const MAC_OS_X_VERSION_10_14: u32 = 101400;
pub const MAC_OS_X_VERSION_10_14_1: u32 = 101401;
pub const MAC_OS_X_VERSION_10_14_4: u32 = 101404;
pub const MAC_OS_X_VERSION_10_14_6: u32 = 101406;
pub const MAC_OS_X_VERSION_10_15: u32 = 101500;
pub const MAC_OS_X_VERSION_10_15_1: u32 = 101501;
pub const MAC_OS_X_VERSION_10_16: u32 = 101600;
pub const MAC_OS_VERSION_11_0: u32 = 110000;
pub const MAC_OS_VERSION_12_0: u32 = 120000;
pub const __DRIVERKIT_19_0: u32 = 190000;
pub const __DRIVERKIT_20_0: u32 = 200000;
pub const __DRIVERKIT_21_0: u32 = 210000;
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: u32 = 120300;
pub const __ENABLE_LEGACY_MAC_AVAILABILITY: u32 = 1;
pub const __DARWIN_WCHAR_MIN: i32 = -2147483648;
pub const _FORTIFY_SOURCE: u32 = 2;
pub const RENAME_SECLUDE: u32 = 1;
pub const RENAME_SWAP: u32 = 2;
pub const RENAME_EXCL: u32 = 4;
pub const RENAME_RESERVED1: u32 = 8;
pub const RENAME_NOFOLLOW_ANY: u32 = 16;
pub const __SLBF: u32 = 1;
pub const __SNBF: u32 = 2;
pub const __SRD: u32 = 4;
pub const __SWR: u32 = 8;
pub const __SRW: u32 = 16;
pub const __SEOF: u32 = 32;
pub const __SERR: u32 = 64;
pub const __SMBF: u32 = 128;
pub const __SAPP: u32 = 256;
pub const __SSTR: u32 = 512;
pub const __SOPT: u32 = 1024;
pub const __SNPT: u32 = 2048;
pub const __SOFF: u32 = 4096;
pub const __SMOD: u32 = 8192;
pub const __SALC: u32 = 16384;
pub const __SIGN: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 1024;
pub const EOF: i32 = -1;
pub const FOPEN_MAX: u32 = 20;
pub const FILENAME_MAX: u32 = 1024;
pub const P_tmpdir: &[u8; 10usize] = b"/var/tmp/\0";
pub const L_tmpnam: u32 = 1024;
pub const TMP_MAX: u32 = 308915776;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const L_ctermid: u32 = 1024;
pub const _USE_FORTIFY_LEVEL: u32 = 2;
pub const DYNAMIC_TARGETS_ENABLED: u32 = 0;
pub const TARGET_OS_MAC: u32 = 1;
pub const TARGET_OS_WIN32: u32 = 0;
pub const TARGET_OS_WINDOWS: u32 = 0;
pub const TARGET_OS_UNIX: u32 = 0;
pub const TARGET_OS_LINUX: u32 = 0;
pub const TARGET_OS_OSX: u32 = 1;
pub const TARGET_OS_IPHONE: u32 = 0;
pub const TARGET_OS_IOS: u32 = 0;
pub const TARGET_OS_WATCH: u32 = 0;
pub const TARGET_OS_TV: u32 = 0;
pub const TARGET_OS_MACCATALYST: u32 = 0;
pub const TARGET_OS_UIKITFORMAC: u32 = 0;
pub const TARGET_OS_SIMULATOR: u32 = 0;
pub const TARGET_OS_EMBEDDED: u32 = 0;
pub const TARGET_OS_RTKIT: u32 = 0;
pub const TARGET_OS_DRIVERKIT: u32 = 0;
pub const TARGET_IPHONE_SIMULATOR: u32 = 0;
pub const TARGET_OS_NANO: u32 = 0;
pub const TARGET_CPU_PPC: u32 = 0;
pub const TARGET_CPU_PPC64: u32 = 0;
pub const TARGET_CPU_68K: u32 = 0;
pub const TARGET_CPU_X86: u32 = 0;
pub const TARGET_CPU_X86_64: u32 = 0;
pub const TARGET_CPU_ARM: u32 = 0;
pub const TARGET_CPU_ARM64: u32 = 1;
pub const TARGET_CPU_MIPS: u32 = 0;
pub const TARGET_CPU_SPARC: u32 = 0;
pub const TARGET_CPU_ALPHA: u32 = 0;
pub const TARGET_RT_MAC_CFM: u32 = 0;
pub const TARGET_RT_MAC_MACHO: u32 = 1;
pub const TARGET_RT_LITTLE_ENDIAN: u32 = 1;
pub const TARGET_RT_BIG_ENDIAN: u32 = 0;
pub const TARGET_RT_64_BIT: u32 = 1;
pub const _QUAD_HIGHWORD: u32 = 1;
pub const _QUAD_LOWWORD: u32 = 0;
pub const __DARWIN_LITTLE_ENDIAN: u32 = 1234;
pub const __DARWIN_BIG_ENDIAN: u32 = 4321;
pub const __DARWIN_PDP_ENDIAN: u32 = 3412;
pub const __DARWIN_BYTE_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const __DARWIN_FD_SETSIZE: u32 = 1024;
pub const __DARWIN_NBBY: u32 = 8;
pub const NBBY: u32 = 8;
pub const FD_SETSIZE: u32 = 1024;
pub const FALSE: u32 = 0;
pub const TRUE: u32 = 1;
pub const __PRI_8_LENGTH_MODIFIER__: &[u8; 3usize] = b"hh\0";
pub const __PRI_64_LENGTH_MODIFIER__: &[u8; 3usize] = b"ll\0";
pub const __SCN_64_LENGTH_MODIFIER__: &[u8; 3usize] = b"ll\0";
pub const __PRI_MAX_LENGTH_MODIFIER__: &[u8; 2usize] = b"j\0";
pub const __SCN_MAX_LENGTH_MODIFIER__: &[u8; 2usize] = b"j\0";
pub const PRId8: &[u8; 4usize] = b"hhd\0";
pub const PRIi8: &[u8; 4usize] = b"hhi\0";
pub const PRIo8: &[u8; 4usize] = b"hho\0";
pub const PRIu8: &[u8; 4usize] = b"hhu\0";
pub const PRIx8: &[u8; 4usize] = b"hhx\0";
pub const PRIX8: &[u8; 4usize] = b"hhX\0";
pub const PRId16: &[u8; 3usize] = b"hd\0";
pub const PRIi16: &[u8; 3usize] = b"hi\0";
pub const PRIo16: &[u8; 3usize] = b"ho\0";
pub const PRIu16: &[u8; 3usize] = b"hu\0";
pub const PRIx16: &[u8; 3usize] = b"hx\0";
pub const PRIX16: &[u8; 3usize] = b"hX\0";
pub const PRId32: &[u8; 2usize] = b"d\0";
pub const PRIi32: &[u8; 2usize] = b"i\0";
pub const PRIo32: &[u8; 2usize] = b"o\0";
pub const PRIu32: &[u8; 2usize] = b"u\0";
pub const PRIx32: &[u8; 2usize] = b"x\0";
pub const PRIX32: &[u8; 2usize] = b"X\0";
pub const PRId64: &[u8; 4usize] = b"lld\0";
pub const PRIi64: &[u8; 4usize] = b"lli\0";
pub const PRIo64: &[u8; 4usize] = b"llo\0";
pub const PRIu64: &[u8; 4usize] = b"llu\0";
pub const PRIx64: &[u8; 4usize] = b"llx\0";
pub const PRIX64: &[u8; 4usize] = b"llX\0";
pub const PRIdLEAST8: &[u8; 4usize] = b"hhd\0";
pub const PRIiLEAST8: &[u8; 4usize] = b"hhi\0";
pub const PRIoLEAST8: &[u8; 4usize] = b"hho\0";
pub const PRIuLEAST8: &[u8; 4usize] = b"hhu\0";
pub const PRIxLEAST8: &[u8; 4usize] = b"hhx\0";
pub const PRIXLEAST8: &[u8; 4usize] = b"hhX\0";
pub const PRIdLEAST16: &[u8; 3usize] = b"hd\0";
pub const PRIiLEAST16: &[u8; 3usize] = b"hi\0";
pub const PRIoLEAST16: &[u8; 3usize] = b"ho\0";
pub const PRIuLEAST16: &[u8; 3usize] = b"hu\0";
pub const PRIxLEAST16: &[u8; 3usize] = b"hx\0";
pub const PRIXLEAST16: &[u8; 3usize] = b"hX\0";
pub const PRIdLEAST32: &[u8; 2usize] = b"d\0";
pub const PRIiLEAST32: &[u8; 2usize] = b"i\0";
pub const PRIoLEAST32: &[u8; 2usize] = b"o\0";
pub const PRIuLEAST32: &[u8; 2usize] = b"u\0";
pub const PRIxLEAST32: &[u8; 2usize] = b"x\0";
pub const PRIXLEAST32: &[u8; 2usize] = b"X\0";
pub const PRIdLEAST64: &[u8; 4usize] = b"lld\0";
pub const PRIiLEAST64: &[u8; 4usize] = b"lli\0";
pub const PRIoLEAST64: &[u8; 4usize] = b"llo\0";
pub const PRIuLEAST64: &[u8; 4usize] = b"llu\0";
pub const PRIxLEAST64: &[u8; 4usize] = b"llx\0";
pub const PRIXLEAST64: &[u8; 4usize] = b"llX\0";
pub const PRIdFAST8: &[u8; 4usize] = b"hhd\0";
pub const PRIiFAST8: &[u8; 4usize] = b"hhi\0";
pub const PRIoFAST8: &[u8; 4usize] = b"hho\0";
pub const PRIuFAST8: &[u8; 4usize] = b"hhu\0";
pub const PRIxFAST8: &[u8; 4usize] = b"hhx\0";
pub const PRIXFAST8: &[u8; 4usize] = b"hhX\0";
pub const PRIdFAST16: &[u8; 3usize] = b"hd\0";
pub const PRIiFAST16: &[u8; 3usize] = b"hi\0";
pub const PRIoFAST16: &[u8; 3usize] = b"ho\0";
pub const PRIuFAST16: &[u8; 3usize] = b"hu\0";
pub const PRIxFAST16: &[u8; 3usize] = b"hx\0";
pub const PRIXFAST16: &[u8; 3usize] = b"hX\0";
pub const PRIdFAST32: &[u8; 2usize] = b"d\0";
pub const PRIiFAST32: &[u8; 2usize] = b"i\0";
pub const PRIoFAST32: &[u8; 2usize] = b"o\0";
pub const PRIuFAST32: &[u8; 2usize] = b"u\0";
pub const PRIxFAST32: &[u8; 2usize] = b"x\0";
pub const PRIXFAST32: &[u8; 2usize] = b"X\0";
pub const PRIdFAST64: &[u8; 4usize] = b"lld\0";
pub const PRIiFAST64: &[u8; 4usize] = b"lli\0";
pub const PRIoFAST64: &[u8; 4usize] = b"llo\0";
pub const PRIuFAST64: &[u8; 4usize] = b"llu\0";
pub const PRIxFAST64: &[u8; 4usize] = b"llx\0";
pub const PRIXFAST64: &[u8; 4usize] = b"llX\0";
pub const PRIdPTR: &[u8; 3usize] = b"ld\0";
pub const PRIiPTR: &[u8; 3usize] = b"li\0";
pub const PRIoPTR: &[u8; 3usize] = b"lo\0";
pub const PRIuPTR: &[u8; 3usize] = b"lu\0";
pub const PRIxPTR: &[u8; 3usize] = b"lx\0";
pub const PRIXPTR: &[u8; 3usize] = b"lX\0";
pub const PRIdMAX: &[u8; 3usize] = b"jd\0";
pub const PRIiMAX: &[u8; 3usize] = b"ji\0";
pub const PRIoMAX: &[u8; 3usize] = b"jo\0";
pub const PRIuMAX: &[u8; 3usize] = b"ju\0";
pub const PRIxMAX: &[u8; 3usize] = b"jx\0";
pub const PRIXMAX: &[u8; 3usize] = b"jX\0";
pub const SCNd8: &[u8; 4usize] = b"hhd\0";
pub const SCNi8: &[u8; 4usize] = b"hhi\0";
pub const SCNo8: &[u8; 4usize] = b"hho\0";
pub const SCNu8: &[u8; 4usize] = b"hhu\0";
pub const SCNx8: &[u8; 4usize] = b"hhx\0";
pub const SCNd16: &[u8; 3usize] = b"hd\0";
pub const SCNi16: &[u8; 3usize] = b"hi\0";
pub const SCNo16: &[u8; 3usize] = b"ho\0";
pub const SCNu16: &[u8; 3usize] = b"hu\0";
pub const SCNx16: &[u8; 3usize] = b"hx\0";
pub const SCNd32: &[u8; 2usize] = b"d\0";
pub const SCNi32: &[u8; 2usize] = b"i\0";
pub const SCNo32: &[u8; 2usize] = b"o\0";
pub const SCNu32: &[u8; 2usize] = b"u\0";
pub const SCNx32: &[u8; 2usize] = b"x\0";
pub const SCNd64: &[u8; 4usize] = b"lld\0";
pub const SCNi64: &[u8; 4usize] = b"lli\0";
pub const SCNo64: &[u8; 4usize] = b"llo\0";
pub const SCNu64: &[u8; 4usize] = b"llu\0";
pub const SCNx64: &[u8; 4usize] = b"llx\0";
pub const SCNdLEAST8: &[u8; 4usize] = b"hhd\0";
pub const SCNiLEAST8: &[u8; 4usize] = b"hhi\0";
pub const SCNoLEAST8: &[u8; 4usize] = b"hho\0";
pub const SCNuLEAST8: &[u8; 4usize] = b"hhu\0";
pub const SCNxLEAST8: &[u8; 4usize] = b"hhx\0";
pub const SCNdLEAST16: &[u8; 3usize] = b"hd\0";
pub const SCNiLEAST16: &[u8; 3usize] = b"hi\0";
pub const SCNoLEAST16: &[u8; 3usize] = b"ho\0";
pub const SCNuLEAST16: &[u8; 3usize] = b"hu\0";
pub const SCNxLEAST16: &[u8; 3usize] = b"hx\0";
pub const SCNdLEAST32: &[u8; 2usize] = b"d\0";
pub const SCNiLEAST32: &[u8; 2usize] = b"i\0";
pub const SCNoLEAST32: &[u8; 2usize] = b"o\0";
pub const SCNuLEAST32: &[u8; 2usize] = b"u\0";
pub const SCNxLEAST32: &[u8; 2usize] = b"x\0";
pub const SCNdLEAST64: &[u8; 4usize] = b"lld\0";
pub const SCNiLEAST64: &[u8; 4usize] = b"lli\0";
pub const SCNoLEAST64: &[u8; 4usize] = b"llo\0";
pub const SCNuLEAST64: &[u8; 4usize] = b"llu\0";
pub const SCNxLEAST64: &[u8; 4usize] = b"llx\0";
pub const SCNdFAST8: &[u8; 4usize] = b"hhd\0";
pub const SCNiFAST8: &[u8; 4usize] = b"hhi\0";
pub const SCNoFAST8: &[u8; 4usize] = b"hho\0";
pub const SCNuFAST8: &[u8; 4usize] = b"hhu\0";
pub const SCNxFAST8: &[u8; 4usize] = b"hhx\0";
pub const SCNdFAST16: &[u8; 3usize] = b"hd\0";
pub const SCNiFAST16: &[u8; 3usize] = b"hi\0";
pub const SCNoFAST16: &[u8; 3usize] = b"ho\0";
pub const SCNuFAST16: &[u8; 3usize] = b"hu\0";
pub const SCNxFAST16: &[u8; 3usize] = b"hx\0";
pub const SCNdFAST32: &[u8; 2usize] = b"d\0";
pub const SCNiFAST32: &[u8; 2usize] = b"i\0";
pub const SCNoFAST32: &[u8; 2usize] = b"o\0";
pub const SCNuFAST32: &[u8; 2usize] = b"u\0";
pub const SCNxFAST32: &[u8; 2usize] = b"x\0";
pub const SCNdFAST64: &[u8; 4usize] = b"lld\0";
pub const SCNiFAST64: &[u8; 4usize] = b"lli\0";
pub const SCNoFAST64: &[u8; 4usize] = b"llo\0";
pub const SCNuFAST64: &[u8; 4usize] = b"llu\0";
pub const SCNxFAST64: &[u8; 4usize] = b"llx\0";
pub const SCNdPTR: &[u8; 3usize] = b"ld\0";
pub const SCNiPTR: &[u8; 3usize] = b"li\0";
pub const SCNoPTR: &[u8; 3usize] = b"lo\0";
pub const SCNuPTR: &[u8; 3usize] = b"lu\0";
pub const SCNxPTR: &[u8; 3usize] = b"lx\0";
pub const SCNdMAX: &[u8; 3usize] = b"jd\0";
pub const SCNiMAX: &[u8; 3usize] = b"ji\0";
pub const SCNoMAX: &[u8; 3usize] = b"jo\0";
pub const SCNuMAX: &[u8; 3usize] = b"ju\0";
pub const SCNxMAX: &[u8; 3usize] = b"jx\0";
pub const MRB_INT_BIT: u32 = 64;
pub const MRB_INT_MIN: i64 = -9223372036854775808;
pub const MRB_INT_MAX: u64 = 9223372036854775807;
pub const MRB_PRIo: &[u8; 4usize] = b"llo\0";
pub const MRB_PRId: &[u8; 4usize] = b"lld\0";
pub const MRB_PRIx: &[u8; 4usize] = b"llx\0";
pub const MRB_FL_OBJ_IS_FROZEN: u32 = 1048576;
pub const WORDBOX_FIXNUM_BIT_POS: u32 = 1;
pub const WORDBOX_FIXNUM_SHIFT: u32 = 1;
pub const WORDBOX_FIXNUM_FLAG: u32 = 1;
pub const WORDBOX_FIXNUM_MASK: u32 = 1;
pub const WORDBOX_FLOAT_FLAG: u32 = 2;
pub const WORDBOX_FLOAT_MASK: u32 = 3;
pub const WORDBOX_SYMBOL_SHIFT: u32 = 32;
pub const WORDBOX_SYMBOL_FLAG: u32 = 28;
pub const WORDBOX_SYMBOL_MASK: u32 = 31;
pub const WORDBOX_IMMEDIATE_MASK: u32 = 7;
pub const MRB_SSIZE_MAX: u64 = 9223372036854775807;
pub const CPU_STATE_MAX: u32 = 4;
pub const CPU_STATE_USER: u32 = 0;
pub const CPU_STATE_SYSTEM: u32 = 1;
pub const CPU_STATE_IDLE: u32 = 2;
pub const CPU_STATE_NICE: u32 = 3;
pub const CPU_ARCH_MASK: u32 = 4278190080;
pub const CPU_ARCH_ABI64: u32 = 16777216;
pub const CPU_ARCH_ABI64_32: u32 = 33554432;
pub const CPU_SUBTYPE_MASK: u32 = 4278190080;
pub const CPU_SUBTYPE_LIB64: u32 = 2147483648;
pub const CPU_SUBTYPE_PTRAUTH_ABI: u32 = 2147483648;
pub const CPU_SUBTYPE_INTEL_FAMILY_MAX: u32 = 15;
pub const CPU_SUBTYPE_INTEL_MODEL_ALL: u32 = 0;
pub const CPU_SUBTYPE_ARM64_PTR_AUTH_MASK: u32 = 251658240;
pub const CPUFAMILY_UNKNOWN: u32 = 0;
pub const CPUFAMILY_POWERPC_G3: u32 = 3471054153;
pub const CPUFAMILY_POWERPC_G4: u32 = 2009171118;
pub const CPUFAMILY_POWERPC_G5: u32 = 3983988906;
pub const CPUFAMILY_INTEL_6_13: u32 = 2855483691;
pub const CPUFAMILY_INTEL_PENRYN: u32 = 2028621756;
pub const CPUFAMILY_INTEL_NEHALEM: u32 = 1801080018;
pub const CPUFAMILY_INTEL_WESTMERE: u32 = 1463508716;
pub const CPUFAMILY_INTEL_SANDYBRIDGE: u32 = 1418770316;
pub const CPUFAMILY_INTEL_IVYBRIDGE: u32 = 526772277;
pub const CPUFAMILY_INTEL_HASWELL: u32 = 280134364;
pub const CPUFAMILY_INTEL_BROADWELL: u32 = 1479463068;
pub const CPUFAMILY_INTEL_SKYLAKE: u32 = 939270559;
pub const CPUFAMILY_INTEL_KABYLAKE: u32 = 260141638;
pub const CPUFAMILY_INTEL_ICELAKE: u32 = 943936839;
pub const CPUFAMILY_INTEL_COMETLAKE: u32 = 486055998;
pub const CPUFAMILY_ARM_9: u32 = 3878847406;
pub const CPUFAMILY_ARM_11: u32 = 2415272152;
pub const CPUFAMILY_ARM_XSCALE: u32 = 1404044789;
pub const CPUFAMILY_ARM_12: u32 = 3172666089;
pub const CPUFAMILY_ARM_13: u32 = 214503012;
pub const CPUFAMILY_ARM_14: u32 = 2517073649;
pub const CPUFAMILY_ARM_15: u32 = 2823887818;
pub const CPUFAMILY_ARM_SWIFT: u32 = 506291073;
pub const CPUFAMILY_ARM_CYCLONE: u32 = 933271106;
pub const CPUFAMILY_ARM_TYPHOON: u32 = 747742334;
pub const CPUFAMILY_ARM_TWISTER: u32 = 2465937352;
pub const CPUFAMILY_ARM_HURRICANE: u32 = 1741614739;
pub const CPUFAMILY_ARM_MONSOON_MISTRAL: u32 = 3894312694;
pub const CPUFAMILY_ARM_VORTEX_TEMPEST: u32 = 131287967;
pub const CPUFAMILY_ARM_LIGHTNING_THUNDER: u32 = 1176831186;
pub const CPUFAMILY_ARM_FIRESTORM_ICESTORM: u32 = 458787763;
pub const CPUFAMILY_ARM_BLIZZARD_AVALANCHE: u32 = 3660830781;
pub const CPUSUBFAMILY_UNKNOWN: u32 = 0;
pub const CPUSUBFAMILY_ARM_HP: u32 = 1;
pub const CPUSUBFAMILY_ARM_HG: u32 = 2;
pub const CPUSUBFAMILY_ARM_M: u32 = 3;
pub const CPUSUBFAMILY_ARM_HS: u32 = 4;
pub const CPUSUBFAMILY_ARM_HC_HD: u32 = 5;
pub const CPUFAMILY_INTEL_6_23: u32 = 2028621756;
pub const CPUFAMILY_INTEL_6_26: u32 = 1801080018;
pub const __DARWIN_OPAQUE_ARM_THREAD_STATE64: u32 = 0;
pub const ARM_THREAD_STATE_MAX: u32 = 1296;
pub const THREAD_STATE_MAX: u32 = 1296;
pub const MACH_PORT_NULL: u32 = 0;
pub const MACH_PORT_TYPE_DNREQUEST: u32 = 2147483648;
pub const MACH_PORT_TYPE_SPREQUEST: u32 = 1073741824;
pub const MACH_PORT_TYPE_SPREQUEST_DELAYED: u32 = 536870912;
pub const MACH_PORT_SRIGHTS_NONE: u32 = 0;
pub const MACH_PORT_SRIGHTS_PRESENT: u32 = 1;
pub const MACH_PORT_QLIMIT_ZERO: u32 = 0;
pub const MACH_PORT_QLIMIT_BASIC: u32 = 5;
pub const MACH_PORT_QLIMIT_SMALL: u32 = 16;
pub const MACH_PORT_QLIMIT_LARGE: u32 = 1024;
pub const MACH_PORT_QLIMIT_KERNEL: u32 = 65534;
pub const MACH_PORT_QLIMIT_MIN: u32 = 0;
pub const MACH_PORT_QLIMIT_DEFAULT: u32 = 5;
pub const MACH_PORT_QLIMIT_MAX: u32 = 1024;
pub const MACH_PORT_STATUS_FLAG_TEMPOWNER: u32 = 1;
pub const MACH_PORT_STATUS_FLAG_GUARDED: u32 = 2;
pub const MACH_PORT_STATUS_FLAG_STRICT_GUARD: u32 = 4;
pub const MACH_PORT_STATUS_FLAG_IMP_DONATION: u32 = 8;
pub const MACH_PORT_STATUS_FLAG_REVIVE: u32 = 16;
pub const MACH_PORT_STATUS_FLAG_TASKPTR: u32 = 32;
pub const MACH_PORT_STATUS_FLAG_GUARD_IMMOVABLE_RECEIVE: u32 = 64;
pub const MACH_PORT_STATUS_FLAG_NO_GRANT: u32 = 128;
pub const MACH_PORT_LIMITS_INFO: u32 = 1;
pub const MACH_PORT_RECEIVE_STATUS: u32 = 2;
pub const MACH_PORT_DNREQUESTS_SIZE: u32 = 3;
pub const MACH_PORT_TEMPOWNER: u32 = 4;
pub const MACH_PORT_IMPORTANCE_RECEIVER: u32 = 5;
pub const MACH_PORT_DENAP_RECEIVER: u32 = 6;
pub const MACH_PORT_INFO_EXT: u32 = 7;
pub const MACH_PORT_GUARD_INFO: u32 = 8;
pub const MACH_PORT_DNREQUESTS_SIZE_COUNT: u32 = 1;
pub const MACH_SERVICE_PORT_INFO_STRING_NAME_MAX_BUF_LEN: u32 = 255;
pub const MPO_CONTEXT_AS_GUARD: u32 = 1;
pub const MPO_QLIMIT: u32 = 2;
pub const MPO_TEMPOWNER: u32 = 4;
pub const MPO_IMPORTANCE_RECEIVER: u32 = 8;
pub const MPO_INSERT_SEND_RIGHT: u32 = 16;
pub const MPO_STRICT: u32 = 32;
pub const MPO_DENAP_RECEIVER: u32 = 64;
pub const MPO_IMMOVABLE_RECEIVE: u32 = 128;
pub const MPO_FILTER_MSG: u32 = 256;
pub const MPO_TG_BLOCK_TRACKING: u32 = 512;
pub const MPO_SERVICE_PORT: u32 = 1024;
pub const MPO_CONNECTION_PORT: u32 = 2048;
pub const GUARD_TYPE_MACH_PORT: u32 = 1;
pub const MAX_FATAL_kGUARD_EXC_CODE: u32 = 128;
pub const MPG_FLAGS_NONE: u32 = 0;
pub const MAX_OPTIONAL_kGUARD_EXC_CODE: u32 = 524288;
pub const MPG_FLAGS_STRICT_REPLY_INVALID_REPLY_DISP: u64 = 72057594037927936;
pub const MPG_FLAGS_STRICT_REPLY_INVALID_REPLY_PORT: u64 = 144115188075855872;
pub const MPG_FLAGS_STRICT_REPLY_INVALID_VOUCHER: u64 = 288230376151711744;
pub const MPG_FLAGS_STRICT_REPLY_NO_BANK_ATTR: u64 = 576460752303423488;
pub const MPG_FLAGS_STRICT_REPLY_MISMATCHED_PERSONA: u64 = 1152921504606846976;
pub const MPG_FLAGS_STRICT_REPLY_MASK: i64 = -72057594037927936;
pub const MPG_FLAGS_MOD_REFS_PINNED_DEALLOC: u64 = 72057594037927936;
pub const MPG_FLAGS_MOD_REFS_PINNED_DESTROY: u64 = 144115188075855872;
pub const MPG_FLAGS_MOD_REFS_PINNED_COPYIN: u64 = 288230376151711744;
pub const MPG_FLAGS_IMMOVABLE_PINNED: u64 = 72057594037927936;
pub const MPG_STRICT: u32 = 1;
pub const MPG_IMMOVABLE_RECEIVE: u32 = 2;
pub const KERN_SUCCESS: u32 = 0;
pub const KERN_INVALID_ADDRESS: u32 = 1;
pub const KERN_PROTECTION_FAILURE: u32 = 2;
pub const KERN_NO_SPACE: u32 = 3;
pub const KERN_INVALID_ARGUMENT: u32 = 4;
pub const KERN_FAILURE: u32 = 5;
pub const KERN_RESOURCE_SHORTAGE: u32 = 6;
pub const KERN_NOT_RECEIVER: u32 = 7;
pub const KERN_NO_ACCESS: u32 = 8;
pub const KERN_MEMORY_FAILURE: u32 = 9;
pub const KERN_MEMORY_ERROR: u32 = 10;
pub const KERN_ALREADY_IN_SET: u32 = 11;
pub const KERN_NOT_IN_SET: u32 = 12;
pub const KERN_NAME_EXISTS: u32 = 13;
pub const KERN_ABORTED: u32 = 14;
pub const KERN_INVALID_NAME: u32 = 15;
pub const KERN_INVALID_TASK: u32 = 16;
pub const KERN_INVALID_RIGHT: u32 = 17;
pub const KERN_INVALID_VALUE: u32 = 18;
pub const KERN_UREFS_OVERFLOW: u32 = 19;
pub const KERN_INVALID_CAPABILITY: u32 = 20;
pub const KERN_RIGHT_EXISTS: u32 = 21;
pub const KERN_INVALID_HOST: u32 = 22;
pub const KERN_MEMORY_PRESENT: u32 = 23;
pub const KERN_MEMORY_DATA_MOVED: u32 = 24;
pub const KERN_MEMORY_RESTART_COPY: u32 = 25;
pub const KERN_INVALID_PROCESSOR_SET: u32 = 26;
pub const KERN_POLICY_LIMIT: u32 = 27;
pub const KERN_INVALID_POLICY: u32 = 28;
pub const KERN_INVALID_OBJECT: u32 = 29;
pub const KERN_ALREADY_WAITING: u32 = 30;
pub const KERN_DEFAULT_SET: u32 = 31;
pub const KERN_EXCEPTION_PROTECTED: u32 = 32;
pub const KERN_INVALID_LEDGER: u32 = 33;
pub const KERN_INVALID_MEMORY_CONTROL: u32 = 34;
pub const KERN_INVALID_SECURITY: u32 = 35;
pub const KERN_NOT_DEPRESSED: u32 = 36;
pub const KERN_TERMINATED: u32 = 37;
pub const KERN_LOCK_SET_DESTROYED: u32 = 38;
pub const KERN_LOCK_UNSTABLE: u32 = 39;
pub const KERN_LOCK_OWNED: u32 = 40;
pub const KERN_LOCK_OWNED_SELF: u32 = 41;
pub const KERN_SEMAPHORE_DESTROYED: u32 = 42;
pub const KERN_RPC_SERVER_TERMINATED: u32 = 43;
pub const KERN_RPC_TERMINATE_ORPHAN: u32 = 44;
pub const KERN_RPC_CONTINUE_ORPHAN: u32 = 45;
pub const KERN_NOT_SUPPORTED: u32 = 46;
pub const KERN_NODE_DOWN: u32 = 47;
pub const KERN_NOT_WAITING: u32 = 48;
pub const KERN_OPERATION_TIMED_OUT: u32 = 49;
pub const KERN_CODESIGN_ERROR: u32 = 50;
pub const KERN_POLICY_STATIC: u32 = 51;
pub const KERN_INSUFFICIENT_BUFFER_SIZE: u32 = 52;
pub const KERN_DENIED: u32 = 53;
pub const KERN_MISSING_KC: u32 = 54;
pub const KERN_INVALID_KC: u32 = 55;
pub const KERN_NOT_FOUND: u32 = 56;
pub const KERN_RETURN_MAX: u32 = 256;
pub const MACH_MSGH_BITS_ZERO: u32 = 0;
pub const MACH_MSGH_BITS_REMOTE_MASK: u32 = 31;
pub const MACH_MSGH_BITS_LOCAL_MASK: u32 = 7936;
pub const MACH_MSGH_BITS_VOUCHER_MASK: u32 = 2031616;
pub const MACH_MSGH_BITS_PORTS_MASK: u32 = 2039583;
pub const MACH_MSGH_BITS_COMPLEX: u32 = 2147483648;
pub const MACH_MSGH_BITS_USER: u32 = 2149523231;
pub const MACH_MSGH_BITS_RAISEIMP: u32 = 536870912;
pub const MACH_MSGH_BITS_DENAP: u32 = 536870912;
pub const MACH_MSGH_BITS_IMPHOLDASRT: u32 = 268435456;
pub const MACH_MSGH_BITS_DENAPHOLDASRT: u32 = 268435456;
pub const MACH_MSGH_BITS_CIRCULAR: u32 = 268435456;
pub const MACH_MSGH_BITS_USED: u32 = 2954829599;
pub const MACH_MSG_TYPE_MOVE_RECEIVE: u32 = 16;
pub const MACH_MSG_TYPE_MOVE_SEND: u32 = 17;
pub const MACH_MSG_TYPE_MOVE_SEND_ONCE: u32 = 18;
pub const MACH_MSG_TYPE_COPY_SEND: u32 = 19;
pub const MACH_MSG_TYPE_MAKE_SEND: u32 = 20;
pub const MACH_MSG_TYPE_MAKE_SEND_ONCE: u32 = 21;
pub const MACH_MSG_TYPE_COPY_RECEIVE: u32 = 22;
pub const MACH_MSG_TYPE_DISPOSE_RECEIVE: u32 = 24;
pub const MACH_MSG_TYPE_DISPOSE_SEND: u32 = 25;
pub const MACH_MSG_TYPE_DISPOSE_SEND_ONCE: u32 = 26;
pub const MACH_MSG_PHYSICAL_COPY: u32 = 0;
pub const MACH_MSG_VIRTUAL_COPY: u32 = 1;
pub const MACH_MSG_ALLOCATE: u32 = 2;
pub const MACH_MSG_OVERWRITE: u32 = 3;
pub const MACH_MSG_GUARD_FLAGS_NONE: u32 = 0;
pub const MACH_MSG_GUARD_FLAGS_IMMOVABLE_RECEIVE: u32 = 1;
pub const MACH_MSG_GUARD_FLAGS_UNGUARDED_ON_SEND: u32 = 2;
pub const MACH_MSG_GUARD_FLAGS_MASK: u32 = 3;
pub const MACH_MSG_PORT_DESCRIPTOR: u32 = 0;
pub const MACH_MSG_OOL_DESCRIPTOR: u32 = 1;
pub const MACH_MSG_OOL_PORTS_DESCRIPTOR: u32 = 2;
pub const MACH_MSG_OOL_VOLATILE_DESCRIPTOR: u32 = 3;
pub const MACH_MSG_GUARDED_PORT_DESCRIPTOR: u32 = 4;
pub const MACH_MSG_TRAILER_FORMAT_0: u32 = 0;
pub const MACH_MSGH_KIND_NORMAL: u32 = 0;
pub const MACH_MSGH_KIND_NOTIFICATION: u32 = 1;
pub const MACH_MSG_TYPE_PORT_NONE: u32 = 0;
pub const MACH_MSG_TYPE_PORT_NAME: u32 = 15;
pub const MACH_MSG_TYPE_PORT_RECEIVE: u32 = 16;
pub const MACH_MSG_TYPE_PORT_SEND: u32 = 17;
pub const MACH_MSG_TYPE_PORT_SEND_ONCE: u32 = 18;
pub const MACH_MSG_TYPE_LAST: u32 = 22;
pub const MACH_MSG_OPTION_NONE: u32 = 0;
pub const MACH_SEND_MSG: u32 = 1;
pub const MACH_RCV_MSG: u32 = 2;
pub const MACH_RCV_LARGE: u32 = 4;
pub const MACH_RCV_LARGE_IDENTITY: u32 = 8;
pub const MACH_SEND_TIMEOUT: u32 = 16;
pub const MACH_SEND_OVERRIDE: u32 = 32;
pub const MACH_SEND_INTERRUPT: u32 = 64;
pub const MACH_SEND_NOTIFY: u32 = 128;
pub const MACH_SEND_ALWAYS: u32 = 65536;
pub const MACH_SEND_FILTER_NONFATAL: u32 = 65536;
pub const MACH_SEND_TRAILER: u32 = 131072;
pub const MACH_SEND_NOIMPORTANCE: u32 = 262144;
pub const MACH_SEND_NODENAP: u32 = 262144;
pub const MACH_SEND_IMPORTANCE: u32 = 524288;
pub const MACH_SEND_SYNC_OVERRIDE: u32 = 1048576;
pub const MACH_SEND_PROPAGATE_QOS: u32 = 2097152;
pub const MACH_SEND_SYNC_USE_THRPRI: u32 = 2097152;
pub const MACH_SEND_KERNEL: u32 = 4194304;
pub const MACH_SEND_SYNC_BOOTSTRAP_CHECKIN: u32 = 8388608;
pub const MACH_RCV_TIMEOUT: u32 = 256;
pub const MACH_RCV_NOTIFY: u32 = 0;
pub const MACH_RCV_INTERRUPT: u32 = 1024;
pub const MACH_RCV_VOUCHER: u32 = 2048;
pub const MACH_RCV_OVERWRITE: u32 = 0;
pub const MACH_RCV_GUARDED_DESC: u32 = 4096;
pub const MACH_RCV_SYNC_WAIT: u32 = 16384;
pub const MACH_RCV_SYNC_PEEK: u32 = 32768;
pub const MACH_MSG_STRICT_REPLY: u32 = 512;
pub const MACH_RCV_TRAILER_NULL: u32 = 0;
pub const MACH_RCV_TRAILER_SEQNO: u32 = 1;
pub const MACH_RCV_TRAILER_SENDER: u32 = 2;
pub const MACH_RCV_TRAILER_AUDIT: u32 = 3;
pub const MACH_RCV_TRAILER_CTX: u32 = 4;
pub const MACH_RCV_TRAILER_AV: u32 = 7;
pub const MACH_RCV_TRAILER_LABELS: u32 = 8;
pub const MACH_RCV_TRAILER_MASK: u32 = 251658240;
pub const MACH_MSG_SUCCESS: u32 = 0;
pub const MACH_MSG_MASK: u32 = 15872;
pub const MACH_MSG_IPC_SPACE: u32 = 8192;
pub const MACH_MSG_VM_SPACE: u32 = 4096;
pub const MACH_MSG_IPC_KERNEL: u32 = 2048;
pub const MACH_MSG_VM_KERNEL: u32 = 1024;
pub const MACH_SEND_IN_PROGRESS: u32 = 268435457;
pub const MACH_SEND_INVALID_DATA: u32 = 268435458;
pub const MACH_SEND_INVALID_DEST: u32 = 268435459;
pub const MACH_SEND_TIMED_OUT: u32 = 268435460;
pub const MACH_SEND_INVALID_VOUCHER: u32 = 268435461;
pub const MACH_SEND_INTERRUPTED: u32 = 268435463;
pub const MACH_SEND_MSG_TOO_SMALL: u32 = 268435464;
pub const MACH_SEND_INVALID_REPLY: u32 = 268435465;
pub const MACH_SEND_INVALID_RIGHT: u32 = 268435466;
pub const MACH_SEND_INVALID_NOTIFY: u32 = 268435467;
pub const MACH_SEND_INVALID_MEMORY: u32 = 268435468;
pub const MACH_SEND_NO_BUFFER: u32 = 268435469;
pub const MACH_SEND_TOO_LARGE: u32 = 268435470;
pub const MACH_SEND_INVALID_TYPE: u32 = 268435471;
pub const MACH_SEND_INVALID_HEADER: u32 = 268435472;
pub const MACH_SEND_INVALID_TRAILER: u32 = 268435473;
pub const MACH_SEND_INVALID_CONTEXT: u32 = 268435474;
pub const MACH_SEND_INVALID_RT_OOL_SIZE: u32 = 268435477;
pub const MACH_SEND_NO_GRANT_DEST: u32 = 268435478;
pub const MACH_SEND_MSG_FILTERED: u32 = 268435479;
pub const MACH_RCV_IN_PROGRESS: u32 = 268451841;
pub const MACH_RCV_INVALID_NAME: u32 = 268451842;
pub const MACH_RCV_TIMED_OUT: u32 = 268451843;
pub const MACH_RCV_TOO_LARGE: u32 = 268451844;
pub const MACH_RCV_INTERRUPTED: u32 = 268451845;
pub const MACH_RCV_PORT_CHANGED: u32 = 268451846;
pub const MACH_RCV_INVALID_NOTIFY: u32 = 268451847;
pub const MACH_RCV_INVALID_DATA: u32 = 268451848;
pub const MACH_RCV_PORT_DIED: u32 = 268451849;
pub const MACH_RCV_IN_SET: u32 = 268451850;
pub const MACH_RCV_HEADER_ERROR: u32 = 268451851;
pub const MACH_RCV_BODY_ERROR: u32 = 268451852;
pub const MACH_RCV_INVALID_TYPE: u32 = 268451853;
pub const MACH_RCV_SCATTER_SMALL: u32 = 268451854;
pub const MACH_RCV_INVALID_TRAILER: u32 = 268451855;
pub const MACH_RCV_IN_PROGRESS_TIMED: u32 = 268451857;
pub const MACH_RCV_INVALID_REPLY: u32 = 268451858;
pub const PPNUM_MAX: u32 = 4294967295;
pub const ARM_THREAD_STATE: u32 = 1;
pub const ARM_UNIFIED_THREAD_STATE: u32 = 1;
pub const ARM_VFP_STATE: u32 = 2;
pub const ARM_EXCEPTION_STATE: u32 = 3;
pub const ARM_DEBUG_STATE: u32 = 4;
pub const THREAD_STATE_NONE: u32 = 5;
pub const ARM_THREAD_STATE64: u32 = 6;
pub const ARM_EXCEPTION_STATE64: u32 = 7;
pub const ARM_THREAD_STATE32: u32 = 9;
pub const ARM_DEBUG_STATE32: u32 = 14;
pub const ARM_DEBUG_STATE64: u32 = 15;
pub const ARM_NEON_STATE: u32 = 16;
pub const ARM_NEON_STATE64: u32 = 17;
pub const ARM_CPMU_STATE64: u32 = 18;
pub const ARM_PAGEIN_STATE: u32 = 27;
pub const MACHINE_THREAD_STATE: u32 = 1;
pub const THREAD_MACHINE_STATE_MAX: u32 = 1296;
pub const MH_MAGIC: u32 = 4277009102;
pub const MH_CIGAM: u32 = 3472551422;
pub const MH_MAGIC_64: u32 = 4277009103;
pub const MH_CIGAM_64: u32 = 3489328638;
pub const MH_OBJECT: u32 = 1;
pub const MH_EXECUTE: u32 = 2;
pub const MH_FVMLIB: u32 = 3;
pub const MH_CORE: u32 = 4;
pub const MH_PRELOAD: u32 = 5;
pub const MH_DYLIB: u32 = 6;
pub const MH_DYLINKER: u32 = 7;
pub const MH_BUNDLE: u32 = 8;
pub const MH_DYLIB_STUB: u32 = 9;
pub const MH_DSYM: u32 = 10;
pub const MH_KEXT_BUNDLE: u32 = 11;
pub const MH_FILESET: u32 = 12;
pub const MH_NOUNDEFS: u32 = 1;
pub const MH_INCRLINK: u32 = 2;
pub const MH_DYLDLINK: u32 = 4;
pub const MH_BINDATLOAD: u32 = 8;
pub const MH_PREBOUND: u32 = 16;
pub const MH_SPLIT_SEGS: u32 = 32;
pub const MH_LAZY_INIT: u32 = 64;
pub const MH_TWOLEVEL: u32 = 128;
pub const MH_FORCE_FLAT: u32 = 256;
pub const MH_NOMULTIDEFS: u32 = 512;
pub const MH_NOFIXPREBINDING: u32 = 1024;
pub const MH_PREBINDABLE: u32 = 2048;
pub const MH_ALLMODSBOUND: u32 = 4096;
pub const MH_SUBSECTIONS_VIA_SYMBOLS: u32 = 8192;
pub const MH_CANONICAL: u32 = 16384;
pub const MH_WEAK_DEFINES: u32 = 32768;
pub const MH_BINDS_TO_WEAK: u32 = 65536;
pub const MH_ALLOW_STACK_EXECUTION: u32 = 131072;
pub const MH_ROOT_SAFE: u32 = 262144;
pub const MH_SETUID_SAFE: u32 = 524288;
pub const MH_NO_REEXPORTED_DYLIBS: u32 = 1048576;
pub const MH_PIE: u32 = 2097152;
pub const MH_DEAD_STRIPPABLE_DYLIB: u32 = 4194304;
pub const MH_HAS_TLV_DESCRIPTORS: u32 = 8388608;
pub const MH_NO_HEAP_EXECUTION: u32 = 16777216;
pub const MH_APP_EXTENSION_SAFE: u32 = 33554432;
pub const MH_NLIST_OUTOFSYNC_WITH_DYLDINFO: u32 = 67108864;
pub const MH_SIM_SUPPORT: u32 = 134217728;
pub const MH_DYLIB_IN_CACHE: u32 = 2147483648;
pub const LC_REQ_DYLD: u32 = 2147483648;
pub const LC_SEGMENT: u32 = 1;
pub const LC_SYMTAB: u32 = 2;
pub const LC_SYMSEG: u32 = 3;
pub const LC_THREAD: u32 = 4;
pub const LC_UNIXTHREAD: u32 = 5;
pub const LC_LOADFVMLIB: u32 = 6;
pub const LC_IDFVMLIB: u32 = 7;
pub const LC_IDENT: u32 = 8;
pub const LC_FVMFILE: u32 = 9;
pub const LC_PREPAGE: u32 = 10;
pub const LC_DYSYMTAB: u32 = 11;
pub const LC_LOAD_DYLIB: u32 = 12;
pub const LC_ID_DYLIB: u32 = 13;
pub const LC_LOAD_DYLINKER: u32 = 14;
pub const LC_ID_DYLINKER: u32 = 15;
pub const LC_PREBOUND_DYLIB: u32 = 16;
pub const LC_ROUTINES: u32 = 17;
pub const LC_SUB_FRAMEWORK: u32 = 18;
pub const LC_SUB_UMBRELLA: u32 = 19;
pub const LC_SUB_CLIENT: u32 = 20;
pub const LC_SUB_LIBRARY: u32 = 21;
pub const LC_TWOLEVEL_HINTS: u32 = 22;
pub const LC_PREBIND_CKSUM: u32 = 23;
pub const LC_LOAD_WEAK_DYLIB: u32 = 2147483672;
pub const LC_SEGMENT_64: u32 = 25;
pub const LC_ROUTINES_64: u32 = 26;
pub const LC_UUID: u32 = 27;
pub const LC_RPATH: u32 = 2147483676;
pub const LC_CODE_SIGNATURE: u32 = 29;
pub const LC_SEGMENT_SPLIT_INFO: u32 = 30;
pub const LC_REEXPORT_DYLIB: u32 = 2147483679;
pub const LC_LAZY_LOAD_DYLIB: u32 = 32;
pub const LC_ENCRYPTION_INFO: u32 = 33;
pub const LC_DYLD_INFO: u32 = 34;
pub const LC_DYLD_INFO_ONLY: u32 = 2147483682;
pub const LC_LOAD_UPWARD_DYLIB: u32 = 2147483683;
pub const LC_VERSION_MIN_MACOSX: u32 = 36;
pub const LC_VERSION_MIN_IPHONEOS: u32 = 37;
pub const LC_FUNCTION_STARTS: u32 = 38;
pub const LC_DYLD_ENVIRONMENT: u32 = 39;
pub const LC_MAIN: u32 = 2147483688;
pub const LC_DATA_IN_CODE: u32 = 41;
pub const LC_SOURCE_VERSION: u32 = 42;
pub const LC_DYLIB_CODE_SIGN_DRS: u32 = 43;
pub const LC_ENCRYPTION_INFO_64: u32 = 44;
pub const LC_LINKER_OPTION: u32 = 45;
pub const LC_LINKER_OPTIMIZATION_HINT: u32 = 46;
pub const LC_VERSION_MIN_TVOS: u32 = 47;
pub const LC_VERSION_MIN_WATCHOS: u32 = 48;
pub const LC_NOTE: u32 = 49;
pub const LC_BUILD_VERSION: u32 = 50;
pub const LC_DYLD_EXPORTS_TRIE: u32 = 2147483699;
pub const LC_DYLD_CHAINED_FIXUPS: u32 = 2147483700;
pub const LC_FILESET_ENTRY: u32 = 2147483701;
pub const SG_HIGHVM: u32 = 1;
pub const SG_FVMLIB: u32 = 2;
pub const SG_NORELOC: u32 = 4;
pub const SG_PROTECTED_VERSION_1: u32 = 8;
pub const SG_READ_ONLY: u32 = 16;
pub const SECTION_TYPE: u32 = 255;
pub const SECTION_ATTRIBUTES: u32 = 4294967040;
pub const S_REGULAR: u32 = 0;
pub const S_ZEROFILL: u32 = 1;
pub const S_CSTRING_LITERALS: u32 = 2;
pub const S_4BYTE_LITERALS: u32 = 3;
pub const S_8BYTE_LITERALS: u32 = 4;
pub const S_LITERAL_POINTERS: u32 = 5;
pub const S_NON_LAZY_SYMBOL_POINTERS: u32 = 6;
pub const S_LAZY_SYMBOL_POINTERS: u32 = 7;
pub const S_SYMBOL_STUBS: u32 = 8;
pub const S_MOD_INIT_FUNC_POINTERS: u32 = 9;
pub const S_MOD_TERM_FUNC_POINTERS: u32 = 10;
pub const S_COALESCED: u32 = 11;
pub const S_GB_ZEROFILL: u32 = 12;
pub const S_INTERPOSING: u32 = 13;
pub const S_16BYTE_LITERALS: u32 = 14;
pub const S_DTRACE_DOF: u32 = 15;
pub const S_LAZY_DYLIB_SYMBOL_POINTERS: u32 = 16;
pub const S_THREAD_LOCAL_REGULAR: u32 = 17;
pub const S_THREAD_LOCAL_ZEROFILL: u32 = 18;
pub const S_THREAD_LOCAL_VARIABLES: u32 = 19;
pub const S_THREAD_LOCAL_VARIABLE_POINTERS: u32 = 20;
pub const S_THREAD_LOCAL_INIT_FUNCTION_POINTERS: u32 = 21;
pub const S_INIT_FUNC_OFFSETS: u32 = 22;
pub const SECTION_ATTRIBUTES_USR: u32 = 4278190080;
pub const S_ATTR_PURE_INSTRUCTIONS: u32 = 2147483648;
pub const S_ATTR_NO_TOC: u32 = 1073741824;
pub const S_ATTR_STRIP_STATIC_SYMS: u32 = 536870912;
pub const S_ATTR_NO_DEAD_STRIP: u32 = 268435456;
pub const S_ATTR_LIVE_SUPPORT: u32 = 134217728;
pub const S_ATTR_SELF_MODIFYING_CODE: u32 = 67108864;
pub const S_ATTR_DEBUG: u32 = 33554432;
pub const SECTION_ATTRIBUTES_SYS: u32 = 16776960;
pub const S_ATTR_SOME_INSTRUCTIONS: u32 = 1024;
pub const S_ATTR_EXT_RELOC: u32 = 512;
pub const S_ATTR_LOC_RELOC: u32 = 256;
pub const SEG_PAGEZERO: &[u8; 11usize] = b"__PAGEZERO\0";
pub const SEG_TEXT: &[u8; 7usize] = b"__TEXT\0";
pub const SECT_TEXT: &[u8; 7usize] = b"__text\0";
pub const SECT_FVMLIB_INIT0: &[u8; 15usize] = b"__fvmlib_init0\0";
pub const SECT_FVMLIB_INIT1: &[u8; 15usize] = b"__fvmlib_init1\0";
pub const SEG_DATA: &[u8; 7usize] = b"__DATA\0";
pub const SECT_DATA: &[u8; 7usize] = b"__data\0";
pub const SECT_BSS: &[u8; 6usize] = b"__bss\0";
pub const SECT_COMMON: &[u8; 9usize] = b"__common\0";
pub const SEG_OBJC: &[u8; 7usize] = b"__OBJC\0";
pub const SECT_OBJC_SYMBOLS: &[u8; 15usize] = b"__symbol_table\0";
pub const SECT_OBJC_MODULES: &[u8; 14usize] = b"__module_info\0";
pub const SECT_OBJC_STRINGS: &[u8; 16usize] = b"__selector_strs\0";
pub const SECT_OBJC_REFS: &[u8; 16usize] = b"__selector_refs\0";
pub const SEG_ICON: &[u8; 7usize] = b"__ICON\0";
pub const SECT_ICON_HEADER: &[u8; 9usize] = b"__header\0";
pub const SECT_ICON_TIFF: &[u8; 7usize] = b"__tiff\0";
pub const SEG_LINKEDIT: &[u8; 11usize] = b"__LINKEDIT\0";
pub const SEG_UNIXSTACK: &[u8; 12usize] = b"__UNIXSTACK\0";
pub const SEG_IMPORT: &[u8; 9usize] = b"__IMPORT\0";
pub const INDIRECT_SYMBOL_LOCAL: u32 = 2147483648;
pub const INDIRECT_SYMBOL_ABS: u32 = 1073741824;
pub const PLATFORM_MACOS: u32 = 1;
pub const PLATFORM_IOS: u32 = 2;
pub const PLATFORM_TVOS: u32 = 3;
pub const PLATFORM_WATCHOS: u32 = 4;
pub const PLATFORM_BRIDGEOS: u32 = 5;
pub const PLATFORM_MACCATALYST: u32 = 6;
pub const PLATFORM_IOSSIMULATOR: u32 = 7;
pub const PLATFORM_TVOSSIMULATOR: u32 = 8;
pub const PLATFORM_WATCHOSSIMULATOR: u32 = 9;
pub const PLATFORM_DRIVERKIT: u32 = 10;
pub const PLATFORM_FIRMWARE: u32 = 13;
pub const PLATFORM_SEPOS: u32 = 14;
pub const TOOL_CLANG: u32 = 1;
pub const TOOL_SWIFT: u32 = 2;
pub const TOOL_LD: u32 = 3;
pub const TOOL_LLD: u32 = 4;
pub const REBASE_TYPE_POINTER: u32 = 1;
pub const REBASE_TYPE_TEXT_ABSOLUTE32: u32 = 2;
pub const REBASE_TYPE_TEXT_PCREL32: u32 = 3;
pub const REBASE_OPCODE_MASK: u32 = 240;
pub const REBASE_IMMEDIATE_MASK: u32 = 15;
pub const REBASE_OPCODE_DONE: u32 = 0;
pub const REBASE_OPCODE_SET_TYPE_IMM: u32 = 16;
pub const REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB: u32 = 32;
pub const REBASE_OPCODE_ADD_ADDR_ULEB: u32 = 48;
pub const REBASE_OPCODE_ADD_ADDR_IMM_SCALED: u32 = 64;
pub const REBASE_OPCODE_DO_REBASE_IMM_TIMES: u32 = 80;
pub const REBASE_OPCODE_DO_REBASE_ULEB_TIMES: u32 = 96;
pub const REBASE_OPCODE_DO_REBASE_ADD_ADDR_ULEB: u32 = 112;
pub const REBASE_OPCODE_DO_REBASE_ULEB_TIMES_SKIPPING_ULEB: u32 = 128;
pub const BIND_TYPE_POINTER: u32 = 1;
pub const BIND_TYPE_TEXT_ABSOLUTE32: u32 = 2;
pub const BIND_TYPE_TEXT_PCREL32: u32 = 3;
pub const BIND_SPECIAL_DYLIB_SELF: u32 = 0;
pub const BIND_SPECIAL_DYLIB_MAIN_EXECUTABLE: i32 = -1;
pub const BIND_SPECIAL_DYLIB_FLAT_LOOKUP: i32 = -2;
pub const BIND_SPECIAL_DYLIB_WEAK_LOOKUP: i32 = -3;
pub const BIND_SYMBOL_FLAGS_WEAK_IMPORT: u32 = 1;
pub const BIND_SYMBOL_FLAGS_NON_WEAK_DEFINITION: u32 = 8;
pub const BIND_OPCODE_MASK: u32 = 240;
pub const BIND_IMMEDIATE_MASK: u32 = 15;
pub const BIND_OPCODE_DONE: u32 = 0;
pub const BIND_OPCODE_SET_DYLIB_ORDINAL_IMM: u32 = 16;
pub const BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB: u32 = 32;
pub const BIND_OPCODE_SET_DYLIB_SPECIAL_IMM: u32 = 48;
pub const BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM: u32 = 64;
pub const BIND_OPCODE_SET_TYPE_IMM: u32 = 80;
pub const BIND_OPCODE_SET_ADDEND_SLEB: u32 = 96;
pub const BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB: u32 = 112;
pub const BIND_OPCODE_ADD_ADDR_ULEB: u32 = 128;
pub const BIND_OPCODE_DO_BIND: u32 = 144;
pub const BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB: u32 = 160;
pub const BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED: u32 = 176;
pub const BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB: u32 = 192;
pub const BIND_OPCODE_THREADED: u32 = 208;
pub const BIND_SUBOPCODE_THREADED_SET_BIND_ORDINAL_TABLE_SIZE_ULEB: u32 = 0;
pub const BIND_SUBOPCODE_THREADED_APPLY: u32 = 1;
pub const EXPORT_SYMBOL_FLAGS_KIND_MASK: u32 = 3;
pub const EXPORT_SYMBOL_FLAGS_KIND_REGULAR: u32 = 0;
pub const EXPORT_SYMBOL_FLAGS_KIND_THREAD_LOCAL: u32 = 1;
pub const EXPORT_SYMBOL_FLAGS_KIND_ABSOLUTE: u32 = 2;
pub const EXPORT_SYMBOL_FLAGS_WEAK_DEFINITION: u32 = 4;
pub const EXPORT_SYMBOL_FLAGS_REEXPORT: u32 = 8;
pub const EXPORT_SYMBOL_FLAGS_STUB_AND_RESOLVER: u32 = 16;
pub const EXPORT_SYMBOL_FLAGS_STATIC_RESOLVER: u32 = 32;
pub const DICE_KIND_DATA: u32 = 1;
pub const DICE_KIND_JUMP_TABLE8: u32 = 2;
pub const DICE_KIND_JUMP_TABLE16: u32 = 3;
pub const DICE_KIND_JUMP_TABLE32: u32 = 4;
pub const DICE_KIND_ABS_JUMP_TABLE32: u32 = 5;
pub const MRB_EACH_OBJ_OK: u32 = 0;
pub const MRB_EACH_OBJ_BREAK: u32 = 1;
pub const MRB_GC_ARENA_SIZE: u32 = 100;
pub const MRB_GC_RED: u32 = 7;
pub const MRUBY_RUBY_VERSION: &[u8; 4usize] = b"3.1\0";
pub const MRUBY_RUBY_ENGINE: &[u8; 6usize] = b"mruby\0";
pub const MRUBY_RELEASE_MAJOR: u32 = 3;
pub const MRUBY_RELEASE_MINOR: u32 = 1;
pub const MRUBY_RELEASE_TEENY: u32 = 0;
pub const MRUBY_PATCHLEVEL: i32 = -1;
pub const MRUBY_PATCHLEVEL_STR: &[u8; 1usize] = b"\0";
pub const MRUBY_RELEASE_NO: u32 = 30100;
pub const MRUBY_RELEASE_YEAR: u32 = 2022;
pub const MRUBY_RELEASE_MONTH: u32 = 5;
pub const MRUBY_RELEASE_DAY: u32 = 12;
pub const MRUBY_BIRTH_YEAR: u32 = 2010;
pub const MRUBY_AUTHOR: &[u8; 17usize] = b"mruby developers\0";
pub const FP_NAN: u32 = 1;
pub const FP_INFINITE: u32 = 2;
pub const FP_ZERO: u32 = 3;
pub const FP_NORMAL: u32 = 4;
pub const FP_SUBNORMAL: u32 = 5;
pub const FP_SUPERNORMAL: u32 = 6;
pub const FP_FAST_FMA: u32 = 1;
pub const FP_FAST_FMAF: u32 = 1;
pub const FP_FAST_FMAL: u32 = 1;
pub const FP_ILOGB0: i32 = -2147483648;
pub const FP_ILOGBNAN: i32 = -2147483648;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const FP_SNAN: u32 = 1;
pub const FP_QNAN: u32 = 1;
pub const DOMAIN: u32 = 1;
pub const SING: u32 = 2;
pub const OVERFLOW: u32 = 3;
pub const UNDERFLOW: u32 = 4;
pub const TLOSS: u32 = 5;
pub const PLOSS: u32 = 6;
pub const FLT_HAS_SUBNORM: u32 = 1;
pub const DBL_HAS_SUBNORM: u32 = 1;
pub const LDBL_HAS_SUBNORM: u32 = 1;
pub const MRB_FIXED_STATE_ATEXIT_STACK_SIZE: u32 = 5;
pub const MRB_METHOD_CACHE_SIZE: u32 = 256;
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        128usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    fn test_field___mbstate8() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__mbstate_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__mbstate8) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__mbstate_t),
                "::",
                stringify!(__mbstate8)
            )
        );
    }
    test_field___mbstate8();
    fn test_field__mbstateL() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__mbstate_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._mbstateL) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__mbstate_t),
                "::",
                stringify!(_mbstateL)
            )
        );
    }
    test_field__mbstateL();
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_pthread_handler_rec>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_pthread_handler_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_pthread_handler_rec))
    );
    fn test_field___routine() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_pthread_handler_rec>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__routine) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_pthread_handler_rec),
                "::",
                stringify!(__routine)
            )
        );
    }
    test_field___routine();
    fn test_field___arg() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_pthread_handler_rec>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__arg) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_pthread_handler_rec),
                "::",
                stringify!(__arg)
            )
        );
    }
    test_field___arg();
    fn test_field___next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_pthread_handler_rec>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_pthread_handler_rec),
                "::",
                stringify!(__next)
            )
        );
    }
    test_field___next();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_attr_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_attr_t))
    );
    fn test_field___sig() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_attr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_attr_t),
                "::",
                stringify!(__sig)
            )
        );
    }
    test_field___sig();
    fn test_field___opaque() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_attr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_attr_t),
                "::",
                stringify!(__opaque)
            )
        );
    }
    test_field___opaque();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_cond_t))
    );
    fn test_field___sig() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_cond_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_cond_t),
                "::",
                stringify!(__sig)
            )
        );
    }
    test_field___sig();
    fn test_field___opaque() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_cond_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_cond_t),
                "::",
                stringify!(__opaque)
            )
        );
    }
    test_field___opaque();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_condattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_condattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_condattr_t))
    );
    fn test_field___sig() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_condattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_condattr_t),
                "::",
                stringify!(__sig)
            )
        );
    }
    test_field___sig();
    fn test_field___opaque() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_condattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_condattr_t),
                "::",
                stringify!(__opaque)
            )
        );
    }
    test_field___opaque();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutex_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutex_t))
    );
    fn test_field___sig() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_mutex_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_mutex_t),
                "::",
                stringify!(__sig)
            )
        );
    }
    test_field___sig();
    fn test_field___opaque() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_mutex_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_mutex_t),
                "::",
                stringify!(__opaque)
            )
        );
    }
    test_field___opaque();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutexattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutexattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutexattr_t))
    );
    fn test_field___sig() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_mutexattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_mutexattr_t),
                "::",
                stringify!(__sig)
            )
        );
    }
    test_field___sig();
    fn test_field___opaque() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_mutexattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_mutexattr_t),
                "::",
                stringify!(__opaque)
            )
        );
    }
    test_field___opaque();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_once_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_once_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_once_t))
    );
    fn test_field___sig() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_once_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_once_t),
                "::",
                stringify!(__sig)
            )
        );
    }
    test_field___sig();
    fn test_field___opaque() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_once_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_once_t),
                "::",
                stringify!(__opaque)
            )
        );
    }
    test_field___opaque();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlock_t>(),
        200usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlock_t))
    );
    fn test_field___sig() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_rwlock_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_rwlock_t),
                "::",
                stringify!(__sig)
            )
        );
    }
    test_field___sig();
    fn test_field___opaque() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_rwlock_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_rwlock_t),
                "::",
                stringify!(__opaque)
            )
        );
    }
    test_field___opaque();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlockattr_t>(),
        24usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    fn test_field___sig() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_rwlockattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_rwlockattr_t),
                "::",
                stringify!(__sig)
            )
        );
    }
    test_field___sig();
    fn test_field___opaque() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_rwlockattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_rwlockattr_t),
                "::",
                stringify!(__opaque)
            )
        );
    }
    test_field___opaque();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_t>(),
        8192usize,
        concat!("Size of: ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_t))
    );
    fn test_field___sig() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_t),
                "::",
                stringify!(__sig)
            )
        );
    }
    test_field___sig();
    fn test_field___cleanup_stack() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__cleanup_stack) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_t),
                "::",
                stringify!(__cleanup_stack)
            )
        );
    }
    test_field___cleanup_stack();
    fn test_field___opaque() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_t),
                "::",
                stringify!(__opaque)
            )
        );
    }
    test_field___opaque();
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub type size_t = ::std::os::raw::c_ulong;
pub type rsize_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
pub type max_align_t = f64;
pub type __darwin_nl_item = ::std::os::raw::c_int;
pub type __darwin_wctrans_t = ::std::os::raw::c_int;
pub type __darwin_wctype_t = __uint32_t;
extern "C" {
    pub fn renameat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renamex_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameatx_np(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
        arg5: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
pub type fpos_t = __darwin_off_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut ::std::os::raw::c_uchar,
    pub _size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sbuf() {
    assert_eq!(
        ::std::mem::size_of::<__sbuf>(),
        16usize,
        concat!("Size of: ", stringify!(__sbuf))
    );
    assert_eq!(
        ::std::mem::align_of::<__sbuf>(),
        8usize,
        concat!("Alignment of ", stringify!(__sbuf))
    );
    fn test_field__base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sbuf>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__sbuf),
                "::",
                stringify!(_base)
            )
        );
    }
    test_field__base();
    fn test_field__size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sbuf>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._size) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__sbuf),
                "::",
                stringify!(_size)
            )
        );
    }
    test_field__size();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILEX {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut ::std::os::raw::c_uchar,
    pub _r: ::std::os::raw::c_int,
    pub _w: ::std::os::raw::c_int,
    pub _flags: ::std::os::raw::c_short,
    pub _file: ::std::os::raw::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::std::os::raw::c_int,
    pub _cookie: *mut ::std::os::raw::c_void,
    pub _close: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    pub _read: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *mut ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _seek: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: fpos_t,
            arg3: ::std::os::raw::c_int,
        ) -> fpos_t,
    >,
    pub _write: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *const ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _ub: __sbuf,
    pub _extra: *mut __sFILEX,
    pub _ur: ::std::os::raw::c_int,
    pub _ubuf: [::std::os::raw::c_uchar; 3usize],
    pub _nbuf: [::std::os::raw::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::std::os::raw::c_int,
    pub _offset: fpos_t,
}
#[test]
fn bindgen_test_layout___sFILE() {
    assert_eq!(
        ::std::mem::size_of::<__sFILE>(),
        152usize,
        concat!("Size of: ", stringify!(__sFILE))
    );
    assert_eq!(
        ::std::mem::align_of::<__sFILE>(),
        8usize,
        concat!("Alignment of ", stringify!(__sFILE))
    );
    fn test_field__p() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._p) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_p)
            )
        );
    }
    test_field__p();
    fn test_field__r() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._r) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_r)
            )
        );
    }
    test_field__r();
    fn test_field__w() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._w) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_w)
            )
        );
    }
    test_field__w();
    fn test_field__flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_flags)
            )
        );
    }
    test_field__flags();
    fn test_field__file() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._file) as usize - ptr as usize
            },
            18usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_file)
            )
        );
    }
    test_field__file();
    fn test_field__bf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._bf) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_bf)
            )
        );
    }
    test_field__bf();
    fn test_field__lbfsize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._lbfsize) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_lbfsize)
            )
        );
    }
    test_field__lbfsize();
    fn test_field__cookie() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._cookie) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_cookie)
            )
        );
    }
    test_field__cookie();
    fn test_field__close() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._close) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_close)
            )
        );
    }
    test_field__close();
    fn test_field__read() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._read) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_read)
            )
        );
    }
    test_field__read();
    fn test_field__seek() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._seek) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_seek)
            )
        );
    }
    test_field__seek();
    fn test_field__write() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._write) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_write)
            )
        );
    }
    test_field__write();
    fn test_field__ub() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._ub) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_ub)
            )
        );
    }
    test_field__ub();
    fn test_field__extra() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._extra) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_extra)
            )
        );
    }
    test_field__extra();
    fn test_field__ur() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._ur) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_ur)
            )
        );
    }
    test_field__ur();
    fn test_field__ubuf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._ubuf) as usize - ptr as usize
            },
            116usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_ubuf)
            )
        );
    }
    test_field__ubuf();
    fn test_field__nbuf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._nbuf) as usize - ptr as usize
            },
            119usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_nbuf)
            )
        );
    }
    test_field__nbuf();
    fn test_field__lb() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._lb) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_lb)
            )
        );
    }
    test_field__lb();
    fn test_field__blksize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._blksize) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_blksize)
            )
        );
    }
    test_field__blksize();
    fn test_field__offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_offset)
            )
        );
    }
    test_field__offset();
}
pub type FILE = __sFILE;
extern "C" {
    pub static mut __stdinp: *mut FILE;
}
extern "C" {
    pub static mut __stdoutp: *mut FILE;
}
extern "C" {
    pub static mut __stderrp: *mut FILE;
}
extern "C" {
    pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
    pub fn fclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn feof(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputs(arg1: *const ::std::os::raw::c_char, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __nitems: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn freopen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseek(
        arg1: *mut FILE,
        arg2: ::std::os::raw::c_long,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(arg1: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __nitems: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn getc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gets(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn perror(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn printf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn remove(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rewind(arg1: *mut FILE);
}
extern "C" {
    pub fn scanf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuf(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ungetc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        arg1: *const ::std::os::raw::c_char,
        arg2: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fdopen(arg1: ::std::os::raw::c_int, arg2: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fileno(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn __srget(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __svfscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __swbuf(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn getc_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __prefix: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type off_t = __darwin_off_t;
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __offset: off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> off_t;
}
extern "C" {
    pub fn snprintf(
        __str: *mut ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        arg1: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        arg1: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __str: *mut ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        arg1: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __str: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        arg1: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
pub type ssize_t = __darwin_ssize_t;
extern "C" {
    pub fn dprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdelim(
        __linep: *mut *mut ::std::os::raw::c_char,
        __linecapp: *mut size_t,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> ssize_t;
}
extern "C" {
    pub fn getline(
        __linep: *mut *mut ::std::os::raw::c_char,
        __linecapp: *mut size_t,
        __stream: *mut FILE,
    ) -> ssize_t;
}
extern "C" {
    pub fn fmemopen(
        __buf: *mut ::std::os::raw::c_void,
        __size: size_t,
        __mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufp: *mut *mut ::std::os::raw::c_char,
        __sizep: *mut size_t,
    ) -> *mut FILE;
}
extern "C" {
    pub static sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn asprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid_r(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fgetln(arg1: *mut FILE, arg2: *mut size_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fmtcheck(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn fpurge(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn setlinebuf(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vasprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funopen(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: fpos_t,
                arg3: ::std::os::raw::c_int,
            ) -> fpos_t,
        >,
        arg5: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
        >,
    ) -> *mut FILE;
}
extern "C" {
    pub fn __sprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: size_t,
        arg4: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __snprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: size_t,
        arg3: ::std::os::raw::c_int,
        arg4: size_t,
        arg5: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __vsprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: size_t,
        arg4: *const ::std::os::raw::c_char,
        arg5: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __vsnprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: size_t,
        arg3: ::std::os::raw::c_int,
        arg4: size_t,
        arg5: *const ::std::os::raw::c_char,
        arg6: va_list,
    ) -> ::std::os::raw::c_int;
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _OSUnalignedU16 {
    pub __val: u16,
}
#[test]
fn bindgen_test_layout__OSUnalignedU16() {
    assert_eq!(
        ::std::mem::size_of::<_OSUnalignedU16>(),
        2usize,
        concat!("Size of: ", stringify!(_OSUnalignedU16))
    );
    assert_eq!(
        ::std::mem::align_of::<_OSUnalignedU16>(),
        1usize,
        concat!("Alignment of ", stringify!(_OSUnalignedU16))
    );
    fn test_field___val() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_OSUnalignedU16>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_OSUnalignedU16),
                "::",
                stringify!(__val)
            )
        );
    }
    test_field___val();
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _OSUnalignedU32 {
    pub __val: u32,
}
#[test]
fn bindgen_test_layout__OSUnalignedU32() {
    assert_eq!(
        ::std::mem::size_of::<_OSUnalignedU32>(),
        4usize,
        concat!("Size of: ", stringify!(_OSUnalignedU32))
    );
    assert_eq!(
        ::std::mem::align_of::<_OSUnalignedU32>(),
        1usize,
        concat!("Alignment of ", stringify!(_OSUnalignedU32))
    );
    fn test_field___val() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_OSUnalignedU32>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_OSUnalignedU32),
                "::",
                stringify!(__val)
            )
        );
    }
    test_field___val();
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _OSUnalignedU64 {
    pub __val: u64,
}
#[test]
fn bindgen_test_layout__OSUnalignedU64() {
    assert_eq!(
        ::std::mem::size_of::<_OSUnalignedU64>(),
        8usize,
        concat!("Size of: ", stringify!(_OSUnalignedU64))
    );
    assert_eq!(
        ::std::mem::align_of::<_OSUnalignedU64>(),
        1usize,
        concat!("Alignment of ", stringify!(_OSUnalignedU64))
    );
    fn test_field___val() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_OSUnalignedU64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_OSUnalignedU64),
                "::",
                stringify!(__val)
            )
        );
    }
    test_field___val();
}
pub type u_char = ::std::os::raw::c_uchar;
pub type u_short = ::std::os::raw::c_ushort;
pub type u_int = ::std::os::raw::c_uint;
pub type u_long = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_quad_t = u_int64_t;
pub type quad_t = i64;
pub type qaddr_t = *mut quad_t;
pub type caddr_t = *mut ::std::os::raw::c_char;
pub type daddr_t = i32;
pub type dev_t = __darwin_dev_t;
pub type fixpt_t = u_int32_t;
pub type blkcnt_t = __darwin_blkcnt_t;
pub type blksize_t = __darwin_blksize_t;
pub type gid_t = __darwin_gid_t;
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type ino_t = __darwin_ino_t;
pub type ino64_t = __darwin_ino64_t;
pub type key_t = __int32_t;
pub type mode_t = __darwin_mode_t;
pub type nlink_t = __uint16_t;
pub type id_t = __darwin_id_t;
pub type pid_t = __darwin_pid_t;
pub type segsz_t = i32;
pub type swblk_t = i32;
pub type uid_t = __darwin_uid_t;
pub type clock_t = __darwin_clock_t;
pub type time_t = __darwin_time_t;
pub type useconds_t = __darwin_useconds_t;
pub type suseconds_t = __darwin_suseconds_t;
pub type errno_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub fds_bits: [__int32_t; 32usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        4usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    fn test_field_fds_bits() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fd_set>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fds_bits) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fd_set),
                "::",
                stringify!(fds_bits)
            )
        );
    }
    test_field_fds_bits();
}
extern "C" {
    pub fn __darwin_check_fd_set_overflow(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type fd_mask = __int32_t;
pub type pthread_attr_t = __darwin_pthread_attr_t;
pub type pthread_cond_t = __darwin_pthread_cond_t;
pub type pthread_condattr_t = __darwin_pthread_condattr_t;
pub type pthread_mutex_t = __darwin_pthread_mutex_t;
pub type pthread_mutexattr_t = __darwin_pthread_mutexattr_t;
pub type pthread_once_t = __darwin_pthread_once_t;
pub type pthread_rwlock_t = __darwin_pthread_rwlock_t;
pub type pthread_rwlockattr_t = __darwin_pthread_rwlockattr_t;
pub type pthread_t = __darwin_pthread_t;
pub type pthread_key_t = __darwin_pthread_key_t;
pub type fsblkcnt_t = __darwin_fsblkcnt_t;
pub type fsfilcnt_t = __darwin_fsfilcnt_t;
#[doc = " mruby Symbol."]
#[doc = " @class mrb_sym"]
#[doc = ""]
#[doc = " You can create an mrb_sym by simply using mrb_str_intern() or mrb_intern_cstr()"]
pub type mrb_sym = u32;
pub type mrb_bool = bool;
extern "C" {
    pub fn imaxabs(j: intmax_t) -> intmax_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: intmax_t,
    pub rem: intmax_t,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    assert_eq!(
        ::std::mem::size_of::<imaxdiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<imaxdiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(imaxdiv_t))
    );
    fn test_field_quot() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<imaxdiv_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(imaxdiv_t),
                "::",
                stringify!(quot)
            )
        );
    }
    test_field_quot();
    fn test_field_rem() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<imaxdiv_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(imaxdiv_t),
                "::",
                stringify!(rem)
            )
        );
    }
    test_field_rem();
}
extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
pub type mrb_int = i64;
pub type mrb_uint = u64;
extern "C" {
    pub fn mrb_int_read(
        p: *const ::std::os::raw::c_char,
        e: *const ::std::os::raw::c_char,
        endp: *mut *mut ::std::os::raw::c_char,
    ) -> mrb_int;
}
extern "C" {
    pub fn mrb_float_read(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
pub type mrb_float = f64;
pub const mrb_vtype_MRB_TT_FALSE: mrb_vtype = 0;
pub const mrb_vtype_MRB_TT_TRUE: mrb_vtype = 1;
pub const mrb_vtype_MRB_TT_SYMBOL: mrb_vtype = 2;
pub const mrb_vtype_MRB_TT_UNDEF: mrb_vtype = 3;
pub const mrb_vtype_MRB_TT_FREE: mrb_vtype = 4;
pub const mrb_vtype_MRB_TT_FLOAT: mrb_vtype = 5;
pub const mrb_vtype_MRB_TT_INTEGER: mrb_vtype = 6;
pub const mrb_vtype_MRB_TT_CPTR: mrb_vtype = 7;
pub const mrb_vtype_MRB_TT_OBJECT: mrb_vtype = 8;
pub const mrb_vtype_MRB_TT_CLASS: mrb_vtype = 9;
pub const mrb_vtype_MRB_TT_MODULE: mrb_vtype = 10;
pub const mrb_vtype_MRB_TT_ICLASS: mrb_vtype = 11;
pub const mrb_vtype_MRB_TT_SCLASS: mrb_vtype = 12;
pub const mrb_vtype_MRB_TT_PROC: mrb_vtype = 13;
pub const mrb_vtype_MRB_TT_ARRAY: mrb_vtype = 14;
pub const mrb_vtype_MRB_TT_HASH: mrb_vtype = 15;
pub const mrb_vtype_MRB_TT_STRING: mrb_vtype = 16;
pub const mrb_vtype_MRB_TT_RANGE: mrb_vtype = 17;
pub const mrb_vtype_MRB_TT_EXCEPTION: mrb_vtype = 18;
pub const mrb_vtype_MRB_TT_ENV: mrb_vtype = 19;
pub const mrb_vtype_MRB_TT_DATA: mrb_vtype = 20;
pub const mrb_vtype_MRB_TT_FIBER: mrb_vtype = 21;
pub const mrb_vtype_MRB_TT_STRUCT: mrb_vtype = 22;
pub const mrb_vtype_MRB_TT_ISTRUCT: mrb_vtype = 23;
pub const mrb_vtype_MRB_TT_BREAK: mrb_vtype = 24;
pub const mrb_vtype_MRB_TT_COMPLEX: mrb_vtype = 25;
pub const mrb_vtype_MRB_TT_RATIONAL: mrb_vtype = 26;
pub const mrb_vtype_MRB_TT_MAXDEFINE: mrb_vtype = 27;
pub type mrb_vtype = ::std::os::raw::c_uint;
pub type MRB_TYPEOF_MRB_TT_FALSE = ::std::os::raw::c_void;
pub type MRB_TYPEOF_MRB_TT_TRUE = ::std::os::raw::c_void;
pub type MRB_TYPEOF_MRB_TT_SYMBOL = ::std::os::raw::c_void;
pub type MRB_TYPEOF_MRB_TT_UNDEF = ::std::os::raw::c_void;
pub type MRB_TYPEOF_MRB_TT_FREE = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RFloat {
    _unused: [u8; 0],
}
pub type MRB_TYPEOF_MRB_TT_FLOAT = RFloat;
pub type MRB_TYPEOF_MRB_TT_INTEGER = RInteger;
pub type MRB_TYPEOF_MRB_TT_CPTR = RCptr;
pub type MRB_TYPEOF_MRB_TT_OBJECT = RObject;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RClass {
    _unused: [u8; 0],
}
pub type MRB_TYPEOF_MRB_TT_CLASS = RClass;
pub type MRB_TYPEOF_MRB_TT_MODULE = RClass;
pub type MRB_TYPEOF_MRB_TT_ICLASS = RClass;
pub type MRB_TYPEOF_MRB_TT_SCLASS = RClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RProc {
    _unused: [u8; 0],
}
pub type MRB_TYPEOF_MRB_TT_PROC = RProc;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RArray {
    _unused: [u8; 0],
}
pub type MRB_TYPEOF_MRB_TT_ARRAY = RArray;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RHash {
    _unused: [u8; 0],
}
pub type MRB_TYPEOF_MRB_TT_HASH = RHash;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RString {
    _unused: [u8; 0],
}
pub type MRB_TYPEOF_MRB_TT_STRING = RString;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RRange {
    _unused: [u8; 0],
}
pub type MRB_TYPEOF_MRB_TT_RANGE = RRange;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RException {
    _unused: [u8; 0],
}
pub type MRB_TYPEOF_MRB_TT_EXCEPTION = RException;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct REnv {
    _unused: [u8; 0],
}
pub type MRB_TYPEOF_MRB_TT_ENV = REnv;
pub type MRB_TYPEOF_MRB_TT_DATA = RData;
pub type MRB_TYPEOF_MRB_TT_FIBER = RFiber;
pub type MRB_TYPEOF_MRB_TT_STRUCT = RArray;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RIStruct {
    _unused: [u8; 0],
}
pub type MRB_TYPEOF_MRB_TT_ISTRUCT = RIStruct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RBreak {
    _unused: [u8; 0],
}
pub type MRB_TYPEOF_MRB_TT_BREAK = RBreak;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RComplex {
    _unused: [u8; 0],
}
pub type MRB_TYPEOF_MRB_TT_COMPLEX = RComplex;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RRational {
    _unused: [u8; 0],
}
pub type MRB_TYPEOF_MRB_TT_RATIONAL = RRational;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RBasic {
    pub c: *mut RClass,
    pub gcnext: *mut RBasic,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub __bindgen_padding_0: u32,
}
#[test]
fn bindgen_test_layout_RBasic() {
    assert_eq!(
        ::std::mem::size_of::<RBasic>(),
        24usize,
        concat!("Size of: ", stringify!(RBasic))
    );
    assert_eq!(
        ::std::mem::align_of::<RBasic>(),
        8usize,
        concat!("Alignment of ", stringify!(RBasic))
    );
    fn test_field_c() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RBasic>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).c) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(RBasic), "::", stringify!(c))
        );
    }
    test_field_c();
    fn test_field_gcnext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RBasic>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gcnext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(RBasic),
                "::",
                stringify!(gcnext)
            )
        );
    }
    test_field_gcnext();
}
impl RBasic {
    #[inline]
    pub fn tt(&self) -> mrb_vtype {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_tt(&mut self, val: mrb_vtype) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn color(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_color(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn flags(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 21u8) as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 21u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tt: mrb_vtype,
        color: u32,
        flags: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let tt: u32 = unsafe { ::std::mem::transmute(tt) };
            tt as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let color: u32 = unsafe { ::std::mem::transmute(color) };
            color as u64
        });
        __bindgen_bitfield_unit.set(11usize, 21u8, {
            let flags: u32 = unsafe { ::std::mem::transmute(flags) };
            flags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RObject {
    pub c: *mut RClass,
    pub gcnext: *mut RBasic,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub iv: *mut iv_tbl,
}
#[test]
fn bindgen_test_layout_RObject() {
    assert_eq!(
        ::std::mem::size_of::<RObject>(),
        32usize,
        concat!("Size of: ", stringify!(RObject))
    );
    assert_eq!(
        ::std::mem::align_of::<RObject>(),
        8usize,
        concat!("Alignment of ", stringify!(RObject))
    );
    fn test_field_c() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RObject>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).c) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(RObject),
                "::",
                stringify!(c)
            )
        );
    }
    test_field_c();
    fn test_field_gcnext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RObject>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gcnext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(RObject),
                "::",
                stringify!(gcnext)
            )
        );
    }
    test_field_gcnext();
    fn test_field_iv() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RObject>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).iv) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(RObject),
                "::",
                stringify!(iv)
            )
        );
    }
    test_field_iv();
}
impl RObject {
    #[inline]
    pub fn tt(&self) -> mrb_vtype {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_tt(&mut self, val: mrb_vtype) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn color(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_color(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn flags(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 21u8) as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 21u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tt: mrb_vtype,
        color: u32,
        flags: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let tt: u32 = unsafe { ::std::mem::transmute(tt) };
            tt as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let color: u32 = unsafe { ::std::mem::transmute(color) };
            color as u64
        });
        __bindgen_bitfield_unit.set(11usize, 21u8, {
            let flags: u32 = unsafe { ::std::mem::transmute(flags) };
            flags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RFiber {
    pub c: *mut RClass,
    pub gcnext: *mut RBasic,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub cxt: *mut mrb_context,
}
#[test]
fn bindgen_test_layout_RFiber() {
    assert_eq!(
        ::std::mem::size_of::<RFiber>(),
        32usize,
        concat!("Size of: ", stringify!(RFiber))
    );
    assert_eq!(
        ::std::mem::align_of::<RFiber>(),
        8usize,
        concat!("Alignment of ", stringify!(RFiber))
    );
    fn test_field_c() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RFiber>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).c) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(RFiber), "::", stringify!(c))
        );
    }
    test_field_c();
    fn test_field_gcnext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RFiber>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gcnext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(RFiber),
                "::",
                stringify!(gcnext)
            )
        );
    }
    test_field_gcnext();
    fn test_field_cxt() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RFiber>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cxt) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(RFiber),
                "::",
                stringify!(cxt)
            )
        );
    }
    test_field_cxt();
}
impl RFiber {
    #[inline]
    pub fn tt(&self) -> mrb_vtype {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_tt(&mut self, val: mrb_vtype) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn color(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_color(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn flags(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 21u8) as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 21u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tt: mrb_vtype,
        color: u32,
        flags: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let tt: u32 = unsafe { ::std::mem::transmute(tt) };
            tt as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let color: u32 = unsafe { ::std::mem::transmute(color) };
            color as u64
        });
        __bindgen_bitfield_unit.set(11usize, 21u8, {
            let flags: u32 = unsafe { ::std::mem::transmute(flags) };
            flags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RCptr {
    pub c: *mut RClass,
    pub gcnext: *mut RBasic,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub p: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_RCptr() {
    assert_eq!(
        ::std::mem::size_of::<RCptr>(),
        32usize,
        concat!("Size of: ", stringify!(RCptr))
    );
    assert_eq!(
        ::std::mem::align_of::<RCptr>(),
        8usize,
        concat!("Alignment of ", stringify!(RCptr))
    );
    fn test_field_c() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RCptr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).c) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(RCptr), "::", stringify!(c))
        );
    }
    test_field_c();
    fn test_field_gcnext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RCptr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gcnext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(RCptr),
                "::",
                stringify!(gcnext)
            )
        );
    }
    test_field_gcnext();
    fn test_field_p() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RCptr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p) as usize - ptr as usize
            },
            24usize,
            concat!("Offset of field: ", stringify!(RCptr), "::", stringify!(p))
        );
    }
    test_field_p();
}
impl RCptr {
    #[inline]
    pub fn tt(&self) -> mrb_vtype {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_tt(&mut self, val: mrb_vtype) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn color(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_color(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn flags(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 21u8) as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 21u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tt: mrb_vtype,
        color: u32,
        flags: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let tt: u32 = unsafe { ::std::mem::transmute(tt) };
            tt as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let color: u32 = unsafe { ::std::mem::transmute(color) };
            color as u64
        });
        __bindgen_bitfield_unit.set(11usize, 21u8, {
            let flags: u32 = unsafe { ::std::mem::transmute(flags) };
            flags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RInteger {
    pub c: *mut RClass,
    pub gcnext: *mut RBasic,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub i: mrb_int,
}
#[test]
fn bindgen_test_layout_RInteger() {
    assert_eq!(
        ::std::mem::size_of::<RInteger>(),
        32usize,
        concat!("Size of: ", stringify!(RInteger))
    );
    assert_eq!(
        ::std::mem::align_of::<RInteger>(),
        8usize,
        concat!("Alignment of ", stringify!(RInteger))
    );
    fn test_field_c() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RInteger>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).c) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(RInteger),
                "::",
                stringify!(c)
            )
        );
    }
    test_field_c();
    fn test_field_gcnext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RInteger>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gcnext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(RInteger),
                "::",
                stringify!(gcnext)
            )
        );
    }
    test_field_gcnext();
    fn test_field_i() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RInteger>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).i) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(RInteger),
                "::",
                stringify!(i)
            )
        );
    }
    test_field_i();
}
impl RInteger {
    #[inline]
    pub fn tt(&self) -> mrb_vtype {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_tt(&mut self, val: mrb_vtype) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn color(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_color(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn flags(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 21u8) as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 21u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tt: mrb_vtype,
        color: u32,
        flags: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let tt: u32 = unsafe { ::std::mem::transmute(tt) };
            tt as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let color: u32 = unsafe { ::std::mem::transmute(color) };
            color as u64
        });
        __bindgen_bitfield_unit.set(11usize, 21u8, {
            let flags: u32 = unsafe { ::std::mem::transmute(flags) };
            flags as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const mrb_special_consts_MRB_Qnil: mrb_special_consts = 0;
pub const mrb_special_consts_MRB_Qfalse: mrb_special_consts = 4;
pub const mrb_special_consts_MRB_Qtrue: mrb_special_consts = 12;
pub const mrb_special_consts_MRB_Qundef: mrb_special_consts = 20;
pub type mrb_special_consts = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mrb_value {
    pub w: usize,
}
#[test]
fn bindgen_test_layout_mrb_value() {
    assert_eq!(
        ::std::mem::size_of::<mrb_value>(),
        8usize,
        concat!("Size of: ", stringify!(mrb_value))
    );
    assert_eq!(
        ::std::mem::align_of::<mrb_value>(),
        8usize,
        concat!("Alignment of ", stringify!(mrb_value))
    );
    fn test_field_w() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_value>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_value),
                "::",
                stringify!(w)
            )
        );
    }
    test_field_w();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mrb_value_ {
    pub p: *mut ::std::os::raw::c_void,
    pub bp: *mut RBasic,
    pub f: mrb_float,
    pub ip: *mut RInteger,
    pub vp: *mut RCptr,
    pub w: usize,
    pub value: mrb_value,
}
#[test]
fn bindgen_test_layout_mrb_value_() {
    assert_eq!(
        ::std::mem::size_of::<mrb_value_>(),
        8usize,
        concat!("Size of: ", stringify!(mrb_value_))
    );
    assert_eq!(
        ::std::mem::align_of::<mrb_value_>(),
        8usize,
        concat!("Alignment of ", stringify!(mrb_value_))
    );
    fn test_field_p() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_value_>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_value_),
                "::",
                stringify!(p)
            )
        );
    }
    test_field_p();
    fn test_field_bp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_value_>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bp) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_value_),
                "::",
                stringify!(bp)
            )
        );
    }
    test_field_bp();
    fn test_field_f() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_value_>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).f) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_value_),
                "::",
                stringify!(f)
            )
        );
    }
    test_field_f();
    fn test_field_ip() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_value_>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ip) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_value_),
                "::",
                stringify!(ip)
            )
        );
    }
    test_field_ip();
    fn test_field_vp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_value_>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vp) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_value_),
                "::",
                stringify!(vp)
            )
        );
    }
    test_field_vp();
    fn test_field_w() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_value_>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_value_),
                "::",
                stringify!(w)
            )
        );
    }
    test_field_w();
    fn test_field_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_value_>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_value_),
                "::",
                stringify!(value)
            )
        );
    }
    test_field_value();
}
extern "C" {
    pub fn mrb_word_boxing_cptr_value(
        arg1: *mut mrb_state,
        arg2: *mut ::std::os::raw::c_void,
    ) -> mrb_value;
}
extern "C" {
    pub fn mrb_word_boxing_float_value(arg1: *mut mrb_state, arg2: mrb_float) -> mrb_value;
}
extern "C" {
    pub fn mrb_boxing_int_value(arg1: *mut mrb_state, arg2: mrb_int) -> mrb_value;
}
extern "C" {
    pub fn mrb_word_boxing_value_float(v: mrb_value) -> mrb_float;
}
pub type mrb_ssize = mrb_int;
pub type natural_t = __darwin_natural_t;
pub type integer_t = ::std::os::raw::c_int;
pub type vm_offset_t = usize;
pub type vm_size_t = usize;
pub type mach_vm_address_t = u64;
pub type mach_vm_offset_t = u64;
pub type mach_vm_size_t = u64;
pub type vm_map_offset_t = u64;
pub type vm_map_address_t = u64;
pub type vm_map_size_t = u64;
pub type vm32_offset_t = u32;
pub type vm32_address_t = u32;
pub type vm32_size_t = u32;
pub type mach_port_context_t = vm_offset_t;
pub type boolean_t = ::std::os::raw::c_int;
pub type cpu_type_t = integer_t;
pub type cpu_subtype_t = integer_t;
pub type cpu_threadtype_t = integer_t;
pub type vm_prot_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_exception_state {
    pub __exception: __uint32_t,
    pub __fsr: __uint32_t,
    pub __far: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_exception_state() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_exception_state>(),
        12usize,
        concat!("Size of: ", stringify!(__darwin_arm_exception_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_exception_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_arm_exception_state))
    );
    fn test_field___exception() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_exception_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__exception) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_exception_state),
                "::",
                stringify!(__exception)
            )
        );
    }
    test_field___exception();
    fn test_field___fsr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_exception_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__fsr) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_exception_state),
                "::",
                stringify!(__fsr)
            )
        );
    }
    test_field___fsr();
    fn test_field___far() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_exception_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__far) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_exception_state),
                "::",
                stringify!(__far)
            )
        );
    }
    test_field___far();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_exception_state64 {
    pub __far: __uint64_t,
    pub __esr: __uint32_t,
    pub __exception: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_exception_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_exception_state64>(),
        16usize,
        concat!("Size of: ", stringify!(__darwin_arm_exception_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_exception_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_exception_state64))
    );
    fn test_field___far() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_exception_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__far) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_exception_state64),
                "::",
                stringify!(__far)
            )
        );
    }
    test_field___far();
    fn test_field___esr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_exception_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__esr) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_exception_state64),
                "::",
                stringify!(__esr)
            )
        );
    }
    test_field___esr();
    fn test_field___exception() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_exception_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__exception) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_exception_state64),
                "::",
                stringify!(__exception)
            )
        );
    }
    test_field___exception();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_thread_state {
    pub __r: [__uint32_t; 13usize],
    pub __sp: __uint32_t,
    pub __lr: __uint32_t,
    pub __pc: __uint32_t,
    pub __cpsr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_thread_state() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_thread_state>(),
        68usize,
        concat!("Size of: ", stringify!(__darwin_arm_thread_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_thread_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_arm_thread_state))
    );
    fn test_field___r() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_thread_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__r) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_thread_state),
                "::",
                stringify!(__r)
            )
        );
    }
    test_field___r();
    fn test_field___sp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_thread_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__sp) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_thread_state),
                "::",
                stringify!(__sp)
            )
        );
    }
    test_field___sp();
    fn test_field___lr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_thread_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__lr) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_thread_state),
                "::",
                stringify!(__lr)
            )
        );
    }
    test_field___lr();
    fn test_field___pc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_thread_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pc) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_thread_state),
                "::",
                stringify!(__pc)
            )
        );
    }
    test_field___pc();
    fn test_field___cpsr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_thread_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__cpsr) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_thread_state),
                "::",
                stringify!(__cpsr)
            )
        );
    }
    test_field___cpsr();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_thread_state64 {
    pub __x: [__uint64_t; 29usize],
    pub __fp: __uint64_t,
    pub __lr: __uint64_t,
    pub __sp: __uint64_t,
    pub __pc: __uint64_t,
    pub __cpsr: __uint32_t,
    pub __pad: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_thread_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_thread_state64>(),
        272usize,
        concat!("Size of: ", stringify!(__darwin_arm_thread_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_thread_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_thread_state64))
    );
    fn test_field___x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_thread_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__x) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_thread_state64),
                "::",
                stringify!(__x)
            )
        );
    }
    test_field___x();
    fn test_field___fp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_thread_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__fp) as usize - ptr as usize
            },
            232usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_thread_state64),
                "::",
                stringify!(__fp)
            )
        );
    }
    test_field___fp();
    fn test_field___lr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_thread_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__lr) as usize - ptr as usize
            },
            240usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_thread_state64),
                "::",
                stringify!(__lr)
            )
        );
    }
    test_field___lr();
    fn test_field___sp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_thread_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__sp) as usize - ptr as usize
            },
            248usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_thread_state64),
                "::",
                stringify!(__sp)
            )
        );
    }
    test_field___sp();
    fn test_field___pc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_thread_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pc) as usize - ptr as usize
            },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_thread_state64),
                "::",
                stringify!(__pc)
            )
        );
    }
    test_field___pc();
    fn test_field___cpsr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_thread_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__cpsr) as usize - ptr as usize
            },
            264usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_thread_state64),
                "::",
                stringify!(__cpsr)
            )
        );
    }
    test_field___cpsr();
    fn test_field___pad() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_thread_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pad) as usize - ptr as usize
            },
            268usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_thread_state64),
                "::",
                stringify!(__pad)
            )
        );
    }
    test_field___pad();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_vfp_state {
    pub __r: [__uint32_t; 64usize],
    pub __fpscr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_vfp_state() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_vfp_state>(),
        260usize,
        concat!("Size of: ", stringify!(__darwin_arm_vfp_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_vfp_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_arm_vfp_state))
    );
    fn test_field___r() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_vfp_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__r) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_vfp_state),
                "::",
                stringify!(__r)
            )
        );
    }
    test_field___r();
    fn test_field___fpscr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_vfp_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__fpscr) as usize - ptr as usize
            },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_vfp_state),
                "::",
                stringify!(__fpscr)
            )
        );
    }
    test_field___fpscr();
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_neon_state64 {
    pub __v: [__uint128_t; 32usize],
    pub __fpsr: __uint32_t,
    pub __fpcr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_neon_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_neon_state64>(),
        528usize,
        concat!("Size of: ", stringify!(__darwin_arm_neon_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_neon_state64>(),
        16usize,
        concat!("Alignment of ", stringify!(__darwin_arm_neon_state64))
    );
    fn test_field___v() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_neon_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__v) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_neon_state64),
                "::",
                stringify!(__v)
            )
        );
    }
    test_field___v();
    fn test_field___fpsr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_neon_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__fpsr) as usize - ptr as usize
            },
            512usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_neon_state64),
                "::",
                stringify!(__fpsr)
            )
        );
    }
    test_field___fpsr();
    fn test_field___fpcr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_neon_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__fpcr) as usize - ptr as usize
            },
            516usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_neon_state64),
                "::",
                stringify!(__fpcr)
            )
        );
    }
    test_field___fpcr();
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_neon_state {
    pub __v: [__uint128_t; 16usize],
    pub __fpsr: __uint32_t,
    pub __fpcr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_neon_state() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_neon_state>(),
        272usize,
        concat!("Size of: ", stringify!(__darwin_arm_neon_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_neon_state>(),
        16usize,
        concat!("Alignment of ", stringify!(__darwin_arm_neon_state))
    );
    fn test_field___v() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_neon_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__v) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_neon_state),
                "::",
                stringify!(__v)
            )
        );
    }
    test_field___v();
    fn test_field___fpsr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_neon_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__fpsr) as usize - ptr as usize
            },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_neon_state),
                "::",
                stringify!(__fpsr)
            )
        );
    }
    test_field___fpsr();
    fn test_field___fpcr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_neon_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__fpcr) as usize - ptr as usize
            },
            260usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_neon_state),
                "::",
                stringify!(__fpcr)
            )
        );
    }
    test_field___fpcr();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __arm_pagein_state {
    pub __pagein_error: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___arm_pagein_state() {
    assert_eq!(
        ::std::mem::size_of::<__arm_pagein_state>(),
        4usize,
        concat!("Size of: ", stringify!(__arm_pagein_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__arm_pagein_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__arm_pagein_state))
    );
    fn test_field___pagein_error() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__arm_pagein_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pagein_error) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__arm_pagein_state),
                "::",
                stringify!(__pagein_error)
            )
        );
    }
    test_field___pagein_error();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __arm_legacy_debug_state {
    pub __bvr: [__uint32_t; 16usize],
    pub __bcr: [__uint32_t; 16usize],
    pub __wvr: [__uint32_t; 16usize],
    pub __wcr: [__uint32_t; 16usize],
}
#[test]
fn bindgen_test_layout___arm_legacy_debug_state() {
    assert_eq!(
        ::std::mem::size_of::<__arm_legacy_debug_state>(),
        256usize,
        concat!("Size of: ", stringify!(__arm_legacy_debug_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__arm_legacy_debug_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__arm_legacy_debug_state))
    );
    fn test_field___bvr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__arm_legacy_debug_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__bvr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__arm_legacy_debug_state),
                "::",
                stringify!(__bvr)
            )
        );
    }
    test_field___bvr();
    fn test_field___bcr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__arm_legacy_debug_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__bcr) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(__arm_legacy_debug_state),
                "::",
                stringify!(__bcr)
            )
        );
    }
    test_field___bcr();
    fn test_field___wvr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__arm_legacy_debug_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__wvr) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(__arm_legacy_debug_state),
                "::",
                stringify!(__wvr)
            )
        );
    }
    test_field___wvr();
    fn test_field___wcr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__arm_legacy_debug_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__wcr) as usize - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(__arm_legacy_debug_state),
                "::",
                stringify!(__wcr)
            )
        );
    }
    test_field___wcr();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_debug_state32 {
    pub __bvr: [__uint32_t; 16usize],
    pub __bcr: [__uint32_t; 16usize],
    pub __wvr: [__uint32_t; 16usize],
    pub __wcr: [__uint32_t; 16usize],
    pub __mdscr_el1: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_debug_state32() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_debug_state32>(),
        264usize,
        concat!("Size of: ", stringify!(__darwin_arm_debug_state32))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_debug_state32>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_debug_state32))
    );
    fn test_field___bvr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_debug_state32>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__bvr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_debug_state32),
                "::",
                stringify!(__bvr)
            )
        );
    }
    test_field___bvr();
    fn test_field___bcr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_debug_state32>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__bcr) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_debug_state32),
                "::",
                stringify!(__bcr)
            )
        );
    }
    test_field___bcr();
    fn test_field___wvr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_debug_state32>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__wvr) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_debug_state32),
                "::",
                stringify!(__wvr)
            )
        );
    }
    test_field___wvr();
    fn test_field___wcr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_debug_state32>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__wcr) as usize - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_debug_state32),
                "::",
                stringify!(__wcr)
            )
        );
    }
    test_field___wcr();
    fn test_field___mdscr_el1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_debug_state32>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__mdscr_el1) as usize - ptr as usize
            },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_debug_state32),
                "::",
                stringify!(__mdscr_el1)
            )
        );
    }
    test_field___mdscr_el1();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_debug_state64 {
    pub __bvr: [__uint64_t; 16usize],
    pub __bcr: [__uint64_t; 16usize],
    pub __wvr: [__uint64_t; 16usize],
    pub __wcr: [__uint64_t; 16usize],
    pub __mdscr_el1: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_debug_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_debug_state64>(),
        520usize,
        concat!("Size of: ", stringify!(__darwin_arm_debug_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_debug_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_debug_state64))
    );
    fn test_field___bvr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_debug_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__bvr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_debug_state64),
                "::",
                stringify!(__bvr)
            )
        );
    }
    test_field___bvr();
    fn test_field___bcr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_debug_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__bcr) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_debug_state64),
                "::",
                stringify!(__bcr)
            )
        );
    }
    test_field___bcr();
    fn test_field___wvr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_debug_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__wvr) as usize - ptr as usize
            },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_debug_state64),
                "::",
                stringify!(__wvr)
            )
        );
    }
    test_field___wvr();
    fn test_field___wcr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_debug_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__wcr) as usize - ptr as usize
            },
            384usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_debug_state64),
                "::",
                stringify!(__wcr)
            )
        );
    }
    test_field___wcr();
    fn test_field___mdscr_el1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_debug_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__mdscr_el1) as usize - ptr as usize
            },
            512usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_debug_state64),
                "::",
                stringify!(__mdscr_el1)
            )
        );
    }
    test_field___mdscr_el1();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_cpmu_state64 {
    pub __ctrs: [__uint64_t; 16usize],
}
#[test]
fn bindgen_test_layout___darwin_arm_cpmu_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_cpmu_state64>(),
        128usize,
        concat!("Size of: ", stringify!(__darwin_arm_cpmu_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_cpmu_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_cpmu_state64))
    );
    fn test_field___ctrs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_cpmu_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__ctrs) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_cpmu_state64),
                "::",
                stringify!(__ctrs)
            )
        );
    }
    test_field___ctrs();
}
pub type mach_port_name_t = natural_t;
pub type mach_port_name_array_t = *mut mach_port_name_t;
pub type mach_port_t = __darwin_mach_port_t;
pub type mach_port_array_t = *mut mach_port_t;
pub type mach_port_right_t = natural_t;
pub type mach_port_type_t = natural_t;
pub type mach_port_type_array_t = *mut mach_port_type_t;
pub type mach_port_urefs_t = natural_t;
pub type mach_port_delta_t = integer_t;
pub type mach_port_seqno_t = natural_t;
pub type mach_port_mscount_t = natural_t;
pub type mach_port_msgcount_t = natural_t;
pub type mach_port_rights_t = natural_t;
pub type mach_port_srights_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_port_status {
    pub mps_pset: mach_port_rights_t,
    pub mps_seqno: mach_port_seqno_t,
    pub mps_mscount: mach_port_mscount_t,
    pub mps_qlimit: mach_port_msgcount_t,
    pub mps_msgcount: mach_port_msgcount_t,
    pub mps_sorights: mach_port_rights_t,
    pub mps_srights: boolean_t,
    pub mps_pdrequest: boolean_t,
    pub mps_nsrequest: boolean_t,
    pub mps_flags: natural_t,
}
#[test]
fn bindgen_test_layout_mach_port_status() {
    assert_eq!(
        ::std::mem::size_of::<mach_port_status>(),
        40usize,
        concat!("Size of: ", stringify!(mach_port_status))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_port_status>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_port_status))
    );
    fn test_field_mps_pset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_port_status>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mps_pset) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_port_status),
                "::",
                stringify!(mps_pset)
            )
        );
    }
    test_field_mps_pset();
    fn test_field_mps_seqno() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_port_status>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mps_seqno) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_port_status),
                "::",
                stringify!(mps_seqno)
            )
        );
    }
    test_field_mps_seqno();
    fn test_field_mps_mscount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_port_status>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mps_mscount) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_port_status),
                "::",
                stringify!(mps_mscount)
            )
        );
    }
    test_field_mps_mscount();
    fn test_field_mps_qlimit() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_port_status>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mps_qlimit) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_port_status),
                "::",
                stringify!(mps_qlimit)
            )
        );
    }
    test_field_mps_qlimit();
    fn test_field_mps_msgcount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_port_status>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mps_msgcount) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_port_status),
                "::",
                stringify!(mps_msgcount)
            )
        );
    }
    test_field_mps_msgcount();
    fn test_field_mps_sorights() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_port_status>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mps_sorights) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_port_status),
                "::",
                stringify!(mps_sorights)
            )
        );
    }
    test_field_mps_sorights();
    fn test_field_mps_srights() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_port_status>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mps_srights) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_port_status),
                "::",
                stringify!(mps_srights)
            )
        );
    }
    test_field_mps_srights();
    fn test_field_mps_pdrequest() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_port_status>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mps_pdrequest) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_port_status),
                "::",
                stringify!(mps_pdrequest)
            )
        );
    }
    test_field_mps_pdrequest();
    fn test_field_mps_nsrequest() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_port_status>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mps_nsrequest) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_port_status),
                "::",
                stringify!(mps_nsrequest)
            )
        );
    }
    test_field_mps_nsrequest();
    fn test_field_mps_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_port_status>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mps_flags) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_port_status),
                "::",
                stringify!(mps_flags)
            )
        );
    }
    test_field_mps_flags();
}
pub type mach_port_status_t = mach_port_status;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_port_limits {
    pub mpl_qlimit: mach_port_msgcount_t,
}
#[test]
fn bindgen_test_layout_mach_port_limits() {
    assert_eq!(
        ::std::mem::size_of::<mach_port_limits>(),
        4usize,
        concat!("Size of: ", stringify!(mach_port_limits))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_port_limits>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_port_limits))
    );
    fn test_field_mpl_qlimit() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_port_limits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mpl_qlimit) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_port_limits),
                "::",
                stringify!(mpl_qlimit)
            )
        );
    }
    test_field_mpl_qlimit();
}
pub type mach_port_limits_t = mach_port_limits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_port_info_ext {
    pub mpie_status: mach_port_status_t,
    pub mpie_boost_cnt: mach_port_msgcount_t,
    pub reserved: [u32; 6usize],
}
#[test]
fn bindgen_test_layout_mach_port_info_ext() {
    assert_eq!(
        ::std::mem::size_of::<mach_port_info_ext>(),
        68usize,
        concat!("Size of: ", stringify!(mach_port_info_ext))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_port_info_ext>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_port_info_ext))
    );
    fn test_field_mpie_status() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_port_info_ext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mpie_status) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_port_info_ext),
                "::",
                stringify!(mpie_status)
            )
        );
    }
    test_field_mpie_status();
    fn test_field_mpie_boost_cnt() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_port_info_ext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mpie_boost_cnt) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_port_info_ext),
                "::",
                stringify!(mpie_boost_cnt)
            )
        );
    }
    test_field_mpie_boost_cnt();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_port_info_ext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_port_info_ext),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
pub type mach_port_info_ext_t = mach_port_info_ext;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_port_guard_info {
    pub mpgi_guard: u64,
}
#[test]
fn bindgen_test_layout_mach_port_guard_info() {
    assert_eq!(
        ::std::mem::size_of::<mach_port_guard_info>(),
        8usize,
        concat!("Size of: ", stringify!(mach_port_guard_info))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_port_guard_info>(),
        8usize,
        concat!("Alignment of ", stringify!(mach_port_guard_info))
    );
    fn test_field_mpgi_guard() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_port_guard_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mpgi_guard) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_port_guard_info),
                "::",
                stringify!(mpgi_guard)
            )
        );
    }
    test_field_mpgi_guard();
}
pub type mach_port_guard_info_t = mach_port_guard_info;
pub type mach_port_info_t = *mut integer_t;
pub type mach_port_flavor_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_port_qos {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub len: natural_t,
}
#[test]
fn bindgen_test_layout_mach_port_qos() {
    assert_eq!(
        ::std::mem::size_of::<mach_port_qos>(),
        8usize,
        concat!("Size of: ", stringify!(mach_port_qos))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_port_qos>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_port_qos))
    );
    fn test_field_len() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_port_qos>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_port_qos),
                "::",
                stringify!(len)
            )
        );
    }
    test_field_len();
}
impl mach_port_qos {
    #[inline]
    pub fn name(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_name(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn prealloc(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_prealloc(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pad1(&self) -> boolean_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_pad1(&mut self, val: boolean_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        name: ::std::os::raw::c_uint,
        prealloc: ::std::os::raw::c_uint,
        pad1: boolean_t,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let name: u32 = unsafe { ::std::mem::transmute(name) };
            name as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let prealloc: u32 = unsafe { ::std::mem::transmute(prealloc) };
            prealloc as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let pad1: u32 = unsafe { ::std::mem::transmute(pad1) };
            pad1 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type mach_port_qos_t = mach_port_qos;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_service_port_info {
    pub mspi_string_name: [::std::os::raw::c_char; 255usize],
    pub mspi_domain_type: u8,
}
#[test]
fn bindgen_test_layout_mach_service_port_info() {
    assert_eq!(
        ::std::mem::size_of::<mach_service_port_info>(),
        256usize,
        concat!("Size of: ", stringify!(mach_service_port_info))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_service_port_info>(),
        1usize,
        concat!("Alignment of ", stringify!(mach_service_port_info))
    );
    fn test_field_mspi_string_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_service_port_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mspi_string_name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_service_port_info),
                "::",
                stringify!(mspi_string_name)
            )
        );
    }
    test_field_mspi_string_name();
    fn test_field_mspi_domain_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_service_port_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mspi_domain_type) as usize - ptr as usize
            },
            255usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_service_port_info),
                "::",
                stringify!(mspi_domain_type)
            )
        );
    }
    test_field_mspi_domain_type();
}
pub type mach_service_port_info_data_t = mach_service_port_info;
pub type mach_service_port_info_t = *mut mach_service_port_info;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mach_port_options {
    pub flags: u32,
    pub mpl: mach_port_limits_t,
    pub __bindgen_anon_1: mach_port_options__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mach_port_options__bindgen_ty_1 {
    pub reserved: [u64; 2usize],
    pub work_interval_port: mach_port_name_t,
    pub service_port_info: mach_service_port_info_t,
    pub service_port_name: mach_port_name_t,
}
#[test]
fn bindgen_test_layout_mach_port_options__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<mach_port_options__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(mach_port_options__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_port_options__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(mach_port_options__bindgen_ty_1))
    );
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_port_options__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_port_options__bindgen_ty_1),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
    fn test_field_work_interval_port() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_port_options__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).work_interval_port) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_port_options__bindgen_ty_1),
                "::",
                stringify!(work_interval_port)
            )
        );
    }
    test_field_work_interval_port();
    fn test_field_service_port_info() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_port_options__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).service_port_info) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_port_options__bindgen_ty_1),
                "::",
                stringify!(service_port_info)
            )
        );
    }
    test_field_service_port_info();
    fn test_field_service_port_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_port_options__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).service_port_name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_port_options__bindgen_ty_1),
                "::",
                stringify!(service_port_name)
            )
        );
    }
    test_field_service_port_name();
}
#[test]
fn bindgen_test_layout_mach_port_options() {
    assert_eq!(
        ::std::mem::size_of::<mach_port_options>(),
        24usize,
        concat!("Size of: ", stringify!(mach_port_options))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_port_options>(),
        8usize,
        concat!("Alignment of ", stringify!(mach_port_options))
    );
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_port_options>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_port_options),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_mpl() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_port_options>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mpl) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_port_options),
                "::",
                stringify!(mpl)
            )
        );
    }
    test_field_mpl();
}
pub type mach_port_options_t = mach_port_options;
pub type mach_port_options_ptr_t = *mut mach_port_options_t;
pub const mach_port_guard_exception_codes_kGUARD_EXC_DESTROY: mach_port_guard_exception_codes = 1;
pub const mach_port_guard_exception_codes_kGUARD_EXC_MOD_REFS: mach_port_guard_exception_codes = 2;
pub const mach_port_guard_exception_codes_kGUARD_EXC_SET_CONTEXT: mach_port_guard_exception_codes =
    4;
pub const mach_port_guard_exception_codes_kGUARD_EXC_UNGUARDED: mach_port_guard_exception_codes = 8;
pub const mach_port_guard_exception_codes_kGUARD_EXC_INCORRECT_GUARD:
    mach_port_guard_exception_codes = 16;
pub const mach_port_guard_exception_codes_kGUARD_EXC_IMMOVABLE: mach_port_guard_exception_codes =
    32;
pub const mach_port_guard_exception_codes_kGUARD_EXC_STRICT_REPLY: mach_port_guard_exception_codes =
    64;
pub const mach_port_guard_exception_codes_kGUARD_EXC_MSG_FILTERED: mach_port_guard_exception_codes =
    128;
pub const mach_port_guard_exception_codes_kGUARD_EXC_INVALID_RIGHT:
    mach_port_guard_exception_codes = 256;
pub const mach_port_guard_exception_codes_kGUARD_EXC_INVALID_NAME: mach_port_guard_exception_codes =
    512;
pub const mach_port_guard_exception_codes_kGUARD_EXC_INVALID_VALUE:
    mach_port_guard_exception_codes = 1024;
pub const mach_port_guard_exception_codes_kGUARD_EXC_INVALID_ARGUMENT:
    mach_port_guard_exception_codes = 2048;
pub const mach_port_guard_exception_codes_kGUARD_EXC_RIGHT_EXISTS: mach_port_guard_exception_codes =
    4096;
pub const mach_port_guard_exception_codes_kGUARD_EXC_KERN_NO_SPACE:
    mach_port_guard_exception_codes = 8192;
pub const mach_port_guard_exception_codes_kGUARD_EXC_KERN_FAILURE: mach_port_guard_exception_codes =
    16384;
pub const mach_port_guard_exception_codes_kGUARD_EXC_KERN_RESOURCE:
    mach_port_guard_exception_codes = 32768;
pub const mach_port_guard_exception_codes_kGUARD_EXC_SEND_INVALID_REPLY:
    mach_port_guard_exception_codes = 65536;
pub const mach_port_guard_exception_codes_kGUARD_EXC_SEND_INVALID_VOUCHER:
    mach_port_guard_exception_codes = 131072;
pub const mach_port_guard_exception_codes_kGUARD_EXC_SEND_INVALID_RIGHT:
    mach_port_guard_exception_codes = 262144;
pub const mach_port_guard_exception_codes_kGUARD_EXC_RCV_INVALID_NAME:
    mach_port_guard_exception_codes = 524288;
pub const mach_port_guard_exception_codes_kGUARD_EXC_RCV_GUARDED_DESC:
    mach_port_guard_exception_codes = 1048576;
pub const mach_port_guard_exception_codes_kGUARD_EXC_MOD_REFS_NON_FATAL:
    mach_port_guard_exception_codes = 2097152;
pub const mach_port_guard_exception_codes_kGUARD_EXC_IMMOVABLE_NON_FATAL:
    mach_port_guard_exception_codes = 4194304;
pub type mach_port_guard_exception_codes = ::std::os::raw::c_uint;
pub type kern_return_t = ::std::os::raw::c_int;
pub type mach_msg_timeout_t = natural_t;
pub type mach_msg_bits_t = ::std::os::raw::c_uint;
pub type mach_msg_size_t = natural_t;
pub type mach_msg_id_t = integer_t;
pub type mach_msg_priority_t = ::std::os::raw::c_uint;
pub type mach_msg_type_name_t = ::std::os::raw::c_uint;
pub type mach_msg_copy_options_t = ::std::os::raw::c_uint;
pub type mach_msg_guard_flags_t = ::std::os::raw::c_uint;
pub type mach_msg_descriptor_type_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_msg_type_descriptor_t {
    pub pad1: natural_t,
    pub pad2: mach_msg_size_t,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_mach_msg_type_descriptor_t() {
    assert_eq!(
        ::std::mem::size_of::<mach_msg_type_descriptor_t>(),
        12usize,
        concat!("Size of: ", stringify!(mach_msg_type_descriptor_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_type_descriptor_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_type_descriptor_t))
    );
    fn test_field_pad1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_msg_type_descriptor_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pad1) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_msg_type_descriptor_t),
                "::",
                stringify!(pad1)
            )
        );
    }
    test_field_pad1();
    fn test_field_pad2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_msg_type_descriptor_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pad2) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_msg_type_descriptor_t),
                "::",
                stringify!(pad2)
            )
        );
    }
    test_field_pad2();
}
impl mach_msg_type_descriptor_t {
    #[inline]
    pub fn pad3(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_pad3(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> mach_msg_descriptor_type_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: mach_msg_descriptor_type_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        pad3: ::std::os::raw::c_uint,
        type_: mach_msg_descriptor_type_t,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let pad3: u32 = unsafe { ::std::mem::transmute(pad3) };
            pad3 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_msg_port_descriptor_t {
    pub name: mach_port_t,
    pub pad1: mach_msg_size_t,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_mach_msg_port_descriptor_t() {
    assert_eq!(
        ::std::mem::size_of::<mach_msg_port_descriptor_t>(),
        12usize,
        concat!("Size of: ", stringify!(mach_msg_port_descriptor_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_port_descriptor_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_port_descriptor_t))
    );
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_msg_port_descriptor_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_msg_port_descriptor_t),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_pad1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_msg_port_descriptor_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pad1) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_msg_port_descriptor_t),
                "::",
                stringify!(pad1)
            )
        );
    }
    test_field_pad1();
}
impl mach_msg_port_descriptor_t {
    #[inline]
    pub fn pad2(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_pad2(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn disposition(&self) -> mach_msg_type_name_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_disposition(&mut self, val: mach_msg_type_name_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> mach_msg_descriptor_type_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: mach_msg_descriptor_type_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        pad2: ::std::os::raw::c_uint,
        disposition: mach_msg_type_name_t,
        type_: mach_msg_descriptor_type_t,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let pad2: u32 = unsafe { ::std::mem::transmute(pad2) };
            pad2 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let disposition: u32 = unsafe { ::std::mem::transmute(disposition) };
            disposition as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_msg_ool_descriptor32_t {
    pub address: u32,
    pub size: mach_msg_size_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_mach_msg_ool_descriptor32_t() {
    assert_eq!(
        ::std::mem::size_of::<mach_msg_ool_descriptor32_t>(),
        12usize,
        concat!("Size of: ", stringify!(mach_msg_ool_descriptor32_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_ool_descriptor32_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_ool_descriptor32_t))
    );
    fn test_field_address() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_msg_ool_descriptor32_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_msg_ool_descriptor32_t),
                "::",
                stringify!(address)
            )
        );
    }
    test_field_address();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_msg_ool_descriptor32_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_msg_ool_descriptor32_t),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
}
impl mach_msg_ool_descriptor32_t {
    #[inline]
    pub fn deallocate(&self) -> boolean_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_deallocate(&mut self, val: boolean_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn copy(&self) -> mach_msg_copy_options_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_copy(&mut self, val: mach_msg_copy_options_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn pad1(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_pad1(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> mach_msg_descriptor_type_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: mach_msg_descriptor_type_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        deallocate: boolean_t,
        copy: mach_msg_copy_options_t,
        pad1: ::std::os::raw::c_uint,
        type_: mach_msg_descriptor_type_t,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let deallocate: u32 = unsafe { ::std::mem::transmute(deallocate) };
            deallocate as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let copy: u32 = unsafe { ::std::mem::transmute(copy) };
            copy as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let pad1: u32 = unsafe { ::std::mem::transmute(pad1) };
            pad1 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct mach_msg_ool_descriptor64_t {
    pub address: u64,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub size: mach_msg_size_t,
}
#[test]
fn bindgen_test_layout_mach_msg_ool_descriptor64_t() {
    assert_eq!(
        ::std::mem::size_of::<mach_msg_ool_descriptor64_t>(),
        16usize,
        concat!("Size of: ", stringify!(mach_msg_ool_descriptor64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_ool_descriptor64_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_ool_descriptor64_t))
    );
    fn test_field_address() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_msg_ool_descriptor64_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_msg_ool_descriptor64_t),
                "::",
                stringify!(address)
            )
        );
    }
    test_field_address();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_msg_ool_descriptor64_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_msg_ool_descriptor64_t),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
}
impl mach_msg_ool_descriptor64_t {
    #[inline]
    pub fn deallocate(&self) -> boolean_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_deallocate(&mut self, val: boolean_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn copy(&self) -> mach_msg_copy_options_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_copy(&mut self, val: mach_msg_copy_options_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn pad1(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_pad1(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> mach_msg_descriptor_type_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: mach_msg_descriptor_type_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        deallocate: boolean_t,
        copy: mach_msg_copy_options_t,
        pad1: ::std::os::raw::c_uint,
        type_: mach_msg_descriptor_type_t,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let deallocate: u32 = unsafe { ::std::mem::transmute(deallocate) };
            deallocate as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let copy: u32 = unsafe { ::std::mem::transmute(copy) };
            copy as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let pad1: u32 = unsafe { ::std::mem::transmute(pad1) };
            pad1 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct mach_msg_ool_descriptor_t {
    pub address: *mut ::std::os::raw::c_void,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub size: mach_msg_size_t,
}
#[test]
fn bindgen_test_layout_mach_msg_ool_descriptor_t() {
    assert_eq!(
        ::std::mem::size_of::<mach_msg_ool_descriptor_t>(),
        16usize,
        concat!("Size of: ", stringify!(mach_msg_ool_descriptor_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_ool_descriptor_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_ool_descriptor_t))
    );
    fn test_field_address() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_msg_ool_descriptor_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_msg_ool_descriptor_t),
                "::",
                stringify!(address)
            )
        );
    }
    test_field_address();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_msg_ool_descriptor_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_msg_ool_descriptor_t),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
}
impl mach_msg_ool_descriptor_t {
    #[inline]
    pub fn deallocate(&self) -> boolean_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_deallocate(&mut self, val: boolean_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn copy(&self) -> mach_msg_copy_options_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_copy(&mut self, val: mach_msg_copy_options_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn pad1(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_pad1(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> mach_msg_descriptor_type_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: mach_msg_descriptor_type_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        deallocate: boolean_t,
        copy: mach_msg_copy_options_t,
        pad1: ::std::os::raw::c_uint,
        type_: mach_msg_descriptor_type_t,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let deallocate: u32 = unsafe { ::std::mem::transmute(deallocate) };
            deallocate as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let copy: u32 = unsafe { ::std::mem::transmute(copy) };
            copy as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let pad1: u32 = unsafe { ::std::mem::transmute(pad1) };
            pad1 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_msg_ool_ports_descriptor32_t {
    pub address: u32,
    pub count: mach_msg_size_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_mach_msg_ool_ports_descriptor32_t() {
    assert_eq!(
        ::std::mem::size_of::<mach_msg_ool_ports_descriptor32_t>(),
        12usize,
        concat!("Size of: ", stringify!(mach_msg_ool_ports_descriptor32_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_ool_ports_descriptor32_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(mach_msg_ool_ports_descriptor32_t)
        )
    );
    fn test_field_address() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_msg_ool_ports_descriptor32_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_msg_ool_ports_descriptor32_t),
                "::",
                stringify!(address)
            )
        );
    }
    test_field_address();
    fn test_field_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_msg_ool_ports_descriptor32_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_msg_ool_ports_descriptor32_t),
                "::",
                stringify!(count)
            )
        );
    }
    test_field_count();
}
impl mach_msg_ool_ports_descriptor32_t {
    #[inline]
    pub fn deallocate(&self) -> boolean_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_deallocate(&mut self, val: boolean_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn copy(&self) -> mach_msg_copy_options_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_copy(&mut self, val: mach_msg_copy_options_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn disposition(&self) -> mach_msg_type_name_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_disposition(&mut self, val: mach_msg_type_name_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> mach_msg_descriptor_type_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: mach_msg_descriptor_type_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        deallocate: boolean_t,
        copy: mach_msg_copy_options_t,
        disposition: mach_msg_type_name_t,
        type_: mach_msg_descriptor_type_t,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let deallocate: u32 = unsafe { ::std::mem::transmute(deallocate) };
            deallocate as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let copy: u32 = unsafe { ::std::mem::transmute(copy) };
            copy as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let disposition: u32 = unsafe { ::std::mem::transmute(disposition) };
            disposition as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct mach_msg_ool_ports_descriptor64_t {
    pub address: u64,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub count: mach_msg_size_t,
}
#[test]
fn bindgen_test_layout_mach_msg_ool_ports_descriptor64_t() {
    assert_eq!(
        ::std::mem::size_of::<mach_msg_ool_ports_descriptor64_t>(),
        16usize,
        concat!("Size of: ", stringify!(mach_msg_ool_ports_descriptor64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_ool_ports_descriptor64_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(mach_msg_ool_ports_descriptor64_t)
        )
    );
    fn test_field_address() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_msg_ool_ports_descriptor64_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_msg_ool_ports_descriptor64_t),
                "::",
                stringify!(address)
            )
        );
    }
    test_field_address();
    fn test_field_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_msg_ool_ports_descriptor64_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_msg_ool_ports_descriptor64_t),
                "::",
                stringify!(count)
            )
        );
    }
    test_field_count();
}
impl mach_msg_ool_ports_descriptor64_t {
    #[inline]
    pub fn deallocate(&self) -> boolean_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_deallocate(&mut self, val: boolean_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn copy(&self) -> mach_msg_copy_options_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_copy(&mut self, val: mach_msg_copy_options_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn disposition(&self) -> mach_msg_type_name_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_disposition(&mut self, val: mach_msg_type_name_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> mach_msg_descriptor_type_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: mach_msg_descriptor_type_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        deallocate: boolean_t,
        copy: mach_msg_copy_options_t,
        disposition: mach_msg_type_name_t,
        type_: mach_msg_descriptor_type_t,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let deallocate: u32 = unsafe { ::std::mem::transmute(deallocate) };
            deallocate as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let copy: u32 = unsafe { ::std::mem::transmute(copy) };
            copy as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let disposition: u32 = unsafe { ::std::mem::transmute(disposition) };
            disposition as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct mach_msg_ool_ports_descriptor_t {
    pub address: *mut ::std::os::raw::c_void,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub count: mach_msg_size_t,
}
#[test]
fn bindgen_test_layout_mach_msg_ool_ports_descriptor_t() {
    assert_eq!(
        ::std::mem::size_of::<mach_msg_ool_ports_descriptor_t>(),
        16usize,
        concat!("Size of: ", stringify!(mach_msg_ool_ports_descriptor_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_ool_ports_descriptor_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_ool_ports_descriptor_t))
    );
    fn test_field_address() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_msg_ool_ports_descriptor_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_msg_ool_ports_descriptor_t),
                "::",
                stringify!(address)
            )
        );
    }
    test_field_address();
    fn test_field_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_msg_ool_ports_descriptor_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_msg_ool_ports_descriptor_t),
                "::",
                stringify!(count)
            )
        );
    }
    test_field_count();
}
impl mach_msg_ool_ports_descriptor_t {
    #[inline]
    pub fn deallocate(&self) -> boolean_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_deallocate(&mut self, val: boolean_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn copy(&self) -> mach_msg_copy_options_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_copy(&mut self, val: mach_msg_copy_options_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn disposition(&self) -> mach_msg_type_name_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_disposition(&mut self, val: mach_msg_type_name_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> mach_msg_descriptor_type_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: mach_msg_descriptor_type_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        deallocate: boolean_t,
        copy: mach_msg_copy_options_t,
        disposition: mach_msg_type_name_t,
        type_: mach_msg_descriptor_type_t,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let deallocate: u32 = unsafe { ::std::mem::transmute(deallocate) };
            deallocate as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let copy: u32 = unsafe { ::std::mem::transmute(copy) };
            copy as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let disposition: u32 = unsafe { ::std::mem::transmute(disposition) };
            disposition as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_msg_guarded_port_descriptor32_t {
    pub context: u32,
    pub name: mach_port_name_t,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_mach_msg_guarded_port_descriptor32_t() {
    assert_eq!(
        ::std::mem::size_of::<mach_msg_guarded_port_descriptor32_t>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(mach_msg_guarded_port_descriptor32_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_guarded_port_descriptor32_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(mach_msg_guarded_port_descriptor32_t)
        )
    );
    fn test_field_context() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<mach_msg_guarded_port_descriptor32_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).context) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_msg_guarded_port_descriptor32_t),
                "::",
                stringify!(context)
            )
        );
    }
    test_field_context();
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<mach_msg_guarded_port_descriptor32_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_msg_guarded_port_descriptor32_t),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
}
impl mach_msg_guarded_port_descriptor32_t {
    #[inline]
    pub fn flags(&self) -> mach_msg_guard_flags_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: mach_msg_guard_flags_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn disposition(&self) -> mach_msg_type_name_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_disposition(&mut self, val: mach_msg_type_name_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> mach_msg_descriptor_type_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: mach_msg_descriptor_type_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        flags: mach_msg_guard_flags_t,
        disposition: mach_msg_type_name_t,
        type_: mach_msg_descriptor_type_t,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let flags: u32 = unsafe { ::std::mem::transmute(flags) };
            flags as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let disposition: u32 = unsafe { ::std::mem::transmute(disposition) };
            disposition as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct mach_msg_guarded_port_descriptor64_t {
    pub context: u64,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub name: mach_port_name_t,
}
#[test]
fn bindgen_test_layout_mach_msg_guarded_port_descriptor64_t() {
    assert_eq!(
        ::std::mem::size_of::<mach_msg_guarded_port_descriptor64_t>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(mach_msg_guarded_port_descriptor64_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_guarded_port_descriptor64_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(mach_msg_guarded_port_descriptor64_t)
        )
    );
    fn test_field_context() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<mach_msg_guarded_port_descriptor64_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).context) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_msg_guarded_port_descriptor64_t),
                "::",
                stringify!(context)
            )
        );
    }
    test_field_context();
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<mach_msg_guarded_port_descriptor64_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_msg_guarded_port_descriptor64_t),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
}
impl mach_msg_guarded_port_descriptor64_t {
    #[inline]
    pub fn flags(&self) -> mach_msg_guard_flags_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: mach_msg_guard_flags_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn disposition(&self) -> mach_msg_type_name_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_disposition(&mut self, val: mach_msg_type_name_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> mach_msg_descriptor_type_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: mach_msg_descriptor_type_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        flags: mach_msg_guard_flags_t,
        disposition: mach_msg_type_name_t,
        type_: mach_msg_descriptor_type_t,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let flags: u32 = unsafe { ::std::mem::transmute(flags) };
            flags as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let disposition: u32 = unsafe { ::std::mem::transmute(disposition) };
            disposition as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct mach_msg_guarded_port_descriptor_t {
    pub context: mach_port_context_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub name: mach_port_name_t,
}
#[test]
fn bindgen_test_layout_mach_msg_guarded_port_descriptor_t() {
    assert_eq!(
        ::std::mem::size_of::<mach_msg_guarded_port_descriptor_t>(),
        16usize,
        concat!("Size of: ", stringify!(mach_msg_guarded_port_descriptor_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_guarded_port_descriptor_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(mach_msg_guarded_port_descriptor_t)
        )
    );
    fn test_field_context() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<mach_msg_guarded_port_descriptor_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).context) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_msg_guarded_port_descriptor_t),
                "::",
                stringify!(context)
            )
        );
    }
    test_field_context();
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<mach_msg_guarded_port_descriptor_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_msg_guarded_port_descriptor_t),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
}
impl mach_msg_guarded_port_descriptor_t {
    #[inline]
    pub fn flags(&self) -> mach_msg_guard_flags_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: mach_msg_guard_flags_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn disposition(&self) -> mach_msg_type_name_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_disposition(&mut self, val: mach_msg_type_name_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> mach_msg_descriptor_type_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: mach_msg_descriptor_type_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        flags: mach_msg_guard_flags_t,
        disposition: mach_msg_type_name_t,
        type_: mach_msg_descriptor_type_t,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let flags: u32 = unsafe { ::std::mem::transmute(flags) };
            flags as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let disposition: u32 = unsafe { ::std::mem::transmute(disposition) };
            disposition as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mach_msg_descriptor_t {
    pub port: mach_msg_port_descriptor_t,
    pub out_of_line: mach_msg_ool_descriptor_t,
    pub ool_ports: mach_msg_ool_ports_descriptor_t,
    pub type_: mach_msg_type_descriptor_t,
    pub guarded_port: mach_msg_guarded_port_descriptor_t,
}
#[test]
fn bindgen_test_layout_mach_msg_descriptor_t() {
    assert_eq!(
        ::std::mem::size_of::<mach_msg_descriptor_t>(),
        16usize,
        concat!("Size of: ", stringify!(mach_msg_descriptor_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_descriptor_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_descriptor_t))
    );
    fn test_field_port() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_msg_descriptor_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).port) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_msg_descriptor_t),
                "::",
                stringify!(port)
            )
        );
    }
    test_field_port();
    fn test_field_out_of_line() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_msg_descriptor_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).out_of_line) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_msg_descriptor_t),
                "::",
                stringify!(out_of_line)
            )
        );
    }
    test_field_out_of_line();
    fn test_field_ool_ports() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_msg_descriptor_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ool_ports) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_msg_descriptor_t),
                "::",
                stringify!(ool_ports)
            )
        );
    }
    test_field_ool_ports();
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_msg_descriptor_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_msg_descriptor_t),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_guarded_port() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_msg_descriptor_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).guarded_port) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_msg_descriptor_t),
                "::",
                stringify!(guarded_port)
            )
        );
    }
    test_field_guarded_port();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_msg_body_t {
    pub msgh_descriptor_count: mach_msg_size_t,
}
#[test]
fn bindgen_test_layout_mach_msg_body_t() {
    assert_eq!(
        ::std::mem::size_of::<mach_msg_body_t>(),
        4usize,
        concat!("Size of: ", stringify!(mach_msg_body_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_body_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_body_t))
    );
    fn test_field_msgh_descriptor_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_msg_body_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).msgh_descriptor_count) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_msg_body_t),
                "::",
                stringify!(msgh_descriptor_count)
            )
        );
    }
    test_field_msgh_descriptor_count();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_msg_header_t {
    pub msgh_bits: mach_msg_bits_t,
    pub msgh_size: mach_msg_size_t,
    pub msgh_remote_port: mach_port_t,
    pub msgh_local_port: mach_port_t,
    pub msgh_voucher_port: mach_port_name_t,
    pub msgh_id: mach_msg_id_t,
}
#[test]
fn bindgen_test_layout_mach_msg_header_t() {
    assert_eq!(
        ::std::mem::size_of::<mach_msg_header_t>(),
        24usize,
        concat!("Size of: ", stringify!(mach_msg_header_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_header_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_header_t))
    );
    fn test_field_msgh_bits() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_msg_header_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).msgh_bits) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_msg_header_t),
                "::",
                stringify!(msgh_bits)
            )
        );
    }
    test_field_msgh_bits();
    fn test_field_msgh_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_msg_header_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).msgh_size) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_msg_header_t),
                "::",
                stringify!(msgh_size)
            )
        );
    }
    test_field_msgh_size();
    fn test_field_msgh_remote_port() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_msg_header_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).msgh_remote_port) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_msg_header_t),
                "::",
                stringify!(msgh_remote_port)
            )
        );
    }
    test_field_msgh_remote_port();
    fn test_field_msgh_local_port() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_msg_header_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).msgh_local_port) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_msg_header_t),
                "::",
                stringify!(msgh_local_port)
            )
        );
    }
    test_field_msgh_local_port();
    fn test_field_msgh_voucher_port() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_msg_header_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).msgh_voucher_port) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_msg_header_t),
                "::",
                stringify!(msgh_voucher_port)
            )
        );
    }
    test_field_msgh_voucher_port();
    fn test_field_msgh_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_msg_header_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).msgh_id) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_msg_header_t),
                "::",
                stringify!(msgh_id)
            )
        );
    }
    test_field_msgh_id();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_msg_base_t {
    pub header: mach_msg_header_t,
    pub body: mach_msg_body_t,
}
#[test]
fn bindgen_test_layout_mach_msg_base_t() {
    assert_eq!(
        ::std::mem::size_of::<mach_msg_base_t>(),
        28usize,
        concat!("Size of: ", stringify!(mach_msg_base_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_base_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_base_t))
    );
    fn test_field_header() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_msg_base_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).header) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_msg_base_t),
                "::",
                stringify!(header)
            )
        );
    }
    test_field_header();
    fn test_field_body() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_msg_base_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).body) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_msg_base_t),
                "::",
                stringify!(body)
            )
        );
    }
    test_field_body();
}
pub type mach_msg_trailer_type_t = ::std::os::raw::c_uint;
pub type mach_msg_trailer_size_t = ::std::os::raw::c_uint;
pub type mach_msg_trailer_info_t = *mut ::std::os::raw::c_char;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_msg_trailer_t {
    pub msgh_trailer_type: mach_msg_trailer_type_t,
    pub msgh_trailer_size: mach_msg_trailer_size_t,
}
#[test]
fn bindgen_test_layout_mach_msg_trailer_t() {
    assert_eq!(
        ::std::mem::size_of::<mach_msg_trailer_t>(),
        8usize,
        concat!("Size of: ", stringify!(mach_msg_trailer_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_trailer_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_trailer_t))
    );
    fn test_field_msgh_trailer_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_msg_trailer_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).msgh_trailer_type) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_msg_trailer_t),
                "::",
                stringify!(msgh_trailer_type)
            )
        );
    }
    test_field_msgh_trailer_type();
    fn test_field_msgh_trailer_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_msg_trailer_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).msgh_trailer_size) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_msg_trailer_t),
                "::",
                stringify!(msgh_trailer_size)
            )
        );
    }
    test_field_msgh_trailer_size();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_msg_seqno_trailer_t {
    pub msgh_trailer_type: mach_msg_trailer_type_t,
    pub msgh_trailer_size: mach_msg_trailer_size_t,
    pub msgh_seqno: mach_port_seqno_t,
}
#[test]
fn bindgen_test_layout_mach_msg_seqno_trailer_t() {
    assert_eq!(
        ::std::mem::size_of::<mach_msg_seqno_trailer_t>(),
        12usize,
        concat!("Size of: ", stringify!(mach_msg_seqno_trailer_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_seqno_trailer_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_seqno_trailer_t))
    );
    fn test_field_msgh_trailer_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_msg_seqno_trailer_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).msgh_trailer_type) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_msg_seqno_trailer_t),
                "::",
                stringify!(msgh_trailer_type)
            )
        );
    }
    test_field_msgh_trailer_type();
    fn test_field_msgh_trailer_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_msg_seqno_trailer_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).msgh_trailer_size) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_msg_seqno_trailer_t),
                "::",
                stringify!(msgh_trailer_size)
            )
        );
    }
    test_field_msgh_trailer_size();
    fn test_field_msgh_seqno() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_msg_seqno_trailer_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).msgh_seqno) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_msg_seqno_trailer_t),
                "::",
                stringify!(msgh_seqno)
            )
        );
    }
    test_field_msgh_seqno();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct security_token_t {
    pub val: [::std::os::raw::c_uint; 2usize],
}
#[test]
fn bindgen_test_layout_security_token_t() {
    assert_eq!(
        ::std::mem::size_of::<security_token_t>(),
        8usize,
        concat!("Size of: ", stringify!(security_token_t))
    );
    assert_eq!(
        ::std::mem::align_of::<security_token_t>(),
        4usize,
        concat!("Alignment of ", stringify!(security_token_t))
    );
    fn test_field_val() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<security_token_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).val) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(security_token_t),
                "::",
                stringify!(val)
            )
        );
    }
    test_field_val();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_msg_security_trailer_t {
    pub msgh_trailer_type: mach_msg_trailer_type_t,
    pub msgh_trailer_size: mach_msg_trailer_size_t,
    pub msgh_seqno: mach_port_seqno_t,
    pub msgh_sender: security_token_t,
}
#[test]
fn bindgen_test_layout_mach_msg_security_trailer_t() {
    assert_eq!(
        ::std::mem::size_of::<mach_msg_security_trailer_t>(),
        20usize,
        concat!("Size of: ", stringify!(mach_msg_security_trailer_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_security_trailer_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_security_trailer_t))
    );
    fn test_field_msgh_trailer_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_msg_security_trailer_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).msgh_trailer_type) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_msg_security_trailer_t),
                "::",
                stringify!(msgh_trailer_type)
            )
        );
    }
    test_field_msgh_trailer_type();
    fn test_field_msgh_trailer_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_msg_security_trailer_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).msgh_trailer_size) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_msg_security_trailer_t),
                "::",
                stringify!(msgh_trailer_size)
            )
        );
    }
    test_field_msgh_trailer_size();
    fn test_field_msgh_seqno() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_msg_security_trailer_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).msgh_seqno) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_msg_security_trailer_t),
                "::",
                stringify!(msgh_seqno)
            )
        );
    }
    test_field_msgh_seqno();
    fn test_field_msgh_sender() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_msg_security_trailer_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).msgh_sender) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_msg_security_trailer_t),
                "::",
                stringify!(msgh_sender)
            )
        );
    }
    test_field_msgh_sender();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct audit_token_t {
    pub val: [::std::os::raw::c_uint; 8usize],
}
#[test]
fn bindgen_test_layout_audit_token_t() {
    assert_eq!(
        ::std::mem::size_of::<audit_token_t>(),
        32usize,
        concat!("Size of: ", stringify!(audit_token_t))
    );
    assert_eq!(
        ::std::mem::align_of::<audit_token_t>(),
        4usize,
        concat!("Alignment of ", stringify!(audit_token_t))
    );
    fn test_field_val() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<audit_token_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).val) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(audit_token_t),
                "::",
                stringify!(val)
            )
        );
    }
    test_field_val();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_msg_audit_trailer_t {
    pub msgh_trailer_type: mach_msg_trailer_type_t,
    pub msgh_trailer_size: mach_msg_trailer_size_t,
    pub msgh_seqno: mach_port_seqno_t,
    pub msgh_sender: security_token_t,
    pub msgh_audit: audit_token_t,
}
#[test]
fn bindgen_test_layout_mach_msg_audit_trailer_t() {
    assert_eq!(
        ::std::mem::size_of::<mach_msg_audit_trailer_t>(),
        52usize,
        concat!("Size of: ", stringify!(mach_msg_audit_trailer_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_audit_trailer_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_audit_trailer_t))
    );
    fn test_field_msgh_trailer_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_msg_audit_trailer_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).msgh_trailer_type) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_msg_audit_trailer_t),
                "::",
                stringify!(msgh_trailer_type)
            )
        );
    }
    test_field_msgh_trailer_type();
    fn test_field_msgh_trailer_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_msg_audit_trailer_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).msgh_trailer_size) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_msg_audit_trailer_t),
                "::",
                stringify!(msgh_trailer_size)
            )
        );
    }
    test_field_msgh_trailer_size();
    fn test_field_msgh_seqno() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_msg_audit_trailer_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).msgh_seqno) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_msg_audit_trailer_t),
                "::",
                stringify!(msgh_seqno)
            )
        );
    }
    test_field_msgh_seqno();
    fn test_field_msgh_sender() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_msg_audit_trailer_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).msgh_sender) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_msg_audit_trailer_t),
                "::",
                stringify!(msgh_sender)
            )
        );
    }
    test_field_msgh_sender();
    fn test_field_msgh_audit() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_msg_audit_trailer_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).msgh_audit) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_msg_audit_trailer_t),
                "::",
                stringify!(msgh_audit)
            )
        );
    }
    test_field_msgh_audit();
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct mach_msg_context_trailer_t {
    pub msgh_trailer_type: mach_msg_trailer_type_t,
    pub msgh_trailer_size: mach_msg_trailer_size_t,
    pub msgh_seqno: mach_port_seqno_t,
    pub msgh_sender: security_token_t,
    pub msgh_audit: audit_token_t,
    pub msgh_context: mach_port_context_t,
}
#[test]
fn bindgen_test_layout_mach_msg_context_trailer_t() {
    assert_eq!(
        ::std::mem::size_of::<mach_msg_context_trailer_t>(),
        60usize,
        concat!("Size of: ", stringify!(mach_msg_context_trailer_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_context_trailer_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_context_trailer_t))
    );
    fn test_field_msgh_trailer_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_msg_context_trailer_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).msgh_trailer_type) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_msg_context_trailer_t),
                "::",
                stringify!(msgh_trailer_type)
            )
        );
    }
    test_field_msgh_trailer_type();
    fn test_field_msgh_trailer_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_msg_context_trailer_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).msgh_trailer_size) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_msg_context_trailer_t),
                "::",
                stringify!(msgh_trailer_size)
            )
        );
    }
    test_field_msgh_trailer_size();
    fn test_field_msgh_seqno() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_msg_context_trailer_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).msgh_seqno) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_msg_context_trailer_t),
                "::",
                stringify!(msgh_seqno)
            )
        );
    }
    test_field_msgh_seqno();
    fn test_field_msgh_sender() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_msg_context_trailer_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).msgh_sender) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_msg_context_trailer_t),
                "::",
                stringify!(msgh_sender)
            )
        );
    }
    test_field_msgh_sender();
    fn test_field_msgh_audit() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_msg_context_trailer_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).msgh_audit) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_msg_context_trailer_t),
                "::",
                stringify!(msgh_audit)
            )
        );
    }
    test_field_msgh_audit();
    fn test_field_msgh_context() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_msg_context_trailer_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).msgh_context) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_msg_context_trailer_t),
                "::",
                stringify!(msgh_context)
            )
        );
    }
    test_field_msgh_context();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msg_labels_t {
    pub sender: mach_port_name_t,
}
#[test]
fn bindgen_test_layout_msg_labels_t() {
    assert_eq!(
        ::std::mem::size_of::<msg_labels_t>(),
        4usize,
        concat!("Size of: ", stringify!(msg_labels_t))
    );
    assert_eq!(
        ::std::mem::align_of::<msg_labels_t>(),
        4usize,
        concat!("Alignment of ", stringify!(msg_labels_t))
    );
    fn test_field_sender() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<msg_labels_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sender) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(msg_labels_t),
                "::",
                stringify!(sender)
            )
        );
    }
    test_field_sender();
}
pub type mach_msg_filter_id = ::std::os::raw::c_int;
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct mach_msg_mac_trailer_t {
    pub msgh_trailer_type: mach_msg_trailer_type_t,
    pub msgh_trailer_size: mach_msg_trailer_size_t,
    pub msgh_seqno: mach_port_seqno_t,
    pub msgh_sender: security_token_t,
    pub msgh_audit: audit_token_t,
    pub msgh_context: mach_port_context_t,
    pub msgh_ad: mach_msg_filter_id,
    pub msgh_labels: msg_labels_t,
}
#[test]
fn bindgen_test_layout_mach_msg_mac_trailer_t() {
    assert_eq!(
        ::std::mem::size_of::<mach_msg_mac_trailer_t>(),
        68usize,
        concat!("Size of: ", stringify!(mach_msg_mac_trailer_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_mac_trailer_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_mac_trailer_t))
    );
    fn test_field_msgh_trailer_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_msg_mac_trailer_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).msgh_trailer_type) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_msg_mac_trailer_t),
                "::",
                stringify!(msgh_trailer_type)
            )
        );
    }
    test_field_msgh_trailer_type();
    fn test_field_msgh_trailer_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_msg_mac_trailer_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).msgh_trailer_size) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_msg_mac_trailer_t),
                "::",
                stringify!(msgh_trailer_size)
            )
        );
    }
    test_field_msgh_trailer_size();
    fn test_field_msgh_seqno() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_msg_mac_trailer_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).msgh_seqno) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_msg_mac_trailer_t),
                "::",
                stringify!(msgh_seqno)
            )
        );
    }
    test_field_msgh_seqno();
    fn test_field_msgh_sender() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_msg_mac_trailer_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).msgh_sender) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_msg_mac_trailer_t),
                "::",
                stringify!(msgh_sender)
            )
        );
    }
    test_field_msgh_sender();
    fn test_field_msgh_audit() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_msg_mac_trailer_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).msgh_audit) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_msg_mac_trailer_t),
                "::",
                stringify!(msgh_audit)
            )
        );
    }
    test_field_msgh_audit();
    fn test_field_msgh_context() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_msg_mac_trailer_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).msgh_context) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_msg_mac_trailer_t),
                "::",
                stringify!(msgh_context)
            )
        );
    }
    test_field_msgh_context();
    fn test_field_msgh_ad() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_msg_mac_trailer_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).msgh_ad) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_msg_mac_trailer_t),
                "::",
                stringify!(msgh_ad)
            )
        );
    }
    test_field_msgh_ad();
    fn test_field_msgh_labels() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_msg_mac_trailer_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).msgh_labels) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_msg_mac_trailer_t),
                "::",
                stringify!(msgh_labels)
            )
        );
    }
    test_field_msgh_labels();
}
pub type mach_msg_max_trailer_t = mach_msg_mac_trailer_t;
pub type mach_msg_format_0_trailer_t = mach_msg_security_trailer_t;
extern "C" {
    pub static KERNEL_SECURITY_TOKEN: security_token_t;
}
extern "C" {
    pub static KERNEL_AUDIT_TOKEN: audit_token_t;
}
pub type mach_msg_options_t = integer_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_msg_empty_send_t {
    pub header: mach_msg_header_t,
}
#[test]
fn bindgen_test_layout_mach_msg_empty_send_t() {
    assert_eq!(
        ::std::mem::size_of::<mach_msg_empty_send_t>(),
        24usize,
        concat!("Size of: ", stringify!(mach_msg_empty_send_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_empty_send_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_empty_send_t))
    );
    fn test_field_header() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_msg_empty_send_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).header) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_msg_empty_send_t),
                "::",
                stringify!(header)
            )
        );
    }
    test_field_header();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_msg_empty_rcv_t {
    pub header: mach_msg_header_t,
    pub trailer: mach_msg_trailer_t,
}
#[test]
fn bindgen_test_layout_mach_msg_empty_rcv_t() {
    assert_eq!(
        ::std::mem::size_of::<mach_msg_empty_rcv_t>(),
        32usize,
        concat!("Size of: ", stringify!(mach_msg_empty_rcv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_empty_rcv_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_empty_rcv_t))
    );
    fn test_field_header() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_msg_empty_rcv_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).header) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_msg_empty_rcv_t),
                "::",
                stringify!(header)
            )
        );
    }
    test_field_header();
    fn test_field_trailer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_msg_empty_rcv_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).trailer) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_msg_empty_rcv_t),
                "::",
                stringify!(trailer)
            )
        );
    }
    test_field_trailer();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mach_msg_empty_t {
    pub send: mach_msg_empty_send_t,
    pub rcv: mach_msg_empty_rcv_t,
}
#[test]
fn bindgen_test_layout_mach_msg_empty_t() {
    assert_eq!(
        ::std::mem::size_of::<mach_msg_empty_t>(),
        32usize,
        concat!("Size of: ", stringify!(mach_msg_empty_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_msg_empty_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_msg_empty_t))
    );
    fn test_field_send() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_msg_empty_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).send) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_msg_empty_t),
                "::",
                stringify!(send)
            )
        );
    }
    test_field_send();
    fn test_field_rcv() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_msg_empty_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rcv) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_msg_empty_t),
                "::",
                stringify!(rcv)
            )
        );
    }
    test_field_rcv();
}
pub type mach_msg_type_size_t = natural_t;
pub type mach_msg_type_number_t = natural_t;
pub type mach_msg_option_t = integer_t;
pub type mach_msg_return_t = kern_return_t;
extern "C" {
    pub fn mach_msg_overwrite(
        msg: *mut mach_msg_header_t,
        option: mach_msg_option_t,
        send_size: mach_msg_size_t,
        rcv_size: mach_msg_size_t,
        rcv_name: mach_port_name_t,
        timeout: mach_msg_timeout_t,
        notify: mach_port_name_t,
        rcv_msg: *mut mach_msg_header_t,
        rcv_limit: mach_msg_size_t,
    ) -> mach_msg_return_t;
}
extern "C" {
    pub fn mach_msg(
        msg: *mut mach_msg_header_t,
        option: mach_msg_option_t,
        send_size: mach_msg_size_t,
        rcv_size: mach_msg_size_t,
        rcv_name: mach_port_name_t,
        timeout: mach_msg_timeout_t,
        notify: mach_port_name_t,
    ) -> mach_msg_return_t;
}
extern "C" {
    pub fn mach_voucher_deallocate(voucher: mach_port_name_t) -> kern_return_t;
}
pub type pointer_t = vm_offset_t;
pub type vm_address_t = vm_offset_t;
pub type addr64_t = u64;
pub type reg64_t = u32;
pub type ppnum_t = u32;
pub type vm_map_t = mach_port_t;
pub type vm_map_read_t = mach_port_t;
pub type vm_map_inspect_t = mach_port_t;
pub type vm_object_offset_t = u64;
pub type vm_object_size_t = u64;
pub type upl_t = mach_port_t;
pub type vm_named_entry_t = mach_port_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arm_state_hdr {
    pub flavor: u32,
    pub count: u32,
}
#[test]
fn bindgen_test_layout_arm_state_hdr() {
    assert_eq!(
        ::std::mem::size_of::<arm_state_hdr>(),
        8usize,
        concat!("Size of: ", stringify!(arm_state_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<arm_state_hdr>(),
        4usize,
        concat!("Alignment of ", stringify!(arm_state_hdr))
    );
    fn test_field_flavor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<arm_state_hdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flavor) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(arm_state_hdr),
                "::",
                stringify!(flavor)
            )
        );
    }
    test_field_flavor();
    fn test_field_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<arm_state_hdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(arm_state_hdr),
                "::",
                stringify!(count)
            )
        );
    }
    test_field_count();
}
pub type arm_state_hdr_t = arm_state_hdr;
pub type arm_thread_state_t = __darwin_arm_thread_state;
pub type arm_thread_state32_t = __darwin_arm_thread_state;
pub type arm_thread_state64_t = __darwin_arm_thread_state64;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct arm_unified_thread_state {
    pub ash: arm_state_hdr_t,
    pub uts: arm_unified_thread_state__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union arm_unified_thread_state__bindgen_ty_1 {
    pub ts_32: arm_thread_state32_t,
    pub ts_64: arm_thread_state64_t,
}
#[test]
fn bindgen_test_layout_arm_unified_thread_state__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<arm_unified_thread_state__bindgen_ty_1>(),
        272usize,
        concat!(
            "Size of: ",
            stringify!(arm_unified_thread_state__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<arm_unified_thread_state__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(arm_unified_thread_state__bindgen_ty_1)
        )
    );
    fn test_field_ts_32() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<arm_unified_thread_state__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ts_32) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(arm_unified_thread_state__bindgen_ty_1),
                "::",
                stringify!(ts_32)
            )
        );
    }
    test_field_ts_32();
    fn test_field_ts_64() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<arm_unified_thread_state__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ts_64) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(arm_unified_thread_state__bindgen_ty_1),
                "::",
                stringify!(ts_64)
            )
        );
    }
    test_field_ts_64();
}
#[test]
fn bindgen_test_layout_arm_unified_thread_state() {
    assert_eq!(
        ::std::mem::size_of::<arm_unified_thread_state>(),
        280usize,
        concat!("Size of: ", stringify!(arm_unified_thread_state))
    );
    assert_eq!(
        ::std::mem::align_of::<arm_unified_thread_state>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_unified_thread_state))
    );
    fn test_field_ash() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<arm_unified_thread_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ash) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(arm_unified_thread_state),
                "::",
                stringify!(ash)
            )
        );
    }
    test_field_ash();
    fn test_field_uts() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<arm_unified_thread_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uts) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(arm_unified_thread_state),
                "::",
                stringify!(uts)
            )
        );
    }
    test_field_uts();
}
pub type arm_unified_thread_state_t = arm_unified_thread_state;
pub type arm_vfp_state_t = __darwin_arm_vfp_state;
pub type arm_neon_state_t = __darwin_arm_neon_state;
pub type arm_neon_state32_t = __darwin_arm_neon_state;
pub type arm_neon_state64_t = __darwin_arm_neon_state64;
pub type arm_exception_state_t = __darwin_arm_exception_state;
pub type arm_exception_state32_t = __darwin_arm_exception_state;
pub type arm_exception_state64_t = __darwin_arm_exception_state64;
pub type arm_debug_state32_t = __darwin_arm_debug_state32;
pub type arm_debug_state64_t = __darwin_arm_debug_state64;
pub type arm_pagein_state_t = __arm_pagein_state;
pub type arm_debug_state_t = __arm_legacy_debug_state;
pub const OSUnknownByteOrder: _bindgen_ty_1 = 0;
pub const OSLittleEndian: _bindgen_ty_1 = 1;
pub const OSBigEndian: _bindgen_ty_1 = 2;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
pub type NXSwappedFloat = ::std::os::raw::c_ulong;
pub type NXSwappedDouble = ::std::os::raw::c_ulonglong;
pub const NXByteOrder_NX_UnknownByteOrder: NXByteOrder = 0;
pub const NXByteOrder_NX_LittleEndian: NXByteOrder = 1;
pub const NXByteOrder_NX_BigEndian: NXByteOrder = 2;
pub type NXByteOrder = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_header {
    pub magic: u32,
    pub cputype: cpu_type_t,
    pub cpusubtype: cpu_subtype_t,
    pub filetype: u32,
    pub ncmds: u32,
    pub sizeofcmds: u32,
    pub flags: u32,
}
#[test]
fn bindgen_test_layout_mach_header() {
    assert_eq!(
        ::std::mem::size_of::<mach_header>(),
        28usize,
        concat!("Size of: ", stringify!(mach_header))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_header>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_header))
    );
    fn test_field_magic() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_header>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_header),
                "::",
                stringify!(magic)
            )
        );
    }
    test_field_magic();
    fn test_field_cputype() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_header>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cputype) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_header),
                "::",
                stringify!(cputype)
            )
        );
    }
    test_field_cputype();
    fn test_field_cpusubtype() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_header>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cpusubtype) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_header),
                "::",
                stringify!(cpusubtype)
            )
        );
    }
    test_field_cpusubtype();
    fn test_field_filetype() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_header>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).filetype) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_header),
                "::",
                stringify!(filetype)
            )
        );
    }
    test_field_filetype();
    fn test_field_ncmds() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_header>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ncmds) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_header),
                "::",
                stringify!(ncmds)
            )
        );
    }
    test_field_ncmds();
    fn test_field_sizeofcmds() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_header>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sizeofcmds) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_header),
                "::",
                stringify!(sizeofcmds)
            )
        );
    }
    test_field_sizeofcmds();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_header>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_header),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_header_64 {
    pub magic: u32,
    pub cputype: cpu_type_t,
    pub cpusubtype: cpu_subtype_t,
    pub filetype: u32,
    pub ncmds: u32,
    pub sizeofcmds: u32,
    pub flags: u32,
    pub reserved: u32,
}
#[test]
fn bindgen_test_layout_mach_header_64() {
    assert_eq!(
        ::std::mem::size_of::<mach_header_64>(),
        32usize,
        concat!("Size of: ", stringify!(mach_header_64))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_header_64>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_header_64))
    );
    fn test_field_magic() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_header_64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_header_64),
                "::",
                stringify!(magic)
            )
        );
    }
    test_field_magic();
    fn test_field_cputype() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_header_64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cputype) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_header_64),
                "::",
                stringify!(cputype)
            )
        );
    }
    test_field_cputype();
    fn test_field_cpusubtype() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_header_64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cpusubtype) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_header_64),
                "::",
                stringify!(cpusubtype)
            )
        );
    }
    test_field_cpusubtype();
    fn test_field_filetype() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_header_64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).filetype) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_header_64),
                "::",
                stringify!(filetype)
            )
        );
    }
    test_field_filetype();
    fn test_field_ncmds() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_header_64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ncmds) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_header_64),
                "::",
                stringify!(ncmds)
            )
        );
    }
    test_field_ncmds();
    fn test_field_sizeofcmds() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_header_64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sizeofcmds) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_header_64),
                "::",
                stringify!(sizeofcmds)
            )
        );
    }
    test_field_sizeofcmds();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_header_64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_header_64),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_header_64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_header_64),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct load_command {
    pub cmd: u32,
    pub cmdsize: u32,
}
#[test]
fn bindgen_test_layout_load_command() {
    assert_eq!(
        ::std::mem::size_of::<load_command>(),
        8usize,
        concat!("Size of: ", stringify!(load_command))
    );
    assert_eq!(
        ::std::mem::align_of::<load_command>(),
        4usize,
        concat!("Alignment of ", stringify!(load_command))
    );
    fn test_field_cmd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<load_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(load_command),
                "::",
                stringify!(cmd)
            )
        );
    }
    test_field_cmd();
    fn test_field_cmdsize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<load_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmdsize) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(load_command),
                "::",
                stringify!(cmdsize)
            )
        );
    }
    test_field_cmdsize();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lc_str {
    pub offset: u32,
}
#[test]
fn bindgen_test_layout_lc_str() {
    assert_eq!(
        ::std::mem::size_of::<lc_str>(),
        4usize,
        concat!("Size of: ", stringify!(lc_str))
    );
    assert_eq!(
        ::std::mem::align_of::<lc_str>(),
        4usize,
        concat!("Alignment of ", stringify!(lc_str))
    );
    fn test_field_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<lc_str>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(lc_str),
                "::",
                stringify!(offset)
            )
        );
    }
    test_field_offset();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct segment_command {
    pub cmd: u32,
    pub cmdsize: u32,
    pub segname: [::std::os::raw::c_char; 16usize],
    pub vmaddr: u32,
    pub vmsize: u32,
    pub fileoff: u32,
    pub filesize: u32,
    pub maxprot: vm_prot_t,
    pub initprot: vm_prot_t,
    pub nsects: u32,
    pub flags: u32,
}
#[test]
fn bindgen_test_layout_segment_command() {
    assert_eq!(
        ::std::mem::size_of::<segment_command>(),
        56usize,
        concat!("Size of: ", stringify!(segment_command))
    );
    assert_eq!(
        ::std::mem::align_of::<segment_command>(),
        4usize,
        concat!("Alignment of ", stringify!(segment_command))
    );
    fn test_field_cmd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<segment_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(segment_command),
                "::",
                stringify!(cmd)
            )
        );
    }
    test_field_cmd();
    fn test_field_cmdsize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<segment_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmdsize) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(segment_command),
                "::",
                stringify!(cmdsize)
            )
        );
    }
    test_field_cmdsize();
    fn test_field_segname() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<segment_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).segname) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(segment_command),
                "::",
                stringify!(segname)
            )
        );
    }
    test_field_segname();
    fn test_field_vmaddr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<segment_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vmaddr) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(segment_command),
                "::",
                stringify!(vmaddr)
            )
        );
    }
    test_field_vmaddr();
    fn test_field_vmsize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<segment_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vmsize) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(segment_command),
                "::",
                stringify!(vmsize)
            )
        );
    }
    test_field_vmsize();
    fn test_field_fileoff() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<segment_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fileoff) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(segment_command),
                "::",
                stringify!(fileoff)
            )
        );
    }
    test_field_fileoff();
    fn test_field_filesize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<segment_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).filesize) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(segment_command),
                "::",
                stringify!(filesize)
            )
        );
    }
    test_field_filesize();
    fn test_field_maxprot() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<segment_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxprot) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(segment_command),
                "::",
                stringify!(maxprot)
            )
        );
    }
    test_field_maxprot();
    fn test_field_initprot() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<segment_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).initprot) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(segment_command),
                "::",
                stringify!(initprot)
            )
        );
    }
    test_field_initprot();
    fn test_field_nsects() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<segment_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nsects) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(segment_command),
                "::",
                stringify!(nsects)
            )
        );
    }
    test_field_nsects();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<segment_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(segment_command),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct segment_command_64 {
    pub cmd: u32,
    pub cmdsize: u32,
    pub segname: [::std::os::raw::c_char; 16usize],
    pub vmaddr: u64,
    pub vmsize: u64,
    pub fileoff: u64,
    pub filesize: u64,
    pub maxprot: vm_prot_t,
    pub initprot: vm_prot_t,
    pub nsects: u32,
    pub flags: u32,
}
#[test]
fn bindgen_test_layout_segment_command_64() {
    assert_eq!(
        ::std::mem::size_of::<segment_command_64>(),
        72usize,
        concat!("Size of: ", stringify!(segment_command_64))
    );
    assert_eq!(
        ::std::mem::align_of::<segment_command_64>(),
        8usize,
        concat!("Alignment of ", stringify!(segment_command_64))
    );
    fn test_field_cmd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<segment_command_64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(segment_command_64),
                "::",
                stringify!(cmd)
            )
        );
    }
    test_field_cmd();
    fn test_field_cmdsize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<segment_command_64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmdsize) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(segment_command_64),
                "::",
                stringify!(cmdsize)
            )
        );
    }
    test_field_cmdsize();
    fn test_field_segname() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<segment_command_64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).segname) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(segment_command_64),
                "::",
                stringify!(segname)
            )
        );
    }
    test_field_segname();
    fn test_field_vmaddr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<segment_command_64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vmaddr) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(segment_command_64),
                "::",
                stringify!(vmaddr)
            )
        );
    }
    test_field_vmaddr();
    fn test_field_vmsize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<segment_command_64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vmsize) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(segment_command_64),
                "::",
                stringify!(vmsize)
            )
        );
    }
    test_field_vmsize();
    fn test_field_fileoff() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<segment_command_64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fileoff) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(segment_command_64),
                "::",
                stringify!(fileoff)
            )
        );
    }
    test_field_fileoff();
    fn test_field_filesize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<segment_command_64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).filesize) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(segment_command_64),
                "::",
                stringify!(filesize)
            )
        );
    }
    test_field_filesize();
    fn test_field_maxprot() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<segment_command_64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxprot) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(segment_command_64),
                "::",
                stringify!(maxprot)
            )
        );
    }
    test_field_maxprot();
    fn test_field_initprot() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<segment_command_64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).initprot) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(segment_command_64),
                "::",
                stringify!(initprot)
            )
        );
    }
    test_field_initprot();
    fn test_field_nsects() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<segment_command_64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nsects) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(segment_command_64),
                "::",
                stringify!(nsects)
            )
        );
    }
    test_field_nsects();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<segment_command_64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(segment_command_64),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct section {
    pub sectname: [::std::os::raw::c_char; 16usize],
    pub segname: [::std::os::raw::c_char; 16usize],
    pub addr: u32,
    pub size: u32,
    pub offset: u32,
    pub align: u32,
    pub reloff: u32,
    pub nreloc: u32,
    pub flags: u32,
    pub reserved1: u32,
    pub reserved2: u32,
}
#[test]
fn bindgen_test_layout_section() {
    assert_eq!(
        ::std::mem::size_of::<section>(),
        68usize,
        concat!("Size of: ", stringify!(section))
    );
    assert_eq!(
        ::std::mem::align_of::<section>(),
        4usize,
        concat!("Alignment of ", stringify!(section))
    );
    fn test_field_sectname() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<section>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sectname) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(section),
                "::",
                stringify!(sectname)
            )
        );
    }
    test_field_sectname();
    fn test_field_segname() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<section>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).segname) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(section),
                "::",
                stringify!(segname)
            )
        );
    }
    test_field_segname();
    fn test_field_addr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<section>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).addr) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(section),
                "::",
                stringify!(addr)
            )
        );
    }
    test_field_addr();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<section>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(section),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<section>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(section),
                "::",
                stringify!(offset)
            )
        );
    }
    test_field_offset();
    fn test_field_align() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<section>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).align) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(section),
                "::",
                stringify!(align)
            )
        );
    }
    test_field_align();
    fn test_field_reloff() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<section>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reloff) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(section),
                "::",
                stringify!(reloff)
            )
        );
    }
    test_field_reloff();
    fn test_field_nreloc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<section>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nreloc) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(section),
                "::",
                stringify!(nreloc)
            )
        );
    }
    test_field_nreloc();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<section>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(section),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_reserved1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<section>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(section),
                "::",
                stringify!(reserved1)
            )
        );
    }
    test_field_reserved1();
    fn test_field_reserved2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<section>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(section),
                "::",
                stringify!(reserved2)
            )
        );
    }
    test_field_reserved2();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct section_64 {
    pub sectname: [::std::os::raw::c_char; 16usize],
    pub segname: [::std::os::raw::c_char; 16usize],
    pub addr: u64,
    pub size: u64,
    pub offset: u32,
    pub align: u32,
    pub reloff: u32,
    pub nreloc: u32,
    pub flags: u32,
    pub reserved1: u32,
    pub reserved2: u32,
    pub reserved3: u32,
}
#[test]
fn bindgen_test_layout_section_64() {
    assert_eq!(
        ::std::mem::size_of::<section_64>(),
        80usize,
        concat!("Size of: ", stringify!(section_64))
    );
    assert_eq!(
        ::std::mem::align_of::<section_64>(),
        8usize,
        concat!("Alignment of ", stringify!(section_64))
    );
    fn test_field_sectname() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<section_64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sectname) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(section_64),
                "::",
                stringify!(sectname)
            )
        );
    }
    test_field_sectname();
    fn test_field_segname() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<section_64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).segname) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(section_64),
                "::",
                stringify!(segname)
            )
        );
    }
    test_field_segname();
    fn test_field_addr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<section_64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).addr) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(section_64),
                "::",
                stringify!(addr)
            )
        );
    }
    test_field_addr();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<section_64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(section_64),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<section_64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(section_64),
                "::",
                stringify!(offset)
            )
        );
    }
    test_field_offset();
    fn test_field_align() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<section_64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).align) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(section_64),
                "::",
                stringify!(align)
            )
        );
    }
    test_field_align();
    fn test_field_reloff() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<section_64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reloff) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(section_64),
                "::",
                stringify!(reloff)
            )
        );
    }
    test_field_reloff();
    fn test_field_nreloc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<section_64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nreloc) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(section_64),
                "::",
                stringify!(nreloc)
            )
        );
    }
    test_field_nreloc();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<section_64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(section_64),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_reserved1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<section_64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize
            },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(section_64),
                "::",
                stringify!(reserved1)
            )
        );
    }
    test_field_reserved1();
    fn test_field_reserved2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<section_64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(section_64),
                "::",
                stringify!(reserved2)
            )
        );
    }
    test_field_reserved2();
    fn test_field_reserved3() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<section_64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved3) as usize - ptr as usize
            },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(section_64),
                "::",
                stringify!(reserved3)
            )
        );
    }
    test_field_reserved3();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fvmlib {
    pub name: lc_str,
    pub minor_version: u32,
    pub header_addr: u32,
}
#[test]
fn bindgen_test_layout_fvmlib() {
    assert_eq!(
        ::std::mem::size_of::<fvmlib>(),
        12usize,
        concat!("Size of: ", stringify!(fvmlib))
    );
    assert_eq!(
        ::std::mem::align_of::<fvmlib>(),
        4usize,
        concat!("Alignment of ", stringify!(fvmlib))
    );
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fvmlib>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fvmlib),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_minor_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fvmlib>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minor_version) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(fvmlib),
                "::",
                stringify!(minor_version)
            )
        );
    }
    test_field_minor_version();
    fn test_field_header_addr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fvmlib>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).header_addr) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fvmlib),
                "::",
                stringify!(header_addr)
            )
        );
    }
    test_field_header_addr();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fvmlib_command {
    pub cmd: u32,
    pub cmdsize: u32,
    pub fvmlib: fvmlib,
}
#[test]
fn bindgen_test_layout_fvmlib_command() {
    assert_eq!(
        ::std::mem::size_of::<fvmlib_command>(),
        20usize,
        concat!("Size of: ", stringify!(fvmlib_command))
    );
    assert_eq!(
        ::std::mem::align_of::<fvmlib_command>(),
        4usize,
        concat!("Alignment of ", stringify!(fvmlib_command))
    );
    fn test_field_cmd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fvmlib_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fvmlib_command),
                "::",
                stringify!(cmd)
            )
        );
    }
    test_field_cmd();
    fn test_field_cmdsize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fvmlib_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmdsize) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(fvmlib_command),
                "::",
                stringify!(cmdsize)
            )
        );
    }
    test_field_cmdsize();
    fn test_field_fvmlib() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fvmlib_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fvmlib) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fvmlib_command),
                "::",
                stringify!(fvmlib)
            )
        );
    }
    test_field_fvmlib();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dylib {
    pub name: lc_str,
    pub timestamp: u32,
    pub current_version: u32,
    pub compatibility_version: u32,
}
#[test]
fn bindgen_test_layout_dylib() {
    assert_eq!(
        ::std::mem::size_of::<dylib>(),
        16usize,
        concat!("Size of: ", stringify!(dylib))
    );
    assert_eq!(
        ::std::mem::align_of::<dylib>(),
        4usize,
        concat!("Alignment of ", stringify!(dylib))
    );
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dylib>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(dylib),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_timestamp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dylib>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(dylib),
                "::",
                stringify!(timestamp)
            )
        );
    }
    test_field_timestamp();
    fn test_field_current_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dylib>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).current_version) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(dylib),
                "::",
                stringify!(current_version)
            )
        );
    }
    test_field_current_version();
    fn test_field_compatibility_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dylib>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).compatibility_version) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(dylib),
                "::",
                stringify!(compatibility_version)
            )
        );
    }
    test_field_compatibility_version();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dylib_command {
    pub cmd: u32,
    pub cmdsize: u32,
    pub dylib: dylib,
}
#[test]
fn bindgen_test_layout_dylib_command() {
    assert_eq!(
        ::std::mem::size_of::<dylib_command>(),
        24usize,
        concat!("Size of: ", stringify!(dylib_command))
    );
    assert_eq!(
        ::std::mem::align_of::<dylib_command>(),
        4usize,
        concat!("Alignment of ", stringify!(dylib_command))
    );
    fn test_field_cmd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dylib_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(dylib_command),
                "::",
                stringify!(cmd)
            )
        );
    }
    test_field_cmd();
    fn test_field_cmdsize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dylib_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmdsize) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(dylib_command),
                "::",
                stringify!(cmdsize)
            )
        );
    }
    test_field_cmdsize();
    fn test_field_dylib() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dylib_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dylib) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(dylib_command),
                "::",
                stringify!(dylib)
            )
        );
    }
    test_field_dylib();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sub_framework_command {
    pub cmd: u32,
    pub cmdsize: u32,
    pub umbrella: lc_str,
}
#[test]
fn bindgen_test_layout_sub_framework_command() {
    assert_eq!(
        ::std::mem::size_of::<sub_framework_command>(),
        12usize,
        concat!("Size of: ", stringify!(sub_framework_command))
    );
    assert_eq!(
        ::std::mem::align_of::<sub_framework_command>(),
        4usize,
        concat!("Alignment of ", stringify!(sub_framework_command))
    );
    fn test_field_cmd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sub_framework_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sub_framework_command),
                "::",
                stringify!(cmd)
            )
        );
    }
    test_field_cmd();
    fn test_field_cmdsize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sub_framework_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmdsize) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(sub_framework_command),
                "::",
                stringify!(cmdsize)
            )
        );
    }
    test_field_cmdsize();
    fn test_field_umbrella() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sub_framework_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).umbrella) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(sub_framework_command),
                "::",
                stringify!(umbrella)
            )
        );
    }
    test_field_umbrella();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sub_client_command {
    pub cmd: u32,
    pub cmdsize: u32,
    pub client: lc_str,
}
#[test]
fn bindgen_test_layout_sub_client_command() {
    assert_eq!(
        ::std::mem::size_of::<sub_client_command>(),
        12usize,
        concat!("Size of: ", stringify!(sub_client_command))
    );
    assert_eq!(
        ::std::mem::align_of::<sub_client_command>(),
        4usize,
        concat!("Alignment of ", stringify!(sub_client_command))
    );
    fn test_field_cmd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sub_client_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sub_client_command),
                "::",
                stringify!(cmd)
            )
        );
    }
    test_field_cmd();
    fn test_field_cmdsize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sub_client_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmdsize) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(sub_client_command),
                "::",
                stringify!(cmdsize)
            )
        );
    }
    test_field_cmdsize();
    fn test_field_client() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sub_client_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).client) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(sub_client_command),
                "::",
                stringify!(client)
            )
        );
    }
    test_field_client();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sub_umbrella_command {
    pub cmd: u32,
    pub cmdsize: u32,
    pub sub_umbrella: lc_str,
}
#[test]
fn bindgen_test_layout_sub_umbrella_command() {
    assert_eq!(
        ::std::mem::size_of::<sub_umbrella_command>(),
        12usize,
        concat!("Size of: ", stringify!(sub_umbrella_command))
    );
    assert_eq!(
        ::std::mem::align_of::<sub_umbrella_command>(),
        4usize,
        concat!("Alignment of ", stringify!(sub_umbrella_command))
    );
    fn test_field_cmd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sub_umbrella_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sub_umbrella_command),
                "::",
                stringify!(cmd)
            )
        );
    }
    test_field_cmd();
    fn test_field_cmdsize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sub_umbrella_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmdsize) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(sub_umbrella_command),
                "::",
                stringify!(cmdsize)
            )
        );
    }
    test_field_cmdsize();
    fn test_field_sub_umbrella() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sub_umbrella_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sub_umbrella) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(sub_umbrella_command),
                "::",
                stringify!(sub_umbrella)
            )
        );
    }
    test_field_sub_umbrella();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sub_library_command {
    pub cmd: u32,
    pub cmdsize: u32,
    pub sub_library: lc_str,
}
#[test]
fn bindgen_test_layout_sub_library_command() {
    assert_eq!(
        ::std::mem::size_of::<sub_library_command>(),
        12usize,
        concat!("Size of: ", stringify!(sub_library_command))
    );
    assert_eq!(
        ::std::mem::align_of::<sub_library_command>(),
        4usize,
        concat!("Alignment of ", stringify!(sub_library_command))
    );
    fn test_field_cmd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sub_library_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sub_library_command),
                "::",
                stringify!(cmd)
            )
        );
    }
    test_field_cmd();
    fn test_field_cmdsize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sub_library_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmdsize) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(sub_library_command),
                "::",
                stringify!(cmdsize)
            )
        );
    }
    test_field_cmdsize();
    fn test_field_sub_library() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sub_library_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sub_library) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(sub_library_command),
                "::",
                stringify!(sub_library)
            )
        );
    }
    test_field_sub_library();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct prebound_dylib_command {
    pub cmd: u32,
    pub cmdsize: u32,
    pub name: lc_str,
    pub nmodules: u32,
    pub linked_modules: lc_str,
}
#[test]
fn bindgen_test_layout_prebound_dylib_command() {
    assert_eq!(
        ::std::mem::size_of::<prebound_dylib_command>(),
        20usize,
        concat!("Size of: ", stringify!(prebound_dylib_command))
    );
    assert_eq!(
        ::std::mem::align_of::<prebound_dylib_command>(),
        4usize,
        concat!("Alignment of ", stringify!(prebound_dylib_command))
    );
    fn test_field_cmd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<prebound_dylib_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(prebound_dylib_command),
                "::",
                stringify!(cmd)
            )
        );
    }
    test_field_cmd();
    fn test_field_cmdsize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<prebound_dylib_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmdsize) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(prebound_dylib_command),
                "::",
                stringify!(cmdsize)
            )
        );
    }
    test_field_cmdsize();
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<prebound_dylib_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(prebound_dylib_command),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_nmodules() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<prebound_dylib_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nmodules) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(prebound_dylib_command),
                "::",
                stringify!(nmodules)
            )
        );
    }
    test_field_nmodules();
    fn test_field_linked_modules() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<prebound_dylib_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).linked_modules) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(prebound_dylib_command),
                "::",
                stringify!(linked_modules)
            )
        );
    }
    test_field_linked_modules();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dylinker_command {
    pub cmd: u32,
    pub cmdsize: u32,
    pub name: lc_str,
}
#[test]
fn bindgen_test_layout_dylinker_command() {
    assert_eq!(
        ::std::mem::size_of::<dylinker_command>(),
        12usize,
        concat!("Size of: ", stringify!(dylinker_command))
    );
    assert_eq!(
        ::std::mem::align_of::<dylinker_command>(),
        4usize,
        concat!("Alignment of ", stringify!(dylinker_command))
    );
    fn test_field_cmd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dylinker_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(dylinker_command),
                "::",
                stringify!(cmd)
            )
        );
    }
    test_field_cmd();
    fn test_field_cmdsize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dylinker_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmdsize) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(dylinker_command),
                "::",
                stringify!(cmdsize)
            )
        );
    }
    test_field_cmdsize();
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dylinker_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(dylinker_command),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct thread_command {
    pub cmd: u32,
    pub cmdsize: u32,
}
#[test]
fn bindgen_test_layout_thread_command() {
    assert_eq!(
        ::std::mem::size_of::<thread_command>(),
        8usize,
        concat!("Size of: ", stringify!(thread_command))
    );
    assert_eq!(
        ::std::mem::align_of::<thread_command>(),
        4usize,
        concat!("Alignment of ", stringify!(thread_command))
    );
    fn test_field_cmd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<thread_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(thread_command),
                "::",
                stringify!(cmd)
            )
        );
    }
    test_field_cmd();
    fn test_field_cmdsize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<thread_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmdsize) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(thread_command),
                "::",
                stringify!(cmdsize)
            )
        );
    }
    test_field_cmdsize();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct routines_command {
    pub cmd: u32,
    pub cmdsize: u32,
    pub init_address: u32,
    pub init_module: u32,
    pub reserved1: u32,
    pub reserved2: u32,
    pub reserved3: u32,
    pub reserved4: u32,
    pub reserved5: u32,
    pub reserved6: u32,
}
#[test]
fn bindgen_test_layout_routines_command() {
    assert_eq!(
        ::std::mem::size_of::<routines_command>(),
        40usize,
        concat!("Size of: ", stringify!(routines_command))
    );
    assert_eq!(
        ::std::mem::align_of::<routines_command>(),
        4usize,
        concat!("Alignment of ", stringify!(routines_command))
    );
    fn test_field_cmd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<routines_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(routines_command),
                "::",
                stringify!(cmd)
            )
        );
    }
    test_field_cmd();
    fn test_field_cmdsize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<routines_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmdsize) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(routines_command),
                "::",
                stringify!(cmdsize)
            )
        );
    }
    test_field_cmdsize();
    fn test_field_init_address() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<routines_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).init_address) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(routines_command),
                "::",
                stringify!(init_address)
            )
        );
    }
    test_field_init_address();
    fn test_field_init_module() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<routines_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).init_module) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(routines_command),
                "::",
                stringify!(init_module)
            )
        );
    }
    test_field_init_module();
    fn test_field_reserved1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<routines_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(routines_command),
                "::",
                stringify!(reserved1)
            )
        );
    }
    test_field_reserved1();
    fn test_field_reserved2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<routines_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(routines_command),
                "::",
                stringify!(reserved2)
            )
        );
    }
    test_field_reserved2();
    fn test_field_reserved3() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<routines_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved3) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(routines_command),
                "::",
                stringify!(reserved3)
            )
        );
    }
    test_field_reserved3();
    fn test_field_reserved4() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<routines_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved4) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(routines_command),
                "::",
                stringify!(reserved4)
            )
        );
    }
    test_field_reserved4();
    fn test_field_reserved5() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<routines_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved5) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(routines_command),
                "::",
                stringify!(reserved5)
            )
        );
    }
    test_field_reserved5();
    fn test_field_reserved6() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<routines_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved6) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(routines_command),
                "::",
                stringify!(reserved6)
            )
        );
    }
    test_field_reserved6();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct routines_command_64 {
    pub cmd: u32,
    pub cmdsize: u32,
    pub init_address: u64,
    pub init_module: u64,
    pub reserved1: u64,
    pub reserved2: u64,
    pub reserved3: u64,
    pub reserved4: u64,
    pub reserved5: u64,
    pub reserved6: u64,
}
#[test]
fn bindgen_test_layout_routines_command_64() {
    assert_eq!(
        ::std::mem::size_of::<routines_command_64>(),
        72usize,
        concat!("Size of: ", stringify!(routines_command_64))
    );
    assert_eq!(
        ::std::mem::align_of::<routines_command_64>(),
        8usize,
        concat!("Alignment of ", stringify!(routines_command_64))
    );
    fn test_field_cmd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<routines_command_64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(routines_command_64),
                "::",
                stringify!(cmd)
            )
        );
    }
    test_field_cmd();
    fn test_field_cmdsize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<routines_command_64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmdsize) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(routines_command_64),
                "::",
                stringify!(cmdsize)
            )
        );
    }
    test_field_cmdsize();
    fn test_field_init_address() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<routines_command_64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).init_address) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(routines_command_64),
                "::",
                stringify!(init_address)
            )
        );
    }
    test_field_init_address();
    fn test_field_init_module() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<routines_command_64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).init_module) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(routines_command_64),
                "::",
                stringify!(init_module)
            )
        );
    }
    test_field_init_module();
    fn test_field_reserved1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<routines_command_64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(routines_command_64),
                "::",
                stringify!(reserved1)
            )
        );
    }
    test_field_reserved1();
    fn test_field_reserved2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<routines_command_64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(routines_command_64),
                "::",
                stringify!(reserved2)
            )
        );
    }
    test_field_reserved2();
    fn test_field_reserved3() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<routines_command_64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved3) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(routines_command_64),
                "::",
                stringify!(reserved3)
            )
        );
    }
    test_field_reserved3();
    fn test_field_reserved4() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<routines_command_64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved4) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(routines_command_64),
                "::",
                stringify!(reserved4)
            )
        );
    }
    test_field_reserved4();
    fn test_field_reserved5() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<routines_command_64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved5) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(routines_command_64),
                "::",
                stringify!(reserved5)
            )
        );
    }
    test_field_reserved5();
    fn test_field_reserved6() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<routines_command_64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved6) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(routines_command_64),
                "::",
                stringify!(reserved6)
            )
        );
    }
    test_field_reserved6();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct symtab_command {
    pub cmd: u32,
    pub cmdsize: u32,
    pub symoff: u32,
    pub nsyms: u32,
    pub stroff: u32,
    pub strsize: u32,
}
#[test]
fn bindgen_test_layout_symtab_command() {
    assert_eq!(
        ::std::mem::size_of::<symtab_command>(),
        24usize,
        concat!("Size of: ", stringify!(symtab_command))
    );
    assert_eq!(
        ::std::mem::align_of::<symtab_command>(),
        4usize,
        concat!("Alignment of ", stringify!(symtab_command))
    );
    fn test_field_cmd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<symtab_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(symtab_command),
                "::",
                stringify!(cmd)
            )
        );
    }
    test_field_cmd();
    fn test_field_cmdsize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<symtab_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmdsize) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(symtab_command),
                "::",
                stringify!(cmdsize)
            )
        );
    }
    test_field_cmdsize();
    fn test_field_symoff() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<symtab_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).symoff) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(symtab_command),
                "::",
                stringify!(symoff)
            )
        );
    }
    test_field_symoff();
    fn test_field_nsyms() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<symtab_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nsyms) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(symtab_command),
                "::",
                stringify!(nsyms)
            )
        );
    }
    test_field_nsyms();
    fn test_field_stroff() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<symtab_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stroff) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(symtab_command),
                "::",
                stringify!(stroff)
            )
        );
    }
    test_field_stroff();
    fn test_field_strsize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<symtab_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).strsize) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(symtab_command),
                "::",
                stringify!(strsize)
            )
        );
    }
    test_field_strsize();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dysymtab_command {
    pub cmd: u32,
    pub cmdsize: u32,
    pub ilocalsym: u32,
    pub nlocalsym: u32,
    pub iextdefsym: u32,
    pub nextdefsym: u32,
    pub iundefsym: u32,
    pub nundefsym: u32,
    pub tocoff: u32,
    pub ntoc: u32,
    pub modtaboff: u32,
    pub nmodtab: u32,
    pub extrefsymoff: u32,
    pub nextrefsyms: u32,
    pub indirectsymoff: u32,
    pub nindirectsyms: u32,
    pub extreloff: u32,
    pub nextrel: u32,
    pub locreloff: u32,
    pub nlocrel: u32,
}
#[test]
fn bindgen_test_layout_dysymtab_command() {
    assert_eq!(
        ::std::mem::size_of::<dysymtab_command>(),
        80usize,
        concat!("Size of: ", stringify!(dysymtab_command))
    );
    assert_eq!(
        ::std::mem::align_of::<dysymtab_command>(),
        4usize,
        concat!("Alignment of ", stringify!(dysymtab_command))
    );
    fn test_field_cmd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dysymtab_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(dysymtab_command),
                "::",
                stringify!(cmd)
            )
        );
    }
    test_field_cmd();
    fn test_field_cmdsize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dysymtab_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmdsize) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(dysymtab_command),
                "::",
                stringify!(cmdsize)
            )
        );
    }
    test_field_cmdsize();
    fn test_field_ilocalsym() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dysymtab_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ilocalsym) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(dysymtab_command),
                "::",
                stringify!(ilocalsym)
            )
        );
    }
    test_field_ilocalsym();
    fn test_field_nlocalsym() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dysymtab_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nlocalsym) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(dysymtab_command),
                "::",
                stringify!(nlocalsym)
            )
        );
    }
    test_field_nlocalsym();
    fn test_field_iextdefsym() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dysymtab_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).iextdefsym) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(dysymtab_command),
                "::",
                stringify!(iextdefsym)
            )
        );
    }
    test_field_iextdefsym();
    fn test_field_nextdefsym() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dysymtab_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nextdefsym) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(dysymtab_command),
                "::",
                stringify!(nextdefsym)
            )
        );
    }
    test_field_nextdefsym();
    fn test_field_iundefsym() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dysymtab_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).iundefsym) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(dysymtab_command),
                "::",
                stringify!(iundefsym)
            )
        );
    }
    test_field_iundefsym();
    fn test_field_nundefsym() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dysymtab_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nundefsym) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(dysymtab_command),
                "::",
                stringify!(nundefsym)
            )
        );
    }
    test_field_nundefsym();
    fn test_field_tocoff() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dysymtab_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tocoff) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(dysymtab_command),
                "::",
                stringify!(tocoff)
            )
        );
    }
    test_field_tocoff();
    fn test_field_ntoc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dysymtab_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ntoc) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(dysymtab_command),
                "::",
                stringify!(ntoc)
            )
        );
    }
    test_field_ntoc();
    fn test_field_modtaboff() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dysymtab_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).modtaboff) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(dysymtab_command),
                "::",
                stringify!(modtaboff)
            )
        );
    }
    test_field_modtaboff();
    fn test_field_nmodtab() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dysymtab_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nmodtab) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(dysymtab_command),
                "::",
                stringify!(nmodtab)
            )
        );
    }
    test_field_nmodtab();
    fn test_field_extrefsymoff() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dysymtab_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extrefsymoff) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(dysymtab_command),
                "::",
                stringify!(extrefsymoff)
            )
        );
    }
    test_field_extrefsymoff();
    fn test_field_nextrefsyms() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dysymtab_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nextrefsyms) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(dysymtab_command),
                "::",
                stringify!(nextrefsyms)
            )
        );
    }
    test_field_nextrefsyms();
    fn test_field_indirectsymoff() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dysymtab_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).indirectsymoff) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(dysymtab_command),
                "::",
                stringify!(indirectsymoff)
            )
        );
    }
    test_field_indirectsymoff();
    fn test_field_nindirectsyms() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dysymtab_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nindirectsyms) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(dysymtab_command),
                "::",
                stringify!(nindirectsyms)
            )
        );
    }
    test_field_nindirectsyms();
    fn test_field_extreloff() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dysymtab_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extreloff) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(dysymtab_command),
                "::",
                stringify!(extreloff)
            )
        );
    }
    test_field_extreloff();
    fn test_field_nextrel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dysymtab_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nextrel) as usize - ptr as usize
            },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(dysymtab_command),
                "::",
                stringify!(nextrel)
            )
        );
    }
    test_field_nextrel();
    fn test_field_locreloff() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dysymtab_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).locreloff) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(dysymtab_command),
                "::",
                stringify!(locreloff)
            )
        );
    }
    test_field_locreloff();
    fn test_field_nlocrel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dysymtab_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nlocrel) as usize - ptr as usize
            },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(dysymtab_command),
                "::",
                stringify!(nlocrel)
            )
        );
    }
    test_field_nlocrel();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dylib_table_of_contents {
    pub symbol_index: u32,
    pub module_index: u32,
}
#[test]
fn bindgen_test_layout_dylib_table_of_contents() {
    assert_eq!(
        ::std::mem::size_of::<dylib_table_of_contents>(),
        8usize,
        concat!("Size of: ", stringify!(dylib_table_of_contents))
    );
    assert_eq!(
        ::std::mem::align_of::<dylib_table_of_contents>(),
        4usize,
        concat!("Alignment of ", stringify!(dylib_table_of_contents))
    );
    fn test_field_symbol_index() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dylib_table_of_contents>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).symbol_index) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(dylib_table_of_contents),
                "::",
                stringify!(symbol_index)
            )
        );
    }
    test_field_symbol_index();
    fn test_field_module_index() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dylib_table_of_contents>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).module_index) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(dylib_table_of_contents),
                "::",
                stringify!(module_index)
            )
        );
    }
    test_field_module_index();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dylib_module {
    pub module_name: u32,
    pub iextdefsym: u32,
    pub nextdefsym: u32,
    pub irefsym: u32,
    pub nrefsym: u32,
    pub ilocalsym: u32,
    pub nlocalsym: u32,
    pub iextrel: u32,
    pub nextrel: u32,
    pub iinit_iterm: u32,
    pub ninit_nterm: u32,
    pub objc_module_info_addr: u32,
    pub objc_module_info_size: u32,
}
#[test]
fn bindgen_test_layout_dylib_module() {
    assert_eq!(
        ::std::mem::size_of::<dylib_module>(),
        52usize,
        concat!("Size of: ", stringify!(dylib_module))
    );
    assert_eq!(
        ::std::mem::align_of::<dylib_module>(),
        4usize,
        concat!("Alignment of ", stringify!(dylib_module))
    );
    fn test_field_module_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dylib_module>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).module_name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(dylib_module),
                "::",
                stringify!(module_name)
            )
        );
    }
    test_field_module_name();
    fn test_field_iextdefsym() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dylib_module>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).iextdefsym) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(dylib_module),
                "::",
                stringify!(iextdefsym)
            )
        );
    }
    test_field_iextdefsym();
    fn test_field_nextdefsym() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dylib_module>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nextdefsym) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(dylib_module),
                "::",
                stringify!(nextdefsym)
            )
        );
    }
    test_field_nextdefsym();
    fn test_field_irefsym() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dylib_module>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).irefsym) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(dylib_module),
                "::",
                stringify!(irefsym)
            )
        );
    }
    test_field_irefsym();
    fn test_field_nrefsym() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dylib_module>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nrefsym) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(dylib_module),
                "::",
                stringify!(nrefsym)
            )
        );
    }
    test_field_nrefsym();
    fn test_field_ilocalsym() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dylib_module>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ilocalsym) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(dylib_module),
                "::",
                stringify!(ilocalsym)
            )
        );
    }
    test_field_ilocalsym();
    fn test_field_nlocalsym() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dylib_module>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nlocalsym) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(dylib_module),
                "::",
                stringify!(nlocalsym)
            )
        );
    }
    test_field_nlocalsym();
    fn test_field_iextrel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dylib_module>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).iextrel) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(dylib_module),
                "::",
                stringify!(iextrel)
            )
        );
    }
    test_field_iextrel();
    fn test_field_nextrel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dylib_module>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nextrel) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(dylib_module),
                "::",
                stringify!(nextrel)
            )
        );
    }
    test_field_nextrel();
    fn test_field_iinit_iterm() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dylib_module>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).iinit_iterm) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(dylib_module),
                "::",
                stringify!(iinit_iterm)
            )
        );
    }
    test_field_iinit_iterm();
    fn test_field_ninit_nterm() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dylib_module>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ninit_nterm) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(dylib_module),
                "::",
                stringify!(ninit_nterm)
            )
        );
    }
    test_field_ninit_nterm();
    fn test_field_objc_module_info_addr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dylib_module>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).objc_module_info_addr) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(dylib_module),
                "::",
                stringify!(objc_module_info_addr)
            )
        );
    }
    test_field_objc_module_info_addr();
    fn test_field_objc_module_info_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dylib_module>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).objc_module_info_size) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(dylib_module),
                "::",
                stringify!(objc_module_info_size)
            )
        );
    }
    test_field_objc_module_info_size();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dylib_module_64 {
    pub module_name: u32,
    pub iextdefsym: u32,
    pub nextdefsym: u32,
    pub irefsym: u32,
    pub nrefsym: u32,
    pub ilocalsym: u32,
    pub nlocalsym: u32,
    pub iextrel: u32,
    pub nextrel: u32,
    pub iinit_iterm: u32,
    pub ninit_nterm: u32,
    pub objc_module_info_size: u32,
    pub objc_module_info_addr: u64,
}
#[test]
fn bindgen_test_layout_dylib_module_64() {
    assert_eq!(
        ::std::mem::size_of::<dylib_module_64>(),
        56usize,
        concat!("Size of: ", stringify!(dylib_module_64))
    );
    assert_eq!(
        ::std::mem::align_of::<dylib_module_64>(),
        8usize,
        concat!("Alignment of ", stringify!(dylib_module_64))
    );
    fn test_field_module_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dylib_module_64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).module_name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(dylib_module_64),
                "::",
                stringify!(module_name)
            )
        );
    }
    test_field_module_name();
    fn test_field_iextdefsym() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dylib_module_64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).iextdefsym) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(dylib_module_64),
                "::",
                stringify!(iextdefsym)
            )
        );
    }
    test_field_iextdefsym();
    fn test_field_nextdefsym() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dylib_module_64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nextdefsym) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(dylib_module_64),
                "::",
                stringify!(nextdefsym)
            )
        );
    }
    test_field_nextdefsym();
    fn test_field_irefsym() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dylib_module_64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).irefsym) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(dylib_module_64),
                "::",
                stringify!(irefsym)
            )
        );
    }
    test_field_irefsym();
    fn test_field_nrefsym() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dylib_module_64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nrefsym) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(dylib_module_64),
                "::",
                stringify!(nrefsym)
            )
        );
    }
    test_field_nrefsym();
    fn test_field_ilocalsym() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dylib_module_64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ilocalsym) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(dylib_module_64),
                "::",
                stringify!(ilocalsym)
            )
        );
    }
    test_field_ilocalsym();
    fn test_field_nlocalsym() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dylib_module_64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nlocalsym) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(dylib_module_64),
                "::",
                stringify!(nlocalsym)
            )
        );
    }
    test_field_nlocalsym();
    fn test_field_iextrel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dylib_module_64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).iextrel) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(dylib_module_64),
                "::",
                stringify!(iextrel)
            )
        );
    }
    test_field_iextrel();
    fn test_field_nextrel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dylib_module_64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nextrel) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(dylib_module_64),
                "::",
                stringify!(nextrel)
            )
        );
    }
    test_field_nextrel();
    fn test_field_iinit_iterm() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dylib_module_64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).iinit_iterm) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(dylib_module_64),
                "::",
                stringify!(iinit_iterm)
            )
        );
    }
    test_field_iinit_iterm();
    fn test_field_ninit_nterm() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dylib_module_64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ninit_nterm) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(dylib_module_64),
                "::",
                stringify!(ninit_nterm)
            )
        );
    }
    test_field_ninit_nterm();
    fn test_field_objc_module_info_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dylib_module_64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).objc_module_info_size) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(dylib_module_64),
                "::",
                stringify!(objc_module_info_size)
            )
        );
    }
    test_field_objc_module_info_size();
    fn test_field_objc_module_info_addr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dylib_module_64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).objc_module_info_addr) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(dylib_module_64),
                "::",
                stringify!(objc_module_info_addr)
            )
        );
    }
    test_field_objc_module_info_addr();
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct dylib_reference {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_dylib_reference() {
    assert_eq!(
        ::std::mem::size_of::<dylib_reference>(),
        4usize,
        concat!("Size of: ", stringify!(dylib_reference))
    );
    assert_eq!(
        ::std::mem::align_of::<dylib_reference>(),
        4usize,
        concat!("Alignment of ", stringify!(dylib_reference))
    );
}
impl dylib_reference {
    #[inline]
    pub fn isym(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_isym(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn flags(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(isym: u32, flags: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let isym: u32 = unsafe { ::std::mem::transmute(isym) };
            isym as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let flags: u32 = unsafe { ::std::mem::transmute(flags) };
            flags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct twolevel_hints_command {
    pub cmd: u32,
    pub cmdsize: u32,
    pub offset: u32,
    pub nhints: u32,
}
#[test]
fn bindgen_test_layout_twolevel_hints_command() {
    assert_eq!(
        ::std::mem::size_of::<twolevel_hints_command>(),
        16usize,
        concat!("Size of: ", stringify!(twolevel_hints_command))
    );
    assert_eq!(
        ::std::mem::align_of::<twolevel_hints_command>(),
        4usize,
        concat!("Alignment of ", stringify!(twolevel_hints_command))
    );
    fn test_field_cmd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<twolevel_hints_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(twolevel_hints_command),
                "::",
                stringify!(cmd)
            )
        );
    }
    test_field_cmd();
    fn test_field_cmdsize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<twolevel_hints_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmdsize) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(twolevel_hints_command),
                "::",
                stringify!(cmdsize)
            )
        );
    }
    test_field_cmdsize();
    fn test_field_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<twolevel_hints_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(twolevel_hints_command),
                "::",
                stringify!(offset)
            )
        );
    }
    test_field_offset();
    fn test_field_nhints() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<twolevel_hints_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nhints) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(twolevel_hints_command),
                "::",
                stringify!(nhints)
            )
        );
    }
    test_field_nhints();
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct twolevel_hint {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_twolevel_hint() {
    assert_eq!(
        ::std::mem::size_of::<twolevel_hint>(),
        4usize,
        concat!("Size of: ", stringify!(twolevel_hint))
    );
    assert_eq!(
        ::std::mem::align_of::<twolevel_hint>(),
        4usize,
        concat!("Alignment of ", stringify!(twolevel_hint))
    );
}
impl twolevel_hint {
    #[inline]
    pub fn isub_image(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_isub_image(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn itoc(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_itoc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(isub_image: u32, itoc: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let isub_image: u32 = unsafe { ::std::mem::transmute(isub_image) };
            isub_image as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let itoc: u32 = unsafe { ::std::mem::transmute(itoc) };
            itoc as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct prebind_cksum_command {
    pub cmd: u32,
    pub cmdsize: u32,
    pub cksum: u32,
}
#[test]
fn bindgen_test_layout_prebind_cksum_command() {
    assert_eq!(
        ::std::mem::size_of::<prebind_cksum_command>(),
        12usize,
        concat!("Size of: ", stringify!(prebind_cksum_command))
    );
    assert_eq!(
        ::std::mem::align_of::<prebind_cksum_command>(),
        4usize,
        concat!("Alignment of ", stringify!(prebind_cksum_command))
    );
    fn test_field_cmd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<prebind_cksum_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(prebind_cksum_command),
                "::",
                stringify!(cmd)
            )
        );
    }
    test_field_cmd();
    fn test_field_cmdsize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<prebind_cksum_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmdsize) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(prebind_cksum_command),
                "::",
                stringify!(cmdsize)
            )
        );
    }
    test_field_cmdsize();
    fn test_field_cksum() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<prebind_cksum_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cksum) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(prebind_cksum_command),
                "::",
                stringify!(cksum)
            )
        );
    }
    test_field_cksum();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uuid_command {
    pub cmd: u32,
    pub cmdsize: u32,
    pub uuid: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_uuid_command() {
    assert_eq!(
        ::std::mem::size_of::<uuid_command>(),
        24usize,
        concat!("Size of: ", stringify!(uuid_command))
    );
    assert_eq!(
        ::std::mem::align_of::<uuid_command>(),
        4usize,
        concat!("Alignment of ", stringify!(uuid_command))
    );
    fn test_field_cmd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<uuid_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(uuid_command),
                "::",
                stringify!(cmd)
            )
        );
    }
    test_field_cmd();
    fn test_field_cmdsize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<uuid_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmdsize) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(uuid_command),
                "::",
                stringify!(cmdsize)
            )
        );
    }
    test_field_cmdsize();
    fn test_field_uuid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<uuid_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uuid) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(uuid_command),
                "::",
                stringify!(uuid)
            )
        );
    }
    test_field_uuid();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rpath_command {
    pub cmd: u32,
    pub cmdsize: u32,
    pub path: lc_str,
}
#[test]
fn bindgen_test_layout_rpath_command() {
    assert_eq!(
        ::std::mem::size_of::<rpath_command>(),
        12usize,
        concat!("Size of: ", stringify!(rpath_command))
    );
    assert_eq!(
        ::std::mem::align_of::<rpath_command>(),
        4usize,
        concat!("Alignment of ", stringify!(rpath_command))
    );
    fn test_field_cmd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rpath_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rpath_command),
                "::",
                stringify!(cmd)
            )
        );
    }
    test_field_cmd();
    fn test_field_cmdsize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rpath_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmdsize) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(rpath_command),
                "::",
                stringify!(cmdsize)
            )
        );
    }
    test_field_cmdsize();
    fn test_field_path() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rpath_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).path) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rpath_command),
                "::",
                stringify!(path)
            )
        );
    }
    test_field_path();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct linkedit_data_command {
    pub cmd: u32,
    pub cmdsize: u32,
    pub dataoff: u32,
    pub datasize: u32,
}
#[test]
fn bindgen_test_layout_linkedit_data_command() {
    assert_eq!(
        ::std::mem::size_of::<linkedit_data_command>(),
        16usize,
        concat!("Size of: ", stringify!(linkedit_data_command))
    );
    assert_eq!(
        ::std::mem::align_of::<linkedit_data_command>(),
        4usize,
        concat!("Alignment of ", stringify!(linkedit_data_command))
    );
    fn test_field_cmd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<linkedit_data_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(linkedit_data_command),
                "::",
                stringify!(cmd)
            )
        );
    }
    test_field_cmd();
    fn test_field_cmdsize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<linkedit_data_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmdsize) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(linkedit_data_command),
                "::",
                stringify!(cmdsize)
            )
        );
    }
    test_field_cmdsize();
    fn test_field_dataoff() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<linkedit_data_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dataoff) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(linkedit_data_command),
                "::",
                stringify!(dataoff)
            )
        );
    }
    test_field_dataoff();
    fn test_field_datasize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<linkedit_data_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).datasize) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(linkedit_data_command),
                "::",
                stringify!(datasize)
            )
        );
    }
    test_field_datasize();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct encryption_info_command {
    pub cmd: u32,
    pub cmdsize: u32,
    pub cryptoff: u32,
    pub cryptsize: u32,
    pub cryptid: u32,
}
#[test]
fn bindgen_test_layout_encryption_info_command() {
    assert_eq!(
        ::std::mem::size_of::<encryption_info_command>(),
        20usize,
        concat!("Size of: ", stringify!(encryption_info_command))
    );
    assert_eq!(
        ::std::mem::align_of::<encryption_info_command>(),
        4usize,
        concat!("Alignment of ", stringify!(encryption_info_command))
    );
    fn test_field_cmd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<encryption_info_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(encryption_info_command),
                "::",
                stringify!(cmd)
            )
        );
    }
    test_field_cmd();
    fn test_field_cmdsize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<encryption_info_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmdsize) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(encryption_info_command),
                "::",
                stringify!(cmdsize)
            )
        );
    }
    test_field_cmdsize();
    fn test_field_cryptoff() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<encryption_info_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cryptoff) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(encryption_info_command),
                "::",
                stringify!(cryptoff)
            )
        );
    }
    test_field_cryptoff();
    fn test_field_cryptsize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<encryption_info_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cryptsize) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(encryption_info_command),
                "::",
                stringify!(cryptsize)
            )
        );
    }
    test_field_cryptsize();
    fn test_field_cryptid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<encryption_info_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cryptid) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(encryption_info_command),
                "::",
                stringify!(cryptid)
            )
        );
    }
    test_field_cryptid();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct encryption_info_command_64 {
    pub cmd: u32,
    pub cmdsize: u32,
    pub cryptoff: u32,
    pub cryptsize: u32,
    pub cryptid: u32,
    pub pad: u32,
}
#[test]
fn bindgen_test_layout_encryption_info_command_64() {
    assert_eq!(
        ::std::mem::size_of::<encryption_info_command_64>(),
        24usize,
        concat!("Size of: ", stringify!(encryption_info_command_64))
    );
    assert_eq!(
        ::std::mem::align_of::<encryption_info_command_64>(),
        4usize,
        concat!("Alignment of ", stringify!(encryption_info_command_64))
    );
    fn test_field_cmd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<encryption_info_command_64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(encryption_info_command_64),
                "::",
                stringify!(cmd)
            )
        );
    }
    test_field_cmd();
    fn test_field_cmdsize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<encryption_info_command_64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmdsize) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(encryption_info_command_64),
                "::",
                stringify!(cmdsize)
            )
        );
    }
    test_field_cmdsize();
    fn test_field_cryptoff() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<encryption_info_command_64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cryptoff) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(encryption_info_command_64),
                "::",
                stringify!(cryptoff)
            )
        );
    }
    test_field_cryptoff();
    fn test_field_cryptsize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<encryption_info_command_64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cryptsize) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(encryption_info_command_64),
                "::",
                stringify!(cryptsize)
            )
        );
    }
    test_field_cryptsize();
    fn test_field_cryptid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<encryption_info_command_64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cryptid) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(encryption_info_command_64),
                "::",
                stringify!(cryptid)
            )
        );
    }
    test_field_cryptid();
    fn test_field_pad() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<encryption_info_command_64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(encryption_info_command_64),
                "::",
                stringify!(pad)
            )
        );
    }
    test_field_pad();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct version_min_command {
    pub cmd: u32,
    pub cmdsize: u32,
    pub version: u32,
    pub sdk: u32,
}
#[test]
fn bindgen_test_layout_version_min_command() {
    assert_eq!(
        ::std::mem::size_of::<version_min_command>(),
        16usize,
        concat!("Size of: ", stringify!(version_min_command))
    );
    assert_eq!(
        ::std::mem::align_of::<version_min_command>(),
        4usize,
        concat!("Alignment of ", stringify!(version_min_command))
    );
    fn test_field_cmd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<version_min_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(version_min_command),
                "::",
                stringify!(cmd)
            )
        );
    }
    test_field_cmd();
    fn test_field_cmdsize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<version_min_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmdsize) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(version_min_command),
                "::",
                stringify!(cmdsize)
            )
        );
    }
    test_field_cmdsize();
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<version_min_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(version_min_command),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_sdk() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<version_min_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sdk) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(version_min_command),
                "::",
                stringify!(sdk)
            )
        );
    }
    test_field_sdk();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct build_version_command {
    pub cmd: u32,
    pub cmdsize: u32,
    pub platform: u32,
    pub minos: u32,
    pub sdk: u32,
    pub ntools: u32,
}
#[test]
fn bindgen_test_layout_build_version_command() {
    assert_eq!(
        ::std::mem::size_of::<build_version_command>(),
        24usize,
        concat!("Size of: ", stringify!(build_version_command))
    );
    assert_eq!(
        ::std::mem::align_of::<build_version_command>(),
        4usize,
        concat!("Alignment of ", stringify!(build_version_command))
    );
    fn test_field_cmd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<build_version_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(build_version_command),
                "::",
                stringify!(cmd)
            )
        );
    }
    test_field_cmd();
    fn test_field_cmdsize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<build_version_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmdsize) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(build_version_command),
                "::",
                stringify!(cmdsize)
            )
        );
    }
    test_field_cmdsize();
    fn test_field_platform() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<build_version_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).platform) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(build_version_command),
                "::",
                stringify!(platform)
            )
        );
    }
    test_field_platform();
    fn test_field_minos() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<build_version_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minos) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(build_version_command),
                "::",
                stringify!(minos)
            )
        );
    }
    test_field_minos();
    fn test_field_sdk() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<build_version_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sdk) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(build_version_command),
                "::",
                stringify!(sdk)
            )
        );
    }
    test_field_sdk();
    fn test_field_ntools() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<build_version_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ntools) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(build_version_command),
                "::",
                stringify!(ntools)
            )
        );
    }
    test_field_ntools();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct build_tool_version {
    pub tool: u32,
    pub version: u32,
}
#[test]
fn bindgen_test_layout_build_tool_version() {
    assert_eq!(
        ::std::mem::size_of::<build_tool_version>(),
        8usize,
        concat!("Size of: ", stringify!(build_tool_version))
    );
    assert_eq!(
        ::std::mem::align_of::<build_tool_version>(),
        4usize,
        concat!("Alignment of ", stringify!(build_tool_version))
    );
    fn test_field_tool() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<build_tool_version>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tool) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(build_tool_version),
                "::",
                stringify!(tool)
            )
        );
    }
    test_field_tool();
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<build_tool_version>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(build_tool_version),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dyld_info_command {
    pub cmd: u32,
    pub cmdsize: u32,
    pub rebase_off: u32,
    pub rebase_size: u32,
    pub bind_off: u32,
    pub bind_size: u32,
    pub weak_bind_off: u32,
    pub weak_bind_size: u32,
    pub lazy_bind_off: u32,
    pub lazy_bind_size: u32,
    pub export_off: u32,
    pub export_size: u32,
}
#[test]
fn bindgen_test_layout_dyld_info_command() {
    assert_eq!(
        ::std::mem::size_of::<dyld_info_command>(),
        48usize,
        concat!("Size of: ", stringify!(dyld_info_command))
    );
    assert_eq!(
        ::std::mem::align_of::<dyld_info_command>(),
        4usize,
        concat!("Alignment of ", stringify!(dyld_info_command))
    );
    fn test_field_cmd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dyld_info_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(dyld_info_command),
                "::",
                stringify!(cmd)
            )
        );
    }
    test_field_cmd();
    fn test_field_cmdsize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dyld_info_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmdsize) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(dyld_info_command),
                "::",
                stringify!(cmdsize)
            )
        );
    }
    test_field_cmdsize();
    fn test_field_rebase_off() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dyld_info_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rebase_off) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(dyld_info_command),
                "::",
                stringify!(rebase_off)
            )
        );
    }
    test_field_rebase_off();
    fn test_field_rebase_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dyld_info_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rebase_size) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(dyld_info_command),
                "::",
                stringify!(rebase_size)
            )
        );
    }
    test_field_rebase_size();
    fn test_field_bind_off() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dyld_info_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bind_off) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(dyld_info_command),
                "::",
                stringify!(bind_off)
            )
        );
    }
    test_field_bind_off();
    fn test_field_bind_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dyld_info_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bind_size) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(dyld_info_command),
                "::",
                stringify!(bind_size)
            )
        );
    }
    test_field_bind_size();
    fn test_field_weak_bind_off() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dyld_info_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).weak_bind_off) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(dyld_info_command),
                "::",
                stringify!(weak_bind_off)
            )
        );
    }
    test_field_weak_bind_off();
    fn test_field_weak_bind_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dyld_info_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).weak_bind_size) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(dyld_info_command),
                "::",
                stringify!(weak_bind_size)
            )
        );
    }
    test_field_weak_bind_size();
    fn test_field_lazy_bind_off() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dyld_info_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lazy_bind_off) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(dyld_info_command),
                "::",
                stringify!(lazy_bind_off)
            )
        );
    }
    test_field_lazy_bind_off();
    fn test_field_lazy_bind_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dyld_info_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lazy_bind_size) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(dyld_info_command),
                "::",
                stringify!(lazy_bind_size)
            )
        );
    }
    test_field_lazy_bind_size();
    fn test_field_export_off() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dyld_info_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).export_off) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(dyld_info_command),
                "::",
                stringify!(export_off)
            )
        );
    }
    test_field_export_off();
    fn test_field_export_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dyld_info_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).export_size) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(dyld_info_command),
                "::",
                stringify!(export_size)
            )
        );
    }
    test_field_export_size();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct linker_option_command {
    pub cmd: u32,
    pub cmdsize: u32,
    pub count: u32,
}
#[test]
fn bindgen_test_layout_linker_option_command() {
    assert_eq!(
        ::std::mem::size_of::<linker_option_command>(),
        12usize,
        concat!("Size of: ", stringify!(linker_option_command))
    );
    assert_eq!(
        ::std::mem::align_of::<linker_option_command>(),
        4usize,
        concat!("Alignment of ", stringify!(linker_option_command))
    );
    fn test_field_cmd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<linker_option_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(linker_option_command),
                "::",
                stringify!(cmd)
            )
        );
    }
    test_field_cmd();
    fn test_field_cmdsize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<linker_option_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmdsize) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(linker_option_command),
                "::",
                stringify!(cmdsize)
            )
        );
    }
    test_field_cmdsize();
    fn test_field_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<linker_option_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(linker_option_command),
                "::",
                stringify!(count)
            )
        );
    }
    test_field_count();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct symseg_command {
    pub cmd: u32,
    pub cmdsize: u32,
    pub offset: u32,
    pub size: u32,
}
#[test]
fn bindgen_test_layout_symseg_command() {
    assert_eq!(
        ::std::mem::size_of::<symseg_command>(),
        16usize,
        concat!("Size of: ", stringify!(symseg_command))
    );
    assert_eq!(
        ::std::mem::align_of::<symseg_command>(),
        4usize,
        concat!("Alignment of ", stringify!(symseg_command))
    );
    fn test_field_cmd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<symseg_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(symseg_command),
                "::",
                stringify!(cmd)
            )
        );
    }
    test_field_cmd();
    fn test_field_cmdsize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<symseg_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmdsize) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(symseg_command),
                "::",
                stringify!(cmdsize)
            )
        );
    }
    test_field_cmdsize();
    fn test_field_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<symseg_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(symseg_command),
                "::",
                stringify!(offset)
            )
        );
    }
    test_field_offset();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<symseg_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(symseg_command),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ident_command {
    pub cmd: u32,
    pub cmdsize: u32,
}
#[test]
fn bindgen_test_layout_ident_command() {
    assert_eq!(
        ::std::mem::size_of::<ident_command>(),
        8usize,
        concat!("Size of: ", stringify!(ident_command))
    );
    assert_eq!(
        ::std::mem::align_of::<ident_command>(),
        4usize,
        concat!("Alignment of ", stringify!(ident_command))
    );
    fn test_field_cmd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ident_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ident_command),
                "::",
                stringify!(cmd)
            )
        );
    }
    test_field_cmd();
    fn test_field_cmdsize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ident_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmdsize) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(ident_command),
                "::",
                stringify!(cmdsize)
            )
        );
    }
    test_field_cmdsize();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fvmfile_command {
    pub cmd: u32,
    pub cmdsize: u32,
    pub name: lc_str,
    pub header_addr: u32,
}
#[test]
fn bindgen_test_layout_fvmfile_command() {
    assert_eq!(
        ::std::mem::size_of::<fvmfile_command>(),
        16usize,
        concat!("Size of: ", stringify!(fvmfile_command))
    );
    assert_eq!(
        ::std::mem::align_of::<fvmfile_command>(),
        4usize,
        concat!("Alignment of ", stringify!(fvmfile_command))
    );
    fn test_field_cmd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fvmfile_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fvmfile_command),
                "::",
                stringify!(cmd)
            )
        );
    }
    test_field_cmd();
    fn test_field_cmdsize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fvmfile_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmdsize) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(fvmfile_command),
                "::",
                stringify!(cmdsize)
            )
        );
    }
    test_field_cmdsize();
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fvmfile_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fvmfile_command),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_header_addr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fvmfile_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).header_addr) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(fvmfile_command),
                "::",
                stringify!(header_addr)
            )
        );
    }
    test_field_header_addr();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct entry_point_command {
    pub cmd: u32,
    pub cmdsize: u32,
    pub entryoff: u64,
    pub stacksize: u64,
}
#[test]
fn bindgen_test_layout_entry_point_command() {
    assert_eq!(
        ::std::mem::size_of::<entry_point_command>(),
        24usize,
        concat!("Size of: ", stringify!(entry_point_command))
    );
    assert_eq!(
        ::std::mem::align_of::<entry_point_command>(),
        8usize,
        concat!("Alignment of ", stringify!(entry_point_command))
    );
    fn test_field_cmd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<entry_point_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(entry_point_command),
                "::",
                stringify!(cmd)
            )
        );
    }
    test_field_cmd();
    fn test_field_cmdsize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<entry_point_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmdsize) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(entry_point_command),
                "::",
                stringify!(cmdsize)
            )
        );
    }
    test_field_cmdsize();
    fn test_field_entryoff() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<entry_point_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).entryoff) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(entry_point_command),
                "::",
                stringify!(entryoff)
            )
        );
    }
    test_field_entryoff();
    fn test_field_stacksize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<entry_point_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stacksize) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(entry_point_command),
                "::",
                stringify!(stacksize)
            )
        );
    }
    test_field_stacksize();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct source_version_command {
    pub cmd: u32,
    pub cmdsize: u32,
    pub version: u64,
}
#[test]
fn bindgen_test_layout_source_version_command() {
    assert_eq!(
        ::std::mem::size_of::<source_version_command>(),
        16usize,
        concat!("Size of: ", stringify!(source_version_command))
    );
    assert_eq!(
        ::std::mem::align_of::<source_version_command>(),
        8usize,
        concat!("Alignment of ", stringify!(source_version_command))
    );
    fn test_field_cmd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<source_version_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(source_version_command),
                "::",
                stringify!(cmd)
            )
        );
    }
    test_field_cmd();
    fn test_field_cmdsize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<source_version_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmdsize) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(source_version_command),
                "::",
                stringify!(cmdsize)
            )
        );
    }
    test_field_cmdsize();
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<source_version_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(source_version_command),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct data_in_code_entry {
    pub offset: u32,
    pub length: u16,
    pub kind: u16,
}
#[test]
fn bindgen_test_layout_data_in_code_entry() {
    assert_eq!(
        ::std::mem::size_of::<data_in_code_entry>(),
        8usize,
        concat!("Size of: ", stringify!(data_in_code_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<data_in_code_entry>(),
        4usize,
        concat!("Alignment of ", stringify!(data_in_code_entry))
    );
    fn test_field_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<data_in_code_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(data_in_code_entry),
                "::",
                stringify!(offset)
            )
        );
    }
    test_field_offset();
    fn test_field_length() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<data_in_code_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(data_in_code_entry),
                "::",
                stringify!(length)
            )
        );
    }
    test_field_length();
    fn test_field_kind() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<data_in_code_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).kind) as usize - ptr as usize
            },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(data_in_code_entry),
                "::",
                stringify!(kind)
            )
        );
    }
    test_field_kind();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tlv_descriptor {
    pub thunk: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut tlv_descriptor) -> *mut ::std::os::raw::c_void,
    >,
    pub key: ::std::os::raw::c_ulong,
    pub offset: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_tlv_descriptor() {
    assert_eq!(
        ::std::mem::size_of::<tlv_descriptor>(),
        24usize,
        concat!("Size of: ", stringify!(tlv_descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<tlv_descriptor>(),
        8usize,
        concat!("Alignment of ", stringify!(tlv_descriptor))
    );
    fn test_field_thunk() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tlv_descriptor>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).thunk) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(tlv_descriptor),
                "::",
                stringify!(thunk)
            )
        );
    }
    test_field_thunk();
    fn test_field_key() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tlv_descriptor>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(tlv_descriptor),
                "::",
                stringify!(key)
            )
        );
    }
    test_field_key();
    fn test_field_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tlv_descriptor>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(tlv_descriptor),
                "::",
                stringify!(offset)
            )
        );
    }
    test_field_offset();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct note_command {
    pub cmd: u32,
    pub cmdsize: u32,
    pub data_owner: [::std::os::raw::c_char; 16usize],
    pub offset: u64,
    pub size: u64,
}
#[test]
fn bindgen_test_layout_note_command() {
    assert_eq!(
        ::std::mem::size_of::<note_command>(),
        40usize,
        concat!("Size of: ", stringify!(note_command))
    );
    assert_eq!(
        ::std::mem::align_of::<note_command>(),
        8usize,
        concat!("Alignment of ", stringify!(note_command))
    );
    fn test_field_cmd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<note_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(note_command),
                "::",
                stringify!(cmd)
            )
        );
    }
    test_field_cmd();
    fn test_field_cmdsize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<note_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmdsize) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(note_command),
                "::",
                stringify!(cmdsize)
            )
        );
    }
    test_field_cmdsize();
    fn test_field_data_owner() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<note_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data_owner) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(note_command),
                "::",
                stringify!(data_owner)
            )
        );
    }
    test_field_data_owner();
    fn test_field_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<note_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(note_command),
                "::",
                stringify!(offset)
            )
        );
    }
    test_field_offset();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<note_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(note_command),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fileset_entry_command {
    pub cmd: u32,
    pub cmdsize: u32,
    pub vmaddr: u64,
    pub fileoff: u64,
    pub entry_id: lc_str,
    pub reserved: u32,
}
#[test]
fn bindgen_test_layout_fileset_entry_command() {
    assert_eq!(
        ::std::mem::size_of::<fileset_entry_command>(),
        32usize,
        concat!("Size of: ", stringify!(fileset_entry_command))
    );
    assert_eq!(
        ::std::mem::align_of::<fileset_entry_command>(),
        8usize,
        concat!("Alignment of ", stringify!(fileset_entry_command))
    );
    fn test_field_cmd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fileset_entry_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fileset_entry_command),
                "::",
                stringify!(cmd)
            )
        );
    }
    test_field_cmd();
    fn test_field_cmdsize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fileset_entry_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmdsize) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(fileset_entry_command),
                "::",
                stringify!(cmdsize)
            )
        );
    }
    test_field_cmdsize();
    fn test_field_vmaddr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fileset_entry_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vmaddr) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fileset_entry_command),
                "::",
                stringify!(vmaddr)
            )
        );
    }
    test_field_vmaddr();
    fn test_field_fileoff() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fileset_entry_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fileoff) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(fileset_entry_command),
                "::",
                stringify!(fileoff)
            )
        );
    }
    test_field_fileoff();
    fn test_field_entry_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fileset_entry_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).entry_id) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(fileset_entry_command),
                "::",
                stringify!(entry_id)
            )
        );
    }
    test_field_entry_id();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fileset_entry_command>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(fileset_entry_command),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
extern "C" {
    pub fn getsectdata(
        segname: *const ::std::os::raw::c_char,
        sectname: *const ::std::os::raw::c_char,
        size: *mut ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getsectdatafromFramework(
        FrameworkName: *const ::std::os::raw::c_char,
        segname: *const ::std::os::raw::c_char,
        sectname: *const ::std::os::raw::c_char,
        size: *mut ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn get_end() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn get_etext() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn get_edata() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn getsectbyname(
        segname: *const ::std::os::raw::c_char,
        sectname: *const ::std::os::raw::c_char,
    ) -> *const section_64;
}
extern "C" {
    pub fn getsectiondata(
        mhp: *const mach_header_64,
        segname: *const ::std::os::raw::c_char,
        sectname: *const ::std::os::raw::c_char,
        size: *mut ::std::os::raw::c_ulong,
    ) -> *mut u8;
}
extern "C" {
    pub fn getsegbyname(segname: *const ::std::os::raw::c_char) -> *const segment_command_64;
}
extern "C" {
    pub fn getsegmentdata(
        mhp: *const mach_header_64,
        segname: *const ::std::os::raw::c_char,
        size: *mut ::std::os::raw::c_ulong,
    ) -> *mut u8;
}
extern "C" {
    pub fn getsectdatafromheader(
        mhp: *const mach_header,
        segname: *const ::std::os::raw::c_char,
        sectname: *const ::std::os::raw::c_char,
        size: *mut u32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getsectbynamefromheader(
        mhp: *const mach_header,
        segname: *const ::std::os::raw::c_char,
        sectname: *const ::std::os::raw::c_char,
    ) -> *const section;
}
extern "C" {
    pub fn getsectbynamefromheaderwithswap(
        mhp: *mut mach_header,
        segname: *const ::std::os::raw::c_char,
        sectname: *const ::std::os::raw::c_char,
        fSwap: ::std::os::raw::c_int,
    ) -> *const section;
}
extern "C" {
    pub fn getsectdatafromheader_64(
        mhp: *const mach_header_64,
        segname: *const ::std::os::raw::c_char,
        sectname: *const ::std::os::raw::c_char,
        size: *mut u64,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getsectbynamefromheader_64(
        mhp: *const mach_header_64,
        segname: *const ::std::os::raw::c_char,
        sectname: *const ::std::os::raw::c_char,
    ) -> *const section_64;
}
extern "C" {
    pub fn getsectbynamefromheaderwithswap_64(
        mhp: *mut mach_header_64,
        segname: *const ::std::os::raw::c_char,
        sectname: *const ::std::os::raw::c_char,
        fSwap: ::std::os::raw::c_int,
    ) -> *const section;
}
pub type mrb_each_object_callback = ::std::option::Option<
    unsafe extern "C" fn(
        mrb: *mut mrb_state,
        obj: *mut RBasic,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn mrb_objspace_each_objects(
        mrb: *mut mrb_state,
        callback: mrb_each_object_callback,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn mrb_objspace_page_slot_size() -> size_t;
}
extern "C" {
    pub fn mrb_free_context(mrb: *mut mrb_state, c: *mut mrb_context);
}
pub const mrb_gc_state_MRB_GC_STATE_ROOT: mrb_gc_state = 0;
pub const mrb_gc_state_MRB_GC_STATE_MARK: mrb_gc_state = 1;
pub const mrb_gc_state_MRB_GC_STATE_SWEEP: mrb_gc_state = 2;
pub type mrb_gc_state = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug)]
pub struct mrb_heap_page {
    pub freelist: *mut RBasic,
    pub prev: *mut mrb_heap_page,
    pub next: *mut mrb_heap_page,
    pub free_next: *mut mrb_heap_page,
    pub free_prev: *mut mrb_heap_page,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub objects: __IncompleteArrayField<*mut ::std::os::raw::c_void>,
}
#[test]
fn bindgen_test_layout_mrb_heap_page() {
    assert_eq!(
        ::std::mem::size_of::<mrb_heap_page>(),
        48usize,
        concat!("Size of: ", stringify!(mrb_heap_page))
    );
    assert_eq!(
        ::std::mem::align_of::<mrb_heap_page>(),
        8usize,
        concat!("Alignment of ", stringify!(mrb_heap_page))
    );
    fn test_field_freelist() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_heap_page>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).freelist) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_heap_page),
                "::",
                stringify!(freelist)
            )
        );
    }
    test_field_freelist();
    fn test_field_prev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_heap_page>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_heap_page),
                "::",
                stringify!(prev)
            )
        );
    }
    test_field_prev();
    fn test_field_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_heap_page>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_heap_page),
                "::",
                stringify!(next)
            )
        );
    }
    test_field_next();
    fn test_field_free_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_heap_page>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).free_next) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_heap_page),
                "::",
                stringify!(free_next)
            )
        );
    }
    test_field_free_next();
    fn test_field_free_prev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_heap_page>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).free_prev) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_heap_page),
                "::",
                stringify!(free_prev)
            )
        );
    }
    test_field_free_prev();
    fn test_field_objects() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_heap_page>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).objects) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_heap_page),
                "::",
                stringify!(objects)
            )
        );
    }
    test_field_objects();
}
impl mrb_heap_page {
    #[inline]
    pub fn old(&self) -> mrb_bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_old(&mut self, val: mrb_bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(old: mrb_bool) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let old: u8 = unsafe { ::std::mem::transmute(old) };
            old as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mrb_gc {
    pub heaps: *mut mrb_heap_page,
    pub sweeps: *mut mrb_heap_page,
    pub free_heaps: *mut mrb_heap_page,
    pub live: size_t,
    pub arena: *mut *mut RBasic,
    pub arena_capa: ::std::os::raw::c_int,
    pub arena_idx: ::std::os::raw::c_int,
    pub state: mrb_gc_state,
    pub current_white_part: ::std::os::raw::c_int,
    pub gray_list: *mut RBasic,
    pub atomic_gray_list: *mut RBasic,
    pub live_after_mark: size_t,
    pub threshold: size_t,
    pub interval_ratio: ::std::os::raw::c_int,
    pub step_ratio: ::std::os::raw::c_int,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub majorgc_old_threshold: size_t,
}
#[test]
fn bindgen_test_layout_mrb_gc() {
    assert_eq!(
        ::std::mem::size_of::<mrb_gc>(),
        112usize,
        concat!("Size of: ", stringify!(mrb_gc))
    );
    assert_eq!(
        ::std::mem::align_of::<mrb_gc>(),
        8usize,
        concat!("Alignment of ", stringify!(mrb_gc))
    );
    fn test_field_heaps() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_gc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).heaps) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_gc),
                "::",
                stringify!(heaps)
            )
        );
    }
    test_field_heaps();
    fn test_field_sweeps() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_gc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sweeps) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_gc),
                "::",
                stringify!(sweeps)
            )
        );
    }
    test_field_sweeps();
    fn test_field_free_heaps() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_gc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).free_heaps) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_gc),
                "::",
                stringify!(free_heaps)
            )
        );
    }
    test_field_free_heaps();
    fn test_field_live() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_gc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).live) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_gc),
                "::",
                stringify!(live)
            )
        );
    }
    test_field_live();
    fn test_field_arena() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_gc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).arena) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_gc),
                "::",
                stringify!(arena)
            )
        );
    }
    test_field_arena();
    fn test_field_arena_capa() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_gc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).arena_capa) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_gc),
                "::",
                stringify!(arena_capa)
            )
        );
    }
    test_field_arena_capa();
    fn test_field_arena_idx() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_gc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).arena_idx) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_gc),
                "::",
                stringify!(arena_idx)
            )
        );
    }
    test_field_arena_idx();
    fn test_field_state() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_gc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_gc),
                "::",
                stringify!(state)
            )
        );
    }
    test_field_state();
    fn test_field_current_white_part() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_gc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).current_white_part) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_gc),
                "::",
                stringify!(current_white_part)
            )
        );
    }
    test_field_current_white_part();
    fn test_field_gray_list() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_gc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gray_list) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_gc),
                "::",
                stringify!(gray_list)
            )
        );
    }
    test_field_gray_list();
    fn test_field_atomic_gray_list() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_gc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).atomic_gray_list) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_gc),
                "::",
                stringify!(atomic_gray_list)
            )
        );
    }
    test_field_atomic_gray_list();
    fn test_field_live_after_mark() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_gc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).live_after_mark) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_gc),
                "::",
                stringify!(live_after_mark)
            )
        );
    }
    test_field_live_after_mark();
    fn test_field_threshold() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_gc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).threshold) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_gc),
                "::",
                stringify!(threshold)
            )
        );
    }
    test_field_threshold();
    fn test_field_interval_ratio() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_gc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).interval_ratio) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_gc),
                "::",
                stringify!(interval_ratio)
            )
        );
    }
    test_field_interval_ratio();
    fn test_field_step_ratio() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_gc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).step_ratio) as usize - ptr as usize
            },
            92usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_gc),
                "::",
                stringify!(step_ratio)
            )
        );
    }
    test_field_step_ratio();
    fn test_field_majorgc_old_threshold() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_gc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).majorgc_old_threshold) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_gc),
                "::",
                stringify!(majorgc_old_threshold)
            )
        );
    }
    test_field_majorgc_old_threshold();
}
impl mrb_gc {
    #[inline]
    pub fn iterating(&self) -> mrb_bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_iterating(&mut self, val: mrb_bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disabled(&self) -> mrb_bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_disabled(&mut self, val: mrb_bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn full(&self) -> mrb_bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_full(&mut self, val: mrb_bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn generational(&self) -> mrb_bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_generational(&mut self, val: mrb_bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_of_memory(&self) -> mrb_bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_out_of_memory(&mut self, val: mrb_bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        iterating: mrb_bool,
        disabled: mrb_bool,
        full: mrb_bool,
        generational: mrb_bool,
        out_of_memory: mrb_bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let iterating: u8 = unsafe { ::std::mem::transmute(iterating) };
            iterating as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let disabled: u8 = unsafe { ::std::mem::transmute(disabled) };
            disabled as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let full: u8 = unsafe { ::std::mem::transmute(full) };
            full as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let generational: u8 = unsafe { ::std::mem::transmute(generational) };
            generational as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let out_of_memory: u8 = unsafe { ::std::mem::transmute(out_of_memory) };
            out_of_memory as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn mrb_object_dead_p(mrb: *mut mrb_state, object: *mut RBasic) -> mrb_bool;
}
pub type float_t = f32;
pub type double_t = f64;
extern "C" {
    pub fn __math_errhandling() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __fpclassifyf(arg1: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __fpclassifyd(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __fpclassifyl(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acosf(arg1: f32) -> f32;
}
extern "C" {
    pub fn acos(arg1: f64) -> f64;
}
extern "C" {
    pub fn acosl(arg1: f64) -> f64;
}
extern "C" {
    pub fn asinf(arg1: f32) -> f32;
}
extern "C" {
    pub fn asin(arg1: f64) -> f64;
}
extern "C" {
    pub fn asinl(arg1: f64) -> f64;
}
extern "C" {
    pub fn atanf(arg1: f32) -> f32;
}
extern "C" {
    pub fn atan(arg1: f64) -> f64;
}
extern "C" {
    pub fn atanl(arg1: f64) -> f64;
}
extern "C" {
    pub fn atan2f(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn atan2(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn atan2l(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn cosf(arg1: f32) -> f32;
}
extern "C" {
    pub fn cos(arg1: f64) -> f64;
}
extern "C" {
    pub fn cosl(arg1: f64) -> f64;
}
extern "C" {
    pub fn sinf(arg1: f32) -> f32;
}
extern "C" {
    pub fn sin(arg1: f64) -> f64;
}
extern "C" {
    pub fn sinl(arg1: f64) -> f64;
}
extern "C" {
    pub fn tanf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tan(arg1: f64) -> f64;
}
extern "C" {
    pub fn tanl(arg1: f64) -> f64;
}
extern "C" {
    pub fn acoshf(arg1: f32) -> f32;
}
extern "C" {
    pub fn acosh(arg1: f64) -> f64;
}
extern "C" {
    pub fn acoshl(arg1: f64) -> f64;
}
extern "C" {
    pub fn asinhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn asinh(arg1: f64) -> f64;
}
extern "C" {
    pub fn asinhl(arg1: f64) -> f64;
}
extern "C" {
    pub fn atanhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn atanh(arg1: f64) -> f64;
}
extern "C" {
    pub fn atanhl(arg1: f64) -> f64;
}
extern "C" {
    pub fn coshf(arg1: f32) -> f32;
}
extern "C" {
    pub fn cosh(arg1: f64) -> f64;
}
extern "C" {
    pub fn coshl(arg1: f64) -> f64;
}
extern "C" {
    pub fn sinhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn sinh(arg1: f64) -> f64;
}
extern "C" {
    pub fn sinhl(arg1: f64) -> f64;
}
extern "C" {
    pub fn tanhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tanh(arg1: f64) -> f64;
}
extern "C" {
    pub fn tanhl(arg1: f64) -> f64;
}
extern "C" {
    pub fn expf(arg1: f32) -> f32;
}
extern "C" {
    pub fn exp(arg1: f64) -> f64;
}
extern "C" {
    pub fn expl(arg1: f64) -> f64;
}
extern "C" {
    pub fn exp2f(arg1: f32) -> f32;
}
extern "C" {
    pub fn exp2(arg1: f64) -> f64;
}
extern "C" {
    pub fn exp2l(arg1: f64) -> f64;
}
extern "C" {
    pub fn expm1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn expm1(arg1: f64) -> f64;
}
extern "C" {
    pub fn expm1l(arg1: f64) -> f64;
}
extern "C" {
    pub fn logf(arg1: f32) -> f32;
}
extern "C" {
    pub fn log(arg1: f64) -> f64;
}
extern "C" {
    pub fn logl(arg1: f64) -> f64;
}
extern "C" {
    pub fn log10f(arg1: f32) -> f32;
}
extern "C" {
    pub fn log10(arg1: f64) -> f64;
}
extern "C" {
    pub fn log10l(arg1: f64) -> f64;
}
extern "C" {
    pub fn log2f(arg1: f32) -> f32;
}
extern "C" {
    pub fn log2(arg1: f64) -> f64;
}
extern "C" {
    pub fn log2l(arg1: f64) -> f64;
}
extern "C" {
    pub fn log1pf(arg1: f32) -> f32;
}
extern "C" {
    pub fn log1p(arg1: f64) -> f64;
}
extern "C" {
    pub fn log1pl(arg1: f64) -> f64;
}
extern "C" {
    pub fn logbf(arg1: f32) -> f32;
}
extern "C" {
    pub fn logb(arg1: f64) -> f64;
}
extern "C" {
    pub fn logbl(arg1: f64) -> f64;
}
extern "C" {
    pub fn modff(arg1: f32, arg2: *mut f32) -> f32;
}
extern "C" {
    pub fn modf(arg1: f64, arg2: *mut f64) -> f64;
}
extern "C" {
    pub fn modfl(arg1: f64, arg2: *mut f64) -> f64;
}
extern "C" {
    pub fn ldexpf(arg1: f32, arg2: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn ldexp(arg1: f64, arg2: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ldexpl(arg1: f64, arg2: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn frexpf(arg1: f32, arg2: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn frexp(arg1: f64, arg2: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn frexpl(arg1: f64, arg2: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ilogbf(arg1: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ilogb(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ilogbl(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalbnf(arg1: f32, arg2: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn scalbn(arg1: f64, arg2: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn scalbnl(arg1: f64, arg2: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn scalblnf(arg1: f32, arg2: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn scalbln(arg1: f64, arg2: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn scalblnl(arg1: f64, arg2: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn fabsf(arg1: f32) -> f32;
}
extern "C" {
    pub fn fabs(arg1: f64) -> f64;
}
extern "C" {
    pub fn fabsl(arg1: f64) -> f64;
}
extern "C" {
    pub fn cbrtf(arg1: f32) -> f32;
}
extern "C" {
    pub fn cbrt(arg1: f64) -> f64;
}
extern "C" {
    pub fn cbrtl(arg1: f64) -> f64;
}
extern "C" {
    pub fn hypotf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn hypot(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn hypotl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn powf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn pow(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn powl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn sqrtf(arg1: f32) -> f32;
}
extern "C" {
    pub fn sqrt(arg1: f64) -> f64;
}
extern "C" {
    pub fn sqrtl(arg1: f64) -> f64;
}
extern "C" {
    pub fn erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfl(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfcl(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn tgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn ceilf(arg1: f32) -> f32;
}
extern "C" {
    pub fn ceil(arg1: f64) -> f64;
}
extern "C" {
    pub fn ceill(arg1: f64) -> f64;
}
extern "C" {
    pub fn floorf(arg1: f32) -> f32;
}
extern "C" {
    pub fn floor(arg1: f64) -> f64;
}
extern "C" {
    pub fn floorl(arg1: f64) -> f64;
}
extern "C" {
    pub fn nearbyintf(arg1: f32) -> f32;
}
extern "C" {
    pub fn nearbyint(arg1: f64) -> f64;
}
extern "C" {
    pub fn nearbyintl(arg1: f64) -> f64;
}
extern "C" {
    pub fn rintf(arg1: f32) -> f32;
}
extern "C" {
    pub fn rint(arg1: f64) -> f64;
}
extern "C" {
    pub fn rintl(arg1: f64) -> f64;
}
extern "C" {
    pub fn lrintf(arg1: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lrint(arg1: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lrintl(arg1: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn roundf(arg1: f32) -> f32;
}
extern "C" {
    pub fn round(arg1: f64) -> f64;
}
extern "C" {
    pub fn roundl(arg1: f64) -> f64;
}
extern "C" {
    pub fn lroundf(arg1: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lround(arg1: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lroundl(arg1: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrintf(arg1: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llrint(arg1: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llrintl(arg1: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llroundf(arg1: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llround(arg1: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llroundl(arg1: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn truncf(arg1: f32) -> f32;
}
extern "C" {
    pub fn trunc(arg1: f64) -> f64;
}
extern "C" {
    pub fn truncl(arg1: f64) -> f64;
}
extern "C" {
    pub fn fmodf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fmod(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmodl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn remainderf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn remainder(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn remainderl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn remquof(arg1: f32, arg2: f32, arg3: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn remquo(arg1: f64, arg2: f64, arg3: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn remquol(arg1: f64, arg2: f64, arg3: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn copysignf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn copysign(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn copysignl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn nanf(arg1: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn nan(arg1: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn nanl(arg1: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn nextafterf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn nextafter(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn nextafterl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn nexttoward(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn nexttowardf(arg1: f32, arg2: f64) -> f32;
}
extern "C" {
    pub fn nexttowardl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fdimf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fdim(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fdiml(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmaxf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fmax(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmaxl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fminf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fmin(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fminl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmaf(arg1: f32, arg2: f32, arg3: f32) -> f32;
}
extern "C" {
    pub fn fma(arg1: f64, arg2: f64, arg3: f64) -> f64;
}
extern "C" {
    pub fn fmal(arg1: f64, arg2: f64, arg3: f64) -> f64;
}
extern "C" {
    pub fn __exp10f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __exp10(arg1: f64) -> f64;
}
extern "C" {
    pub fn __cospif(arg1: f32) -> f32;
}
extern "C" {
    pub fn __cospi(arg1: f64) -> f64;
}
extern "C" {
    pub fn __sinpif(arg1: f32) -> f32;
}
extern "C" {
    pub fn __sinpi(arg1: f64) -> f64;
}
extern "C" {
    pub fn __tanpif(arg1: f32) -> f32;
}
extern "C" {
    pub fn __tanpi(arg1: f64) -> f64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __float2 {
    pub __sinval: f32,
    pub __cosval: f32,
}
#[test]
fn bindgen_test_layout___float2() {
    assert_eq!(
        ::std::mem::size_of::<__float2>(),
        8usize,
        concat!("Size of: ", stringify!(__float2))
    );
    assert_eq!(
        ::std::mem::align_of::<__float2>(),
        4usize,
        concat!("Alignment of ", stringify!(__float2))
    );
    fn test_field___sinval() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__float2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__sinval) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__float2),
                "::",
                stringify!(__sinval)
            )
        );
    }
    test_field___sinval();
    fn test_field___cosval() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__float2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__cosval) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__float2),
                "::",
                stringify!(__cosval)
            )
        );
    }
    test_field___cosval();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __double2 {
    pub __sinval: f64,
    pub __cosval: f64,
}
#[test]
fn bindgen_test_layout___double2() {
    assert_eq!(
        ::std::mem::size_of::<__double2>(),
        16usize,
        concat!("Size of: ", stringify!(__double2))
    );
    assert_eq!(
        ::std::mem::align_of::<__double2>(),
        8usize,
        concat!("Alignment of ", stringify!(__double2))
    );
    fn test_field___sinval() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__double2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__sinval) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__double2),
                "::",
                stringify!(__sinval)
            )
        );
    }
    test_field___sinval();
    fn test_field___cosval() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__double2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__cosval) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__double2),
                "::",
                stringify!(__cosval)
            )
        );
    }
    test_field___cosval();
}
extern "C" {
    pub fn __sincosf_stret(arg1: f32) -> __float2;
}
extern "C" {
    pub fn __sincos_stret(arg1: f64) -> __double2;
}
extern "C" {
    pub fn __sincospif_stret(arg1: f32) -> __float2;
}
extern "C" {
    pub fn __sincospi_stret(arg1: f64) -> __double2;
}
extern "C" {
    pub fn j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn scalb(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub static mut signgam: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct exception {
    pub type_: ::std::os::raw::c_int,
    pub name: *mut ::std::os::raw::c_char,
    pub arg1: f64,
    pub arg2: f64,
    pub retval: f64,
}
#[test]
fn bindgen_test_layout_exception() {
    assert_eq!(
        ::std::mem::size_of::<exception>(),
        40usize,
        concat!("Size of: ", stringify!(exception))
    );
    assert_eq!(
        ::std::mem::align_of::<exception>(),
        8usize,
        concat!("Alignment of ", stringify!(exception))
    );
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exception>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(exception),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exception>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(exception),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_arg1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exception>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).arg1) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(exception),
                "::",
                stringify!(arg1)
            )
        );
    }
    test_field_arg1();
    fn test_field_arg2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exception>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).arg2) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(exception),
                "::",
                stringify!(arg2)
            )
        );
    }
    test_field_arg2();
    fn test_field_retval() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<exception>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).retval) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(exception),
                "::",
                stringify!(retval)
            )
        );
    }
    test_field_retval();
}
#[doc = " MRuby C API entry point"]
pub type mrb_code = u8;
#[doc = " \\class mrb_aspec"]
#[doc = ""]
#[doc = " Specifies the number of arguments a function takes"]
#[doc = ""]
#[doc = " Example: `MRB_ARGS_REQ(2) | MRB_ARGS_OPT(1)` for a method that expects 2..3 arguments"]
pub type mrb_aspec = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mrb_irep {
    _unused: [u8; 0],
}
#[doc = " Function pointer type of custom allocator used in @see mrb_open_allocf."]
#[doc = ""]
#[doc = " The function pointing it must behave similarly as realloc except:"]
#[doc = " - If ptr is NULL it must allocate new space."]
#[doc = " - If s is NULL, ptr must be freed."]
#[doc = ""]
#[doc = " See @see mrb_default_allocf for the default implementation."]
pub type mrb_allocf = ::std::option::Option<
    unsafe extern "C" fn(
        mrb: *mut mrb_state,
        arg1: *mut ::std::os::raw::c_void,
        arg2: size_t,
        ud: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mrb_callinfo {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub cci: u8,
    pub mid: mrb_sym,
    pub proc_: *const RProc,
    pub stack: *mut mrb_value,
    pub pc: *const mrb_code,
    pub u: mrb_callinfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mrb_callinfo__bindgen_ty_1 {
    pub env: *mut REnv,
    pub target_class: *mut RClass,
}
#[test]
fn bindgen_test_layout_mrb_callinfo__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<mrb_callinfo__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(mrb_callinfo__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<mrb_callinfo__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(mrb_callinfo__bindgen_ty_1))
    );
    fn test_field_env() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_callinfo__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).env) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_callinfo__bindgen_ty_1),
                "::",
                stringify!(env)
            )
        );
    }
    test_field_env();
    fn test_field_target_class() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_callinfo__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).target_class) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_callinfo__bindgen_ty_1),
                "::",
                stringify!(target_class)
            )
        );
    }
    test_field_target_class();
}
#[test]
fn bindgen_test_layout_mrb_callinfo() {
    assert_eq!(
        ::std::mem::size_of::<mrb_callinfo>(),
        40usize,
        concat!("Size of: ", stringify!(mrb_callinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<mrb_callinfo>(),
        8usize,
        concat!("Alignment of ", stringify!(mrb_callinfo))
    );
    fn test_field_cci() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_callinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cci) as usize - ptr as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_callinfo),
                "::",
                stringify!(cci)
            )
        );
    }
    test_field_cci();
    fn test_field_mid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_callinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mid) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_callinfo),
                "::",
                stringify!(mid)
            )
        );
    }
    test_field_mid();
    fn test_field_proc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_callinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).proc_) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_callinfo),
                "::",
                stringify!(proc_)
            )
        );
    }
    test_field_proc();
    fn test_field_stack() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_callinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stack) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_callinfo),
                "::",
                stringify!(stack)
            )
        );
    }
    test_field_stack();
    fn test_field_pc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_callinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pc) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_callinfo),
                "::",
                stringify!(pc)
            )
        );
    }
    test_field_pc();
    fn test_field_u() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_callinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).u) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_callinfo),
                "::",
                stringify!(u)
            )
        );
    }
    test_field_u();
}
impl mrb_callinfo {
    #[inline]
    pub fn n(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_n(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn nk(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_nk(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(n: u8, nk: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let n: u8 = unsafe { ::std::mem::transmute(n) };
            n as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let nk: u8 = unsafe { ::std::mem::transmute(nk) };
            nk as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const mrb_fiber_state_MRB_FIBER_CREATED: mrb_fiber_state = 0;
pub const mrb_fiber_state_MRB_FIBER_RUNNING: mrb_fiber_state = 1;
pub const mrb_fiber_state_MRB_FIBER_RESUMED: mrb_fiber_state = 2;
pub const mrb_fiber_state_MRB_FIBER_SUSPENDED: mrb_fiber_state = 3;
pub const mrb_fiber_state_MRB_FIBER_TRANSFERRED: mrb_fiber_state = 4;
pub const mrb_fiber_state_MRB_FIBER_TERMINATED: mrb_fiber_state = 5;
pub type mrb_fiber_state = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mrb_context {
    pub prev: *mut mrb_context,
    pub stbase: *mut mrb_value,
    pub stend: *mut mrb_value,
    pub ci: *mut mrb_callinfo,
    pub cibase: *mut mrb_callinfo,
    pub ciend: *mut mrb_callinfo,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub fib: *mut RFiber,
}
#[test]
fn bindgen_test_layout_mrb_context() {
    assert_eq!(
        ::std::mem::size_of::<mrb_context>(),
        64usize,
        concat!("Size of: ", stringify!(mrb_context))
    );
    assert_eq!(
        ::std::mem::align_of::<mrb_context>(),
        8usize,
        concat!("Alignment of ", stringify!(mrb_context))
    );
    fn test_field_prev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_context>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_context),
                "::",
                stringify!(prev)
            )
        );
    }
    test_field_prev();
    fn test_field_stbase() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_context>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stbase) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_context),
                "::",
                stringify!(stbase)
            )
        );
    }
    test_field_stbase();
    fn test_field_stend() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_context>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stend) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_context),
                "::",
                stringify!(stend)
            )
        );
    }
    test_field_stend();
    fn test_field_ci() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_context>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ci) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_context),
                "::",
                stringify!(ci)
            )
        );
    }
    test_field_ci();
    fn test_field_cibase() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_context>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cibase) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_context),
                "::",
                stringify!(cibase)
            )
        );
    }
    test_field_cibase();
    fn test_field_ciend() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_context>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ciend) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_context),
                "::",
                stringify!(ciend)
            )
        );
    }
    test_field_ciend();
    fn test_field_fib() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_context>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fib) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_context),
                "::",
                stringify!(fib)
            )
        );
    }
    test_field_fib();
}
impl mrb_context {
    #[inline]
    pub fn status(&self) -> mrb_fiber_state {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_status(&mut self, val: mrb_fiber_state) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn vmexec(&self) -> mrb_bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_vmexec(&mut self, val: mrb_bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        status: mrb_fiber_state,
        vmexec: mrb_bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let status: u32 = unsafe { ::std::mem::transmute(status) };
            status as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let vmexec: u8 = unsafe { ::std::mem::transmute(vmexec) };
            vmexec as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Function pointer type for a function callable by mruby."]
#[doc = ""]
#[doc = " The arguments to the function are stored on the mrb_state. To get them see mrb_get_args"]
#[doc = ""]
#[doc = " @param mrb The mruby state"]
#[doc = " @param self The self object"]
#[doc = " @return [mrb_value] The function's return value"]
pub type mrb_func_t =
    ::std::option::Option<unsafe extern "C" fn(mrb: *mut mrb_state, self_: mrb_value) -> mrb_value>;
pub type mrb_method_t = usize;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mrb_cache_entry {
    pub c: *mut RClass,
    pub c0: *mut RClass,
    pub mid: mrb_sym,
    pub m: mrb_method_t,
}
#[test]
fn bindgen_test_layout_mrb_cache_entry() {
    assert_eq!(
        ::std::mem::size_of::<mrb_cache_entry>(),
        32usize,
        concat!("Size of: ", stringify!(mrb_cache_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<mrb_cache_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(mrb_cache_entry))
    );
    fn test_field_c() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_cache_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).c) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_cache_entry),
                "::",
                stringify!(c)
            )
        );
    }
    test_field_c();
    fn test_field_c0() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_cache_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).c0) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_cache_entry),
                "::",
                stringify!(c0)
            )
        );
    }
    test_field_c0();
    fn test_field_mid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_cache_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mid) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_cache_entry),
                "::",
                stringify!(mid)
            )
        );
    }
    test_field_mid();
    fn test_field_m() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_cache_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_cache_entry),
                "::",
                stringify!(m)
            )
        );
    }
    test_field_m();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mrb_jmpbuf {
    _unused: [u8; 0],
}
pub type mrb_atexit_func = ::std::option::Option<unsafe extern "C" fn(arg1: *mut mrb_state)>;
#[doc = " Uncommon memory management stuffs."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mrb_state {
    pub jmp: *mut mrb_jmpbuf,
    pub allocf: mrb_allocf,
    pub allocf_ud: *mut ::std::os::raw::c_void,
    pub c: *mut mrb_context,
    pub root_c: *mut mrb_context,
    pub globals: *mut iv_tbl,
    pub exc: *mut RObject,
    pub top_self: *mut RObject,
    pub object_class: *mut RClass,
    pub class_class: *mut RClass,
    pub module_class: *mut RClass,
    pub proc_class: *mut RClass,
    pub string_class: *mut RClass,
    pub array_class: *mut RClass,
    pub hash_class: *mut RClass,
    pub range_class: *mut RClass,
    pub float_class: *mut RClass,
    pub integer_class: *mut RClass,
    pub true_class: *mut RClass,
    pub false_class: *mut RClass,
    pub nil_class: *mut RClass,
    pub symbol_class: *mut RClass,
    pub kernel_module: *mut RClass,
    pub gc: mrb_gc,
    pub cache: [mrb_cache_entry; 256usize],
    pub symidx: mrb_sym,
    pub symtbl: *mut *const ::std::os::raw::c_char,
    pub symlink: *mut u8,
    pub symflags: *mut u8,
    pub symhash: [mrb_sym; 256usize],
    pub symcapa: size_t,
    pub symbuf: [::std::os::raw::c_char; 8usize],
    pub eException_class: *mut RClass,
    pub eStandardError_class: *mut RClass,
    pub nomem_err: *mut RObject,
    pub stack_err: *mut RObject,
    pub ud: *mut ::std::os::raw::c_void,
    pub atexit_stack: *mut mrb_atexit_func,
    pub atexit_stack_len: u16,
}
#[test]
fn bindgen_test_layout_mrb_state() {
    assert_eq!(
        ::std::mem::size_of::<mrb_state>(),
        9616usize,
        concat!("Size of: ", stringify!(mrb_state))
    );
    assert_eq!(
        ::std::mem::align_of::<mrb_state>(),
        8usize,
        concat!("Alignment of ", stringify!(mrb_state))
    );
    fn test_field_jmp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).jmp) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(jmp)
            )
        );
    }
    test_field_jmp();
    fn test_field_allocf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).allocf) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(allocf)
            )
        );
    }
    test_field_allocf();
    fn test_field_allocf_ud() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).allocf_ud) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(allocf_ud)
            )
        );
    }
    test_field_allocf_ud();
    fn test_field_c() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).c) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(c)
            )
        );
    }
    test_field_c();
    fn test_field_root_c() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).root_c) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(root_c)
            )
        );
    }
    test_field_root_c();
    fn test_field_globals() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).globals) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(globals)
            )
        );
    }
    test_field_globals();
    fn test_field_exc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).exc) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(exc)
            )
        );
    }
    test_field_exc();
    fn test_field_top_self() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).top_self) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(top_self)
            )
        );
    }
    test_field_top_self();
    fn test_field_object_class() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).object_class) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(object_class)
            )
        );
    }
    test_field_object_class();
    fn test_field_class_class() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).class_class) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(class_class)
            )
        );
    }
    test_field_class_class();
    fn test_field_module_class() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).module_class) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(module_class)
            )
        );
    }
    test_field_module_class();
    fn test_field_proc_class() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).proc_class) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(proc_class)
            )
        );
    }
    test_field_proc_class();
    fn test_field_string_class() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).string_class) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(string_class)
            )
        );
    }
    test_field_string_class();
    fn test_field_array_class() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).array_class) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(array_class)
            )
        );
    }
    test_field_array_class();
    fn test_field_hash_class() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hash_class) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(hash_class)
            )
        );
    }
    test_field_hash_class();
    fn test_field_range_class() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).range_class) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(range_class)
            )
        );
    }
    test_field_range_class();
    fn test_field_float_class() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).float_class) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(float_class)
            )
        );
    }
    test_field_float_class();
    fn test_field_integer_class() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).integer_class) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(integer_class)
            )
        );
    }
    test_field_integer_class();
    fn test_field_true_class() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).true_class) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(true_class)
            )
        );
    }
    test_field_true_class();
    fn test_field_false_class() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).false_class) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(false_class)
            )
        );
    }
    test_field_false_class();
    fn test_field_nil_class() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nil_class) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(nil_class)
            )
        );
    }
    test_field_nil_class();
    fn test_field_symbol_class() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).symbol_class) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(symbol_class)
            )
        );
    }
    test_field_symbol_class();
    fn test_field_kernel_module() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).kernel_module) as usize - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(kernel_module)
            )
        );
    }
    test_field_kernel_module();
    fn test_field_gc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gc) as usize - ptr as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(gc)
            )
        );
    }
    test_field_gc();
    fn test_field_cache() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cache) as usize - ptr as usize
            },
            296usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(cache)
            )
        );
    }
    test_field_cache();
    fn test_field_symidx() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).symidx) as usize - ptr as usize
            },
            8488usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(symidx)
            )
        );
    }
    test_field_symidx();
    fn test_field_symtbl() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).symtbl) as usize - ptr as usize
            },
            8496usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(symtbl)
            )
        );
    }
    test_field_symtbl();
    fn test_field_symlink() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).symlink) as usize - ptr as usize
            },
            8504usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(symlink)
            )
        );
    }
    test_field_symlink();
    fn test_field_symflags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).symflags) as usize - ptr as usize
            },
            8512usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(symflags)
            )
        );
    }
    test_field_symflags();
    fn test_field_symhash() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).symhash) as usize - ptr as usize
            },
            8520usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(symhash)
            )
        );
    }
    test_field_symhash();
    fn test_field_symcapa() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).symcapa) as usize - ptr as usize
            },
            9544usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(symcapa)
            )
        );
    }
    test_field_symcapa();
    fn test_field_symbuf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).symbuf) as usize - ptr as usize
            },
            9552usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(symbuf)
            )
        );
    }
    test_field_symbuf();
    fn test_field_eException_class() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).eException_class) as usize - ptr as usize
            },
            9560usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(eException_class)
            )
        );
    }
    test_field_eException_class();
    fn test_field_eStandardError_class() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).eStandardError_class) as usize - ptr as usize
            },
            9568usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(eStandardError_class)
            )
        );
    }
    test_field_eStandardError_class();
    fn test_field_nomem_err() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nomem_err) as usize - ptr as usize
            },
            9576usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(nomem_err)
            )
        );
    }
    test_field_nomem_err();
    fn test_field_stack_err() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stack_err) as usize - ptr as usize
            },
            9584usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(stack_err)
            )
        );
    }
    test_field_stack_err();
    fn test_field_ud() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ud) as usize - ptr as usize
            },
            9592usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(ud)
            )
        );
    }
    test_field_ud();
    fn test_field_atexit_stack() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).atexit_stack) as usize - ptr as usize
            },
            9600usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(atexit_stack)
            )
        );
    }
    test_field_atexit_stack();
    fn test_field_atexit_stack_len() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).atexit_stack_len) as usize - ptr as usize
            },
            9608usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(atexit_stack_len)
            )
        );
    }
    test_field_atexit_stack_len();
}
extern "C" {
    #[doc = " Defines a new class."]
    #[doc = ""]
    #[doc = " If you're creating a gem it may look something like this:"]
    #[doc = ""]
    #[doc = "      !!!c"]
    #[doc = "      void mrb_example_gem_init(mrb_state* mrb) {"]
    #[doc = "          struct RClass *example_class;"]
    #[doc = "          example_class = mrb_define_class(mrb, \"Example_Class\", mrb->object_class);"]
    #[doc = "      }"]
    #[doc = ""]
    #[doc = "      void mrb_example_gem_final(mrb_state* mrb) {"]
    #[doc = "          //free(TheAnimals);"]
    #[doc = "      }"]
    #[doc = ""]
    #[doc = " @param mrb The current mruby state."]
    #[doc = " @param name The name of the defined class."]
    #[doc = " @param super The new class parent."]
    #[doc = " @return [struct RClass *] Reference to the newly defined class."]
    #[doc = " @see mrb_define_class_under"]
    pub fn mrb_define_class(
        mrb: *mut mrb_state,
        name: *const ::std::os::raw::c_char,
        super_: *mut RClass,
    ) -> *mut RClass;
}
extern "C" {
    pub fn mrb_define_class_id(
        mrb: *mut mrb_state,
        name: mrb_sym,
        super_: *mut RClass,
    ) -> *mut RClass;
}
extern "C" {
    #[doc = " Defines a new module."]
    #[doc = ""]
    #[doc = " @param mrb The current mruby state."]
    #[doc = " @param name The name of the module."]
    #[doc = " @return [struct RClass *] Reference to the newly defined module."]
    pub fn mrb_define_module(
        mrb: *mut mrb_state,
        name: *const ::std::os::raw::c_char,
    ) -> *mut RClass;
}
extern "C" {
    pub fn mrb_define_module_id(mrb: *mut mrb_state, name: mrb_sym) -> *mut RClass;
}
extern "C" {
    pub fn mrb_singleton_class(mrb: *mut mrb_state, val: mrb_value) -> mrb_value;
}
extern "C" {
    pub fn mrb_singleton_class_ptr(mrb: *mut mrb_state, val: mrb_value) -> *mut RClass;
}
extern "C" {
    #[doc = " Include a module in another class or module."]
    #[doc = " Equivalent to:"]
    #[doc = ""]
    #[doc = "   module B"]
    #[doc = "     include A"]
    #[doc = "   end"]
    #[doc = " @param mrb The current mruby state."]
    #[doc = " @param cla A reference to module or a class."]
    #[doc = " @param included A reference to the module to be included."]
    pub fn mrb_include_module(mrb: *mut mrb_state, cla: *mut RClass, included: *mut RClass);
}
extern "C" {
    #[doc = " Prepends a module in another class or module."]
    #[doc = ""]
    #[doc = " Equivalent to:"]
    #[doc = "  module B"]
    #[doc = "    prepend A"]
    #[doc = "  end"]
    #[doc = " @param mrb The current mruby state."]
    #[doc = " @param cla A reference to module or a class."]
    #[doc = " @param prepended A reference to the module to be prepended."]
    pub fn mrb_prepend_module(mrb: *mut mrb_state, cla: *mut RClass, prepended: *mut RClass);
}
extern "C" {
    #[doc = " Defines a global function in ruby."]
    #[doc = ""]
    #[doc = " If you're creating a gem it may look something like this"]
    #[doc = ""]
    #[doc = " Example:"]
    #[doc = ""]
    #[doc = "     mrb_value example_method(mrb_state* mrb, mrb_value self)"]
    #[doc = "     {"]
    #[doc = "          puts(\"Executing example command!\");"]
    #[doc = "          return self;"]
    #[doc = "     }"]
    #[doc = ""]
    #[doc = "     void mrb_example_gem_init(mrb_state* mrb)"]
    #[doc = "     {"]
    #[doc = "           mrb_define_method(mrb, mrb->kernel_module, \"example_method\", example_method, MRB_ARGS_NONE());"]
    #[doc = "     }"]
    #[doc = ""]
    #[doc = " @param mrb The MRuby state reference."]
    #[doc = " @param cla The class pointer where the method will be defined."]
    #[doc = " @param name The name of the method being defined."]
    #[doc = " @param func The function pointer to the method definition."]
    #[doc = " @param aspec The method parameters declaration."]
    pub fn mrb_define_method(
        mrb: *mut mrb_state,
        cla: *mut RClass,
        name: *const ::std::os::raw::c_char,
        func: mrb_func_t,
        aspec: mrb_aspec,
    );
}
extern "C" {
    pub fn mrb_define_method_id(
        mrb: *mut mrb_state,
        c: *mut RClass,
        mid: mrb_sym,
        func: mrb_func_t,
        aspec: mrb_aspec,
    );
}
extern "C" {
    #[doc = " Defines a class method."]
    #[doc = ""]
    #[doc = " Example:"]
    #[doc = ""]
    #[doc = "     # Ruby style"]
    #[doc = "     class Foo"]
    #[doc = "       def Foo.bar"]
    #[doc = "       end"]
    #[doc = "     end"]
    #[doc = "     // C style"]
    #[doc = "     mrb_value bar_method(mrb_state* mrb, mrb_value self){"]
    #[doc = "       return mrb_nil_value();"]
    #[doc = "     }"]
    #[doc = "     void mrb_example_gem_init(mrb_state* mrb){"]
    #[doc = "       struct RClass *foo;"]
    #[doc = "       foo = mrb_define_class(mrb, \"Foo\", mrb->object_class);"]
    #[doc = "       mrb_define_class_method(mrb, foo, \"bar\", bar_method, MRB_ARGS_NONE());"]
    #[doc = "     }"]
    #[doc = " @param mrb The MRuby state reference."]
    #[doc = " @param cla The class where the class method will be defined."]
    #[doc = " @param name The name of the class method being defined."]
    #[doc = " @param fun The function pointer to the class method definition."]
    #[doc = " @param aspec The method parameters declaration."]
    pub fn mrb_define_class_method(
        mrb: *mut mrb_state,
        cla: *mut RClass,
        name: *const ::std::os::raw::c_char,
        fun: mrb_func_t,
        aspec: mrb_aspec,
    );
}
extern "C" {
    pub fn mrb_define_class_method_id(
        mrb: *mut mrb_state,
        cla: *mut RClass,
        name: mrb_sym,
        fun: mrb_func_t,
        aspec: mrb_aspec,
    );
}
extern "C" {
    #[doc = " Defines a singleton method"]
    #[doc = ""]
    #[doc = " @see mrb_define_class_method"]
    pub fn mrb_define_singleton_method(
        mrb: *mut mrb_state,
        cla: *mut RObject,
        name: *const ::std::os::raw::c_char,
        fun: mrb_func_t,
        aspec: mrb_aspec,
    );
}
extern "C" {
    pub fn mrb_define_singleton_method_id(
        mrb: *mut mrb_state,
        cla: *mut RObject,
        name: mrb_sym,
        fun: mrb_func_t,
        aspec: mrb_aspec,
    );
}
extern "C" {
    #[doc = "  Defines a module function."]
    #[doc = ""]
    #[doc = " Example:"]
    #[doc = ""]
    #[doc = "        # Ruby style"]
    #[doc = "        module Foo"]
    #[doc = "          def Foo.bar"]
    #[doc = "          end"]
    #[doc = "        end"]
    #[doc = "        // C style"]
    #[doc = "        mrb_value bar_method(mrb_state* mrb, mrb_value self){"]
    #[doc = "          return mrb_nil_value();"]
    #[doc = "        }"]
    #[doc = "        void mrb_example_gem_init(mrb_state* mrb){"]
    #[doc = "          struct RClass *foo;"]
    #[doc = "          foo = mrb_define_module(mrb, \"Foo\");"]
    #[doc = "          mrb_define_module_function(mrb, foo, \"bar\", bar_method, MRB_ARGS_NONE());"]
    #[doc = "        }"]
    #[doc = "  @param mrb The MRuby state reference."]
    #[doc = "  @param cla The module where the module function will be defined."]
    #[doc = "  @param name The name of the module function being defined."]
    #[doc = "  @param fun The function pointer to the module function definition."]
    #[doc = "  @param aspec The method parameters declaration."]
    pub fn mrb_define_module_function(
        mrb: *mut mrb_state,
        cla: *mut RClass,
        name: *const ::std::os::raw::c_char,
        fun: mrb_func_t,
        aspec: mrb_aspec,
    );
}
extern "C" {
    pub fn mrb_define_module_function_id(
        mrb: *mut mrb_state,
        cla: *mut RClass,
        name: mrb_sym,
        fun: mrb_func_t,
        aspec: mrb_aspec,
    );
}
extern "C" {
    #[doc = "  Defines a constant."]
    #[doc = ""]
    #[doc = " Example:"]
    #[doc = ""]
    #[doc = "          # Ruby style"]
    #[doc = "          class ExampleClass"]
    #[doc = "            AGE = 22"]
    #[doc = "          end"]
    #[doc = "          // C style"]
    #[doc = "          #include <stdio.h>"]
    #[doc = "          #include <mruby.h>"]
    #[doc = ""]
    #[doc = "          void"]
    #[doc = "          mrb_example_gem_init(mrb_state* mrb){"]
    #[doc = "            mrb_define_const(mrb, mrb->kernel_module, \"AGE\", mrb_fixnum_value(22));"]
    #[doc = "          }"]
    #[doc = ""]
    #[doc = "          mrb_value"]
    #[doc = "          mrb_example_gem_final(mrb_state* mrb){"]
    #[doc = "          }"]
    #[doc = "  @param mrb The MRuby state reference."]
    #[doc = "  @param cla A class or module the constant is defined in."]
    #[doc = "  @param name The name of the constant being defined."]
    #[doc = "  @param val The value for the constant."]
    pub fn mrb_define_const(
        mrb: *mut mrb_state,
        cla: *mut RClass,
        name: *const ::std::os::raw::c_char,
        val: mrb_value,
    );
}
extern "C" {
    pub fn mrb_define_const_id(
        mrb: *mut mrb_state,
        cla: *mut RClass,
        name: mrb_sym,
        val: mrb_value,
    );
}
extern "C" {
    #[doc = " Undefines a method."]
    #[doc = ""]
    #[doc = " Example:"]
    #[doc = ""]
    #[doc = "     # Ruby style"]
    #[doc = ""]
    #[doc = "     class ExampleClassA"]
    #[doc = "       def example_method"]
    #[doc = "         \"example\""]
    #[doc = "       end"]
    #[doc = "     end"]
    #[doc = "     ExampleClassA.new.example_method # => example"]
    #[doc = ""]
    #[doc = "     class ExampleClassB < ExampleClassA"]
    #[doc = "       undef_method :example_method"]
    #[doc = "     end"]
    #[doc = ""]
    #[doc = "     ExampleClassB.new.example_method # => undefined method 'example_method' for ExampleClassB (NoMethodError)"]
    #[doc = ""]
    #[doc = "     // C style"]
    #[doc = "     #include <stdio.h>"]
    #[doc = "     #include <mruby.h>"]
    #[doc = ""]
    #[doc = "     mrb_value"]
    #[doc = "     mrb_example_method(mrb_state *mrb){"]
    #[doc = "       return mrb_str_new_lit(mrb, \"example\");"]
    #[doc = "     }"]
    #[doc = ""]
    #[doc = "     void"]
    #[doc = "     mrb_example_gem_init(mrb_state* mrb){"]
    #[doc = "       struct RClass *example_class_a;"]
    #[doc = "       struct RClass *example_class_b;"]
    #[doc = "       struct RClass *example_class_c;"]
    #[doc = ""]
    #[doc = "       example_class_a = mrb_define_class(mrb, \"ExampleClassA\", mrb->object_class);"]
    #[doc = "       mrb_define_method(mrb, example_class_a, \"example_method\", mrb_example_method, MRB_ARGS_NONE());"]
    #[doc = "       example_class_b = mrb_define_class(mrb, \"ExampleClassB\", example_class_a);"]
    #[doc = "       example_class_c = mrb_define_class(mrb, \"ExampleClassC\", example_class_b);"]
    #[doc = "       mrb_undef_method(mrb, example_class_c, \"example_method\");"]
    #[doc = "     }"]
    #[doc = ""]
    #[doc = "     mrb_example_gem_final(mrb_state* mrb){"]
    #[doc = "     }"]
    #[doc = " @param mrb The mruby state reference."]
    #[doc = " @param cla The class the method will be undefined from."]
    #[doc = " @param name The name of the method to be undefined."]
    pub fn mrb_undef_method(
        mrb: *mut mrb_state,
        cla: *mut RClass,
        name: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn mrb_undef_method_id(arg1: *mut mrb_state, arg2: *mut RClass, arg3: mrb_sym);
}
extern "C" {
    #[doc = " Undefine a class method."]
    #[doc = " Example:"]
    #[doc = ""]
    #[doc = "      # Ruby style"]
    #[doc = "      class ExampleClass"]
    #[doc = "        def self.example_method"]
    #[doc = "          \"example\""]
    #[doc = "        end"]
    #[doc = "      end"]
    #[doc = ""]
    #[doc = "     ExampleClass.example_method"]
    #[doc = ""]
    #[doc = "     // C style"]
    #[doc = "     #include <stdio.h>"]
    #[doc = "     #include <mruby.h>"]
    #[doc = ""]
    #[doc = "     mrb_value"]
    #[doc = "     mrb_example_method(mrb_state *mrb){"]
    #[doc = "       return mrb_str_new_lit(mrb, \"example\");"]
    #[doc = "     }"]
    #[doc = ""]
    #[doc = "     void"]
    #[doc = "     mrb_example_gem_init(mrb_state* mrb){"]
    #[doc = "       struct RClass *example_class;"]
    #[doc = "       example_class = mrb_define_class(mrb, \"ExampleClass\", mrb->object_class);"]
    #[doc = "       mrb_define_class_method(mrb, example_class, \"example_method\", mrb_example_method, MRB_ARGS_NONE());"]
    #[doc = "       mrb_undef_class_method(mrb, example_class, \"example_method\");"]
    #[doc = "      }"]
    #[doc = ""]
    #[doc = "      void"]
    #[doc = "      mrb_example_gem_final(mrb_state* mrb){"]
    #[doc = "      }"]
    #[doc = " @param mrb The mruby state reference."]
    #[doc = " @param cls A class the class method will be undefined from."]
    #[doc = " @param name The name of the class method to be undefined."]
    pub fn mrb_undef_class_method(
        mrb: *mut mrb_state,
        cls: *mut RClass,
        name: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn mrb_undef_class_method_id(mrb: *mut mrb_state, cls: *mut RClass, name: mrb_sym);
}
extern "C" {
    #[doc = " Initialize a new object instance of c class."]
    #[doc = ""]
    #[doc = " Example:"]
    #[doc = ""]
    #[doc = "     # Ruby style"]
    #[doc = "     class ExampleClass"]
    #[doc = "     end"]
    #[doc = ""]
    #[doc = "     p ExampleClass # => #<ExampleClass:0x9958588>"]
    #[doc = "     // C style"]
    #[doc = "     #include <stdio.h>"]
    #[doc = "     #include <mruby.h>"]
    #[doc = ""]
    #[doc = "     void"]
    #[doc = "     mrb_example_gem_init(mrb_state* mrb) {"]
    #[doc = "       struct RClass *example_class;"]
    #[doc = "       mrb_value obj;"]
    #[doc = "       example_class = mrb_define_class(mrb, \"ExampleClass\", mrb->object_class); # => class ExampleClass; end"]
    #[doc = "       obj = mrb_obj_new(mrb, example_class, 0, NULL); # => ExampleClass.new"]
    #[doc = "       mrb_p(mrb, obj); // => Kernel#p"]
    #[doc = "      }"]
    #[doc = " @param mrb The current mruby state."]
    #[doc = " @param c Reference to the class of the new object."]
    #[doc = " @param argc Number of arguments in argv"]
    #[doc = " @param argv Array of mrb_value to initialize the object"]
    #[doc = " @return [mrb_value] The newly initialized object"]
    pub fn mrb_obj_new(
        mrb: *mut mrb_state,
        c: *mut RClass,
        argc: mrb_int,
        argv: *const mrb_value,
    ) -> mrb_value;
}
extern "C" {
    #[doc = " Creates a new instance of Class, Class."]
    #[doc = ""]
    #[doc = " Example:"]
    #[doc = ""]
    #[doc = "      void"]
    #[doc = "      mrb_example_gem_init(mrb_state* mrb) {"]
    #[doc = "        struct RClass *example_class;"]
    #[doc = ""]
    #[doc = "        mrb_value obj;"]
    #[doc = "        example_class = mrb_class_new(mrb, mrb->object_class);"]
    #[doc = "        obj = mrb_obj_new(mrb, example_class, 0, NULL); // => #<#<Class:0x9a945b8>:0x9a94588>"]
    #[doc = "        mrb_p(mrb, obj); // => Kernel#p"]
    #[doc = "       }"]
    #[doc = ""]
    #[doc = " @param mrb The current mruby state."]
    #[doc = " @param super The super class or parent."]
    #[doc = " @return [struct RClass *] Reference to the new class."]
    pub fn mrb_class_new(mrb: *mut mrb_state, super_: *mut RClass) -> *mut RClass;
}
extern "C" {
    #[doc = " Creates a new module, Module."]
    #[doc = ""]
    #[doc = " Example:"]
    #[doc = "      void"]
    #[doc = "      mrb_example_gem_init(mrb_state* mrb) {"]
    #[doc = "        struct RClass *example_module;"]
    #[doc = ""]
    #[doc = "        example_module = mrb_module_new(mrb);"]
    #[doc = "      }"]
    #[doc = ""]
    #[doc = " @param mrb The current mruby state."]
    #[doc = " @return [struct RClass *] Reference to the new module."]
    pub fn mrb_module_new(mrb: *mut mrb_state) -> *mut RClass;
}
extern "C" {
    #[doc = " Returns an mrb_bool. True if class was defined, and false if the class was not defined."]
    #[doc = ""]
    #[doc = " Example:"]
    #[doc = "     void"]
    #[doc = "     mrb_example_gem_init(mrb_state* mrb) {"]
    #[doc = "       struct RClass *example_class;"]
    #[doc = "       mrb_bool cd;"]
    #[doc = ""]
    #[doc = "       example_class = mrb_define_class(mrb, \"ExampleClass\", mrb->object_class);"]
    #[doc = "       cd = mrb_class_defined(mrb, \"ExampleClass\");"]
    #[doc = ""]
    #[doc = "       // If mrb_class_defined returns 1 then puts \"True\""]
    #[doc = "       // If mrb_class_defined returns 0 then puts \"False\""]
    #[doc = "       if (cd == 1){"]
    #[doc = "         puts(\"True\");"]
    #[doc = "       }"]
    #[doc = "       else {"]
    #[doc = "         puts(\"False\");"]
    #[doc = "       }"]
    #[doc = "      }"]
    #[doc = ""]
    #[doc = " @param mrb The current mruby state."]
    #[doc = " @param name A string representing the name of the class."]
    #[doc = " @return [mrb_bool] A boolean value."]
    pub fn mrb_class_defined(mrb: *mut mrb_state, name: *const ::std::os::raw::c_char) -> mrb_bool;
}
extern "C" {
    pub fn mrb_class_defined_id(mrb: *mut mrb_state, name: mrb_sym) -> mrb_bool;
}
extern "C" {
    #[doc = " Gets a class."]
    #[doc = " @param mrb The current mruby state."]
    #[doc = " @param name The name of the class."]
    #[doc = " @return [struct RClass *] A reference to the class."]
    pub fn mrb_class_get(mrb: *mut mrb_state, name: *const ::std::os::raw::c_char) -> *mut RClass;
}
extern "C" {
    pub fn mrb_class_get_id(mrb: *mut mrb_state, name: mrb_sym) -> *mut RClass;
}
extern "C" {
    #[doc = " Gets a exception class."]
    #[doc = " @param mrb The current mruby state."]
    #[doc = " @param name The name of the class."]
    #[doc = " @return [struct RClass *] A reference to the class."]
    pub fn mrb_exc_get_id(mrb: *mut mrb_state, name: mrb_sym) -> *mut RClass;
}
extern "C" {
    #[doc = " Returns an mrb_bool. True if inner class was defined, and false if the inner class was not defined."]
    #[doc = ""]
    #[doc = " Example:"]
    #[doc = "     void"]
    #[doc = "     mrb_example_gem_init(mrb_state* mrb) {"]
    #[doc = "       struct RClass *example_outer, *example_inner;"]
    #[doc = "       mrb_bool cd;"]
    #[doc = ""]
    #[doc = "       example_outer = mrb_define_module(mrb, \"ExampleOuter\");"]
    #[doc = ""]
    #[doc = "       example_inner = mrb_define_class_under(mrb, example_outer, \"ExampleInner\", mrb->object_class);"]
    #[doc = "       cd = mrb_class_defined_under(mrb, example_outer, \"ExampleInner\");"]
    #[doc = ""]
    #[doc = "       // If mrb_class_defined_under returns 1 then puts \"True\""]
    #[doc = "       // If mrb_class_defined_under returns 0 then puts \"False\""]
    #[doc = "       if (cd == 1){"]
    #[doc = "         puts(\"True\");"]
    #[doc = "       }"]
    #[doc = "       else {"]
    #[doc = "         puts(\"False\");"]
    #[doc = "       }"]
    #[doc = "      }"]
    #[doc = ""]
    #[doc = " @param mrb The current mruby state."]
    #[doc = " @param outer The name of the outer class."]
    #[doc = " @param name A string representing the name of the inner class."]
    #[doc = " @return [mrb_bool] A boolean value."]
    pub fn mrb_class_defined_under(
        mrb: *mut mrb_state,
        outer: *mut RClass,
        name: *const ::std::os::raw::c_char,
    ) -> mrb_bool;
}
extern "C" {
    pub fn mrb_class_defined_under_id(
        mrb: *mut mrb_state,
        outer: *mut RClass,
        name: mrb_sym,
    ) -> mrb_bool;
}
extern "C" {
    #[doc = " Gets a child class."]
    #[doc = " @param mrb The current mruby state."]
    #[doc = " @param outer The name of the parent class."]
    #[doc = " @param name The name of the class."]
    #[doc = " @return [struct RClass *] A reference to the class."]
    pub fn mrb_class_get_under(
        mrb: *mut mrb_state,
        outer: *mut RClass,
        name: *const ::std::os::raw::c_char,
    ) -> *mut RClass;
}
extern "C" {
    pub fn mrb_class_get_under_id(
        mrb: *mut mrb_state,
        outer: *mut RClass,
        name: mrb_sym,
    ) -> *mut RClass;
}
extern "C" {
    #[doc = " Gets a module."]
    #[doc = " @param mrb The current mruby state."]
    #[doc = " @param name The name of the module."]
    #[doc = " @return [struct RClass *] A reference to the module."]
    pub fn mrb_module_get(mrb: *mut mrb_state, name: *const ::std::os::raw::c_char) -> *mut RClass;
}
extern "C" {
    pub fn mrb_module_get_id(mrb: *mut mrb_state, name: mrb_sym) -> *mut RClass;
}
extern "C" {
    #[doc = " Gets a module defined under another module."]
    #[doc = " @param mrb The current mruby state."]
    #[doc = " @param outer The name of the outer module."]
    #[doc = " @param name The name of the module."]
    #[doc = " @return [struct RClass *] A reference to the module."]
    pub fn mrb_module_get_under(
        mrb: *mut mrb_state,
        outer: *mut RClass,
        name: *const ::std::os::raw::c_char,
    ) -> *mut RClass;
}
extern "C" {
    pub fn mrb_module_get_under_id(
        mrb: *mut mrb_state,
        outer: *mut RClass,
        name: mrb_sym,
    ) -> *mut RClass;
}
extern "C" {
    pub fn mrb_notimplement(arg1: *mut mrb_state);
}
extern "C" {
    pub fn mrb_notimplement_m(arg1: *mut mrb_state, arg2: mrb_value) -> mrb_value;
}
extern "C" {
    #[doc = " Duplicate an object."]
    #[doc = ""]
    #[doc = " Equivalent to:"]
    #[doc = "   Object#dup"]
    #[doc = " @param mrb The current mruby state."]
    #[doc = " @param obj Object to be duplicate."]
    #[doc = " @return [mrb_value] The newly duplicated object."]
    pub fn mrb_obj_dup(mrb: *mut mrb_state, obj: mrb_value) -> mrb_value;
}
extern "C" {
    #[doc = " Returns true if obj responds to the given method. If the method was defined for that"]
    #[doc = " class it returns true, it returns false otherwise."]
    #[doc = ""]
    #[doc = "      Example:"]
    #[doc = "      # Ruby style"]
    #[doc = "      class ExampleClass"]
    #[doc = "        def example_method"]
    #[doc = "        end"]
    #[doc = "      end"]
    #[doc = ""]
    #[doc = "      ExampleClass.new.respond_to?(:example_method) # => true"]
    #[doc = ""]
    #[doc = "      // C style"]
    #[doc = "      void"]
    #[doc = "      mrb_example_gem_init(mrb_state* mrb) {"]
    #[doc = "        struct RClass *example_class;"]
    #[doc = "        mrb_sym mid;"]
    #[doc = "        mrb_bool obj_resp;"]
    #[doc = ""]
    #[doc = "        example_class = mrb_define_class(mrb, \"ExampleClass\", mrb->object_class);"]
    #[doc = "        mrb_define_method(mrb, example_class, \"example_method\", exampleMethod, MRB_ARGS_NONE());"]
    #[doc = "        mid = mrb_intern_str(mrb, mrb_str_new_lit(mrb, \"example_method\" ));"]
    #[doc = "        obj_resp = mrb_obj_respond_to(mrb, example_class, mid); // => 1(true in Ruby world)"]
    #[doc = ""]
    #[doc = "        // If mrb_obj_respond_to returns 1 then puts \"True\""]
    #[doc = "        // If mrb_obj_respond_to returns 0 then puts \"False\""]
    #[doc = "        if (obj_resp == 1) {"]
    #[doc = "          puts(\"True\");"]
    #[doc = "        }"]
    #[doc = "        else if (obj_resp == 0) {"]
    #[doc = "          puts(\"False\");"]
    #[doc = "        }"]
    #[doc = "      }"]
    #[doc = ""]
    #[doc = " @param mrb The current mruby state."]
    #[doc = " @param c A reference to a class."]
    #[doc = " @param mid A symbol referencing a method id."]
    #[doc = " @return [mrb_bool] A boolean value."]
    pub fn mrb_obj_respond_to(mrb: *mut mrb_state, c: *mut RClass, mid: mrb_sym) -> mrb_bool;
}
extern "C" {
    #[doc = " Defines a new class under a given module"]
    #[doc = ""]
    #[doc = " @param mrb The current mruby state."]
    #[doc = " @param outer Reference to the module under which the new class will be defined"]
    #[doc = " @param name The name of the defined class"]
    #[doc = " @param super The new class parent"]
    #[doc = " @return [struct RClass *] Reference to the newly defined class"]
    #[doc = " @see mrb_define_class"]
    pub fn mrb_define_class_under(
        mrb: *mut mrb_state,
        outer: *mut RClass,
        name: *const ::std::os::raw::c_char,
        super_: *mut RClass,
    ) -> *mut RClass;
}
extern "C" {
    pub fn mrb_define_class_under_id(
        mrb: *mut mrb_state,
        outer: *mut RClass,
        name: mrb_sym,
        super_: *mut RClass,
    ) -> *mut RClass;
}
extern "C" {
    pub fn mrb_define_module_under(
        mrb: *mut mrb_state,
        outer: *mut RClass,
        name: *const ::std::os::raw::c_char,
    ) -> *mut RClass;
}
extern "C" {
    pub fn mrb_define_module_under_id(
        mrb: *mut mrb_state,
        outer: *mut RClass,
        name: mrb_sym,
    ) -> *mut RClass;
}
#[doc = " Format specifiers for {mrb_get_args} function"]
#[doc = ""]
#[doc = " Must be a C string composed of the following format specifiers:"]
#[doc = ""]
#[doc = " | char | Ruby type      | C types           | Notes                                              |"]
#[doc = " |:----:|----------------|-------------------|----------------------------------------------------|"]
#[doc = " | `o`  | {Object}       | {mrb_value}       | Could be used to retrieve any type of argument     |"]
#[doc = " | `C`  | {Class}/{Module} | {mrb_value}     | when `!` follows, the value may be `nil`           |"]
#[doc = " | `S`  | {String}       | {mrb_value}       | when `!` follows, the value may be `nil`           |"]
#[doc = " | `A`  | {Array}        | {mrb_value}       | when `!` follows, the value may be `nil`           |"]
#[doc = " | `H`  | {Hash}         | {mrb_value}       | when `!` follows, the value may be `nil`           |"]
#[doc = " | `s`  | {String}       | const char *, {mrb_int} | Receive two arguments; `s!` gives (`NULL`,`0`) for `nil` |"]
#[doc = " | `z`  | {String}       | const char *      | `NULL` terminated string; `z!` gives `NULL` for `nil` |"]
#[doc = " | `a`  | {Array}        | const {mrb_value} *, {mrb_int} | Receive two arguments; `a!` gives (`NULL`,`0`) for `nil` |"]
#[doc = " | `c`  | {Class}/{Module} | strcut RClass * | `c!` gives `NULL` for `nil`                        |"]
#[doc = " | `f`  | {Integer}/{Float} | {mrb_float}    |                                                    |"]
#[doc = " | `i`  | {Integer}/{Float} | {mrb_int}      |                                                    |"]
#[doc = " | `b`  | boolean        | {mrb_bool}        |                                                    |"]
#[doc = " | `n`  | {String}/{Symbol} | {mrb_sym}         |                                                    |"]
#[doc = " | `d`  | data           | void *, {mrb_data_type} const | 2nd argument will be used to check data type so it won't be modified; when `!` follows, the value may be `nil` |"]
#[doc = " | `I`  | inline struct  | void *, struct RClass | `I!` gives `NULL` for `nil`                    |"]
#[doc = " | `&`  | block          | {mrb_value}       | &! raises exception if no block given.             |"]
#[doc = " | `*`  | rest arguments | const {mrb_value} *, {mrb_int} | Receive the rest of arguments as an array; `*!` avoid copy of the stack.  |"]
#[doc = " | <code>\\|</code> | optional     |                   | After this spec following specs would be optional. |"]
#[doc = " | `?`  | optional given | {mrb_bool}        | `TRUE` if preceding argument is given. Used to check optional argument is given. |"]
#[doc = " | `:`  | keyword args   | {mrb_kwargs} const | Get keyword arguments. @see mrb_kwargs |"]
#[doc = ""]
#[doc = " @see mrb_get_args"]
#[doc = ""]
#[doc = " Immediately after format specifiers it can add format modifiers:"]
#[doc = ""]
#[doc = " | char | Notes                                                                                   |"]
#[doc = " |:----:|-----------------------------------------------------------------------------------------|"]
#[doc = " | `!`  | Switch to the alternate mode; The behaviour changes depending on the format specifier   |"]
#[doc = " | `+`  | Request a not frozen object; However, except nil value                                  |"]
pub type mrb_args_format = *const ::std::os::raw::c_char;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mrb_kwargs {
    pub num: u32,
    pub required: u32,
    pub table: *const mrb_sym,
    pub values: *mut mrb_value,
    pub rest: *mut mrb_value,
}
#[test]
fn bindgen_test_layout_mrb_kwargs() {
    assert_eq!(
        ::std::mem::size_of::<mrb_kwargs>(),
        32usize,
        concat!("Size of: ", stringify!(mrb_kwargs))
    );
    assert_eq!(
        ::std::mem::align_of::<mrb_kwargs>(),
        8usize,
        concat!("Alignment of ", stringify!(mrb_kwargs))
    );
    fn test_field_num() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_kwargs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).num) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_kwargs),
                "::",
                stringify!(num)
            )
        );
    }
    test_field_num();
    fn test_field_required() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_kwargs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).required) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_kwargs),
                "::",
                stringify!(required)
            )
        );
    }
    test_field_required();
    fn test_field_table() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_kwargs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).table) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_kwargs),
                "::",
                stringify!(table)
            )
        );
    }
    test_field_table();
    fn test_field_values() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_kwargs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).values) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_kwargs),
                "::",
                stringify!(values)
            )
        );
    }
    test_field_values();
    fn test_field_rest() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_kwargs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rest) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_kwargs),
                "::",
                stringify!(rest)
            )
        );
    }
    test_field_rest();
}
extern "C" {
    #[doc = " Retrieve arguments from mrb_state."]
    #[doc = ""]
    #[doc = " @param mrb The current MRuby state."]
    #[doc = " @param format is a list of format specifiers"]
    #[doc = " @param ... The passing variadic arguments must be a pointer of retrieving type."]
    #[doc = " @return the number of arguments retrieved."]
    #[doc = " @see mrb_args_format"]
    #[doc = " @see mrb_kwargs"]
    pub fn mrb_get_args(mrb: *mut mrb_state, format: mrb_args_format, ...) -> mrb_int;
}
extern "C" {
    #[doc = " Retrieve number of arguments from mrb_state."]
    #[doc = ""]
    #[doc = " Correctly handles *splat arguments."]
    pub fn mrb_get_argc(mrb: *mut mrb_state) -> mrb_int;
}
extern "C" {
    #[doc = " Retrieve an array of arguments from mrb_state."]
    #[doc = ""]
    #[doc = " Correctly handles *splat arguments."]
    pub fn mrb_get_argv(mrb: *mut mrb_state) -> *const mrb_value;
}
extern "C" {
    #[doc = " Retrieve the first and only argument from mrb_state."]
    #[doc = " Raises ArgumentError unless the number of arguments is exactly one."]
    #[doc = ""]
    #[doc = " Correctly handles *splat arguments."]
    pub fn mrb_get_arg1(mrb: *mut mrb_state) -> mrb_value;
}
extern "C" {
    #[doc = " Check if a block argument is given from mrb_state."]
    pub fn mrb_block_given_p(mrb: *mut mrb_state) -> mrb_bool;
}
extern "C" {
    #[doc = " Call existing ruby functions."]
    #[doc = ""]
    #[doc = " Example:"]
    #[doc = ""]
    #[doc = "      #include <stdio.h>"]
    #[doc = "      #include <mruby.h>"]
    #[doc = "      #include \"mruby/compile.h\""]
    #[doc = ""]
    #[doc = "      int"]
    #[doc = "      main()"]
    #[doc = "      {"]
    #[doc = "        mrb_int i = 99;"]
    #[doc = "        mrb_state *mrb = mrb_open();"]
    #[doc = ""]
    #[doc = "        if (!mrb) { }"]
    #[doc = "        FILE *fp = fopen(\"test.rb\",\"r\");"]
    #[doc = "        mrb_value obj = mrb_load_file(mrb,fp);"]
    #[doc = "        mrb_funcall(mrb, obj, \"method_name\", 1, mrb_fixnum_value(i));"]
    #[doc = "        mrb_funcall_id(mrb, obj, MRB_SYM(method_name), 1, mrb_fixnum_value(i));"]
    #[doc = "        fclose(fp);"]
    #[doc = "        mrb_close(mrb);"]
    #[doc = "      }"]
    #[doc = ""]
    #[doc = " @param mrb The current mruby state."]
    #[doc = " @param val A reference to an mruby value."]
    #[doc = " @param name The name of the method."]
    #[doc = " @param argc The number of arguments the method has."]
    #[doc = " @param ... Variadic values(not type safe!)."]
    #[doc = " @return [mrb_value] mruby function value."]
    pub fn mrb_funcall(
        mrb: *mut mrb_state,
        val: mrb_value,
        name: *const ::std::os::raw::c_char,
        argc: mrb_int,
        ...
    ) -> mrb_value;
}
extern "C" {
    pub fn mrb_funcall_id(
        mrb: *mut mrb_state,
        val: mrb_value,
        mid: mrb_sym,
        argc: mrb_int,
        ...
    ) -> mrb_value;
}
extern "C" {
    #[doc = " Call existing ruby functions. This is basically the type safe version of mrb_funcall."]
    #[doc = ""]
    #[doc = "      #include <stdio.h>"]
    #[doc = "      #include <mruby.h>"]
    #[doc = "      #include \"mruby/compile.h\""]
    #[doc = "      int"]
    #[doc = "      main()"]
    #[doc = "      {"]
    #[doc = "        mrb_state *mrb = mrb_open();"]
    #[doc = "        mrb_value obj = mrb_fixnum_value(1);"]
    #[doc = ""]
    #[doc = "        if (!mrb) { }"]
    #[doc = ""]
    #[doc = "        FILE *fp = fopen(\"test.rb\",\"r\");"]
    #[doc = "        mrb_value obj = mrb_load_file(mrb,fp);"]
    #[doc = "        mrb_funcall_argv(mrb, obj, MRB_SYM(method_name), 1, &obj); // Calling ruby function from test.rb."]
    #[doc = "        fclose(fp);"]
    #[doc = "        mrb_close(mrb);"]
    #[doc = "       }"]
    #[doc = " @param mrb The current mruby state."]
    #[doc = " @param val A reference to an mruby value."]
    #[doc = " @param name_sym The symbol representing the method."]
    #[doc = " @param argc The number of arguments the method has."]
    #[doc = " @param obj Pointer to the object."]
    #[doc = " @return [mrb_value] mrb_value mruby function value."]
    #[doc = " @see mrb_funcall"]
    pub fn mrb_funcall_argv(
        mrb: *mut mrb_state,
        val: mrb_value,
        name: mrb_sym,
        argc: mrb_int,
        argv: *const mrb_value,
    ) -> mrb_value;
}
extern "C" {
    #[doc = " Call existing ruby functions with a block."]
    pub fn mrb_funcall_with_block(
        mrb: *mut mrb_state,
        val: mrb_value,
        name: mrb_sym,
        argc: mrb_int,
        argv: *const mrb_value,
        block: mrb_value,
    ) -> mrb_value;
}
extern "C" {
    #[doc = " Create a symbol from C string. But usually it's better to use MRB_SYM,"]
    #[doc = " MRB_OPSYM, MRB_CVSYM, MRB_IVSYM, MRB_SYM_B, MRB_SYM_Q, MRB_SYM_E macros."]
    #[doc = ""]
    #[doc = " Example:"]
    #[doc = ""]
    #[doc = "     # Ruby style:"]
    #[doc = "     :pizza # => :pizza"]
    #[doc = ""]
    #[doc = "     // C style:"]
    #[doc = "     mrb_sym sym1 = mrb_intern_lit(mrb, \"pizza\"); //  => :pizza"]
    #[doc = "     mrb_sym sym2 = MRB_SYM(pizza);               //  => :pizza"]
    #[doc = "     mrb_sym sym3 = MRB_SYM_Q(pizza);             //  => :pizza?"]
    #[doc = ""]
    #[doc = " @param mrb The current mruby state."]
    #[doc = " @param str The string to be symbolized"]
    #[doc = " @return [mrb_sym] mrb_sym A symbol."]
    pub fn mrb_intern_cstr(mrb: *mut mrb_state, str_: *const ::std::os::raw::c_char) -> mrb_sym;
}
extern "C" {
    pub fn mrb_intern(
        arg1: *mut mrb_state,
        arg2: *const ::std::os::raw::c_char,
        arg3: size_t,
    ) -> mrb_sym;
}
extern "C" {
    pub fn mrb_intern_static(
        arg1: *mut mrb_state,
        arg2: *const ::std::os::raw::c_char,
        arg3: size_t,
    ) -> mrb_sym;
}
extern "C" {
    pub fn mrb_intern_str(arg1: *mut mrb_state, arg2: mrb_value) -> mrb_sym;
}
extern "C" {
    pub fn mrb_intern_check_cstr(
        arg1: *mut mrb_state,
        arg2: *const ::std::os::raw::c_char,
    ) -> mrb_sym;
}
extern "C" {
    pub fn mrb_intern_check(
        arg1: *mut mrb_state,
        arg2: *const ::std::os::raw::c_char,
        arg3: size_t,
    ) -> mrb_sym;
}
extern "C" {
    pub fn mrb_intern_check_str(arg1: *mut mrb_state, arg2: mrb_value) -> mrb_sym;
}
extern "C" {
    pub fn mrb_check_intern_cstr(
        arg1: *mut mrb_state,
        arg2: *const ::std::os::raw::c_char,
    ) -> mrb_value;
}
extern "C" {
    pub fn mrb_check_intern(
        arg1: *mut mrb_state,
        arg2: *const ::std::os::raw::c_char,
        arg3: size_t,
    ) -> mrb_value;
}
extern "C" {
    pub fn mrb_check_intern_str(arg1: *mut mrb_state, arg2: mrb_value) -> mrb_value;
}
extern "C" {
    pub fn mrb_sym_name(arg1: *mut mrb_state, arg2: mrb_sym) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn mrb_sym_name_len(
        arg1: *mut mrb_state,
        arg2: mrb_sym,
        arg3: *mut mrb_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn mrb_sym_dump(arg1: *mut mrb_state, arg2: mrb_sym) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn mrb_sym_str(arg1: *mut mrb_state, arg2: mrb_sym) -> mrb_value;
}
extern "C" {
    pub fn mrb_malloc(arg1: *mut mrb_state, arg2: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mrb_calloc(
        arg1: *mut mrb_state,
        arg2: size_t,
        arg3: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mrb_realloc(
        arg1: *mut mrb_state,
        arg2: *mut ::std::os::raw::c_void,
        arg3: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mrb_realloc_simple(
        arg1: *mut mrb_state,
        arg2: *mut ::std::os::raw::c_void,
        arg3: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mrb_malloc_simple(arg1: *mut mrb_state, arg2: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mrb_obj_alloc(arg1: *mut mrb_state, arg2: mrb_vtype, arg3: *mut RClass) -> *mut RBasic;
}
extern "C" {
    pub fn mrb_free(arg1: *mut mrb_state, arg2: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn mrb_str_new(
        mrb: *mut mrb_state,
        p: *const ::std::os::raw::c_char,
        len: size_t,
    ) -> mrb_value;
}
extern "C" {
    #[doc = " Turns a C string into a Ruby string value."]
    pub fn mrb_str_new_cstr(arg1: *mut mrb_state, arg2: *const ::std::os::raw::c_char)
        -> mrb_value;
}
extern "C" {
    pub fn mrb_str_new_static(
        mrb: *mut mrb_state,
        p: *const ::std::os::raw::c_char,
        len: size_t,
    ) -> mrb_value;
}
extern "C" {
    pub fn mrb_obj_freeze(arg1: *mut mrb_state, arg2: mrb_value) -> mrb_value;
}
extern "C" {
    #[doc = " Creates new mrb_state."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      Pointer to the newly created mrb_state."]
    pub fn mrb_open() -> *mut mrb_state;
}
extern "C" {
    #[doc = " Create new mrb_state with custom allocators."]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "      Reference to the allocation function."]
    #[doc = " @param ud"]
    #[doc = "      User data will be passed to custom allocator f."]
    #[doc = "      If user data isn't required just pass NULL."]
    #[doc = " @return"]
    #[doc = "      Pointer to the newly created mrb_state."]
    pub fn mrb_open_allocf(f: mrb_allocf, ud: *mut ::std::os::raw::c_void) -> *mut mrb_state;
}
extern "C" {
    #[doc = " Create new mrb_state with just the MRuby core"]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "      Reference to the allocation function."]
    #[doc = "      Use mrb_default_allocf for the default"]
    #[doc = " @param ud"]
    #[doc = "      User data will be passed to custom allocator f."]
    #[doc = "      If user data isn't required just pass NULL."]
    #[doc = " @return"]
    #[doc = "      Pointer to the newly created mrb_state."]
    pub fn mrb_open_core(f: mrb_allocf, ud: *mut ::std::os::raw::c_void) -> *mut mrb_state;
}
extern "C" {
    #[doc = " Closes and frees a mrb_state."]
    #[doc = ""]
    #[doc = " @param mrb"]
    #[doc = "      Pointer to the mrb_state to be closed."]
    pub fn mrb_close(mrb: *mut mrb_state);
}
extern "C" {
    #[doc = " The default allocation function."]
    #[doc = ""]
    #[doc = " @see mrb_allocf"]
    pub fn mrb_default_allocf(
        arg1: *mut mrb_state,
        arg2: *mut ::std::os::raw::c_void,
        arg3: size_t,
        arg4: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mrb_top_self(mrb: *mut mrb_state) -> mrb_value;
}
extern "C" {
    pub fn mrb_top_run(
        mrb: *mut mrb_state,
        proc_: *const RProc,
        self_: mrb_value,
        stack_keep: mrb_int,
    ) -> mrb_value;
}
extern "C" {
    pub fn mrb_vm_run(
        mrb: *mut mrb_state,
        proc_: *const RProc,
        self_: mrb_value,
        stack_keep: mrb_int,
    ) -> mrb_value;
}
extern "C" {
    pub fn mrb_vm_exec(
        mrb: *mut mrb_state,
        proc_: *const RProc,
        iseq: *const mrb_code,
    ) -> mrb_value;
}
extern "C" {
    pub fn mrb_p(arg1: *mut mrb_state, arg2: mrb_value);
}
extern "C" {
    pub fn mrb_obj_id(obj: mrb_value) -> mrb_int;
}
extern "C" {
    pub fn mrb_obj_to_sym(mrb: *mut mrb_state, name: mrb_value) -> mrb_sym;
}
extern "C" {
    pub fn mrb_obj_eq(mrb: *mut mrb_state, a: mrb_value, b: mrb_value) -> mrb_bool;
}
extern "C" {
    pub fn mrb_obj_equal(mrb: *mut mrb_state, a: mrb_value, b: mrb_value) -> mrb_bool;
}
extern "C" {
    pub fn mrb_equal(mrb: *mut mrb_state, obj1: mrb_value, obj2: mrb_value) -> mrb_bool;
}
extern "C" {
    pub fn mrb_ensure_float_type(mrb: *mut mrb_state, val: mrb_value) -> mrb_value;
}
extern "C" {
    pub fn mrb_inspect(mrb: *mut mrb_state, obj: mrb_value) -> mrb_value;
}
extern "C" {
    pub fn mrb_eql(mrb: *mut mrb_state, obj1: mrb_value, obj2: mrb_value) -> mrb_bool;
}
extern "C" {
    pub fn mrb_cmp(mrb: *mut mrb_state, obj1: mrb_value, obj2: mrb_value) -> mrb_int;
}
extern "C" {
    pub fn mrb_garbage_collect(arg1: *mut mrb_state);
}
extern "C" {
    pub fn mrb_full_gc(arg1: *mut mrb_state);
}
extern "C" {
    pub fn mrb_incremental_gc(arg1: *mut mrb_state);
}
extern "C" {
    pub fn mrb_gc_mark(arg1: *mut mrb_state, arg2: *mut RBasic);
}
extern "C" {
    pub fn mrb_field_write_barrier(arg1: *mut mrb_state, arg2: *mut RBasic, arg3: *mut RBasic);
}
extern "C" {
    pub fn mrb_write_barrier(arg1: *mut mrb_state, arg2: *mut RBasic);
}
extern "C" {
    pub fn mrb_type_convert(
        mrb: *mut mrb_state,
        val: mrb_value,
        type_: mrb_vtype,
        method: mrb_sym,
    ) -> mrb_value;
}
extern "C" {
    pub fn mrb_type_convert_check(
        mrb: *mut mrb_state,
        val: mrb_value,
        type_: mrb_vtype,
        method: mrb_sym,
    ) -> mrb_value;
}
extern "C" {
    pub fn mrb_any_to_s(mrb: *mut mrb_state, obj: mrb_value) -> mrb_value;
}
extern "C" {
    pub fn mrb_obj_classname(mrb: *mut mrb_state, obj: mrb_value) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn mrb_obj_class(mrb: *mut mrb_state, obj: mrb_value) -> *mut RClass;
}
extern "C" {
    pub fn mrb_class_path(mrb: *mut mrb_state, c: *mut RClass) -> mrb_value;
}
extern "C" {
    pub fn mrb_obj_is_kind_of(mrb: *mut mrb_state, obj: mrb_value, c: *mut RClass) -> mrb_bool;
}
extern "C" {
    pub fn mrb_obj_inspect(mrb: *mut mrb_state, self_: mrb_value) -> mrb_value;
}
extern "C" {
    pub fn mrb_obj_clone(mrb: *mut mrb_state, self_: mrb_value) -> mrb_value;
}
extern "C" {
    pub fn mrb_exc_new(
        mrb: *mut mrb_state,
        c: *mut RClass,
        ptr: *const ::std::os::raw::c_char,
        len: size_t,
    ) -> mrb_value;
}
extern "C" {
    pub fn mrb_exc_raise(mrb: *mut mrb_state, exc: mrb_value);
}
extern "C" {
    pub fn mrb_raise(mrb: *mut mrb_state, c: *mut RClass, msg: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn mrb_raisef(mrb: *mut mrb_state, c: *mut RClass, fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn mrb_name_error(
        mrb: *mut mrb_state,
        id: mrb_sym,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn mrb_frozen_error(mrb: *mut mrb_state, frozen_obj: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn mrb_argnum_error(
        mrb: *mut mrb_state,
        argc: mrb_int,
        min: ::std::os::raw::c_int,
        max: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn mrb_warn(mrb: *mut mrb_state, fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn mrb_bug(mrb: *mut mrb_state, fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn mrb_print_backtrace(mrb: *mut mrb_state);
}
extern "C" {
    pub fn mrb_print_error(mrb: *mut mrb_state);
}
extern "C" {
    pub fn mrb_vformat(
        mrb: *mut mrb_state,
        format: *const ::std::os::raw::c_char,
        ap: va_list,
    ) -> mrb_value;
}
extern "C" {
    pub fn mrb_yield(mrb: *mut mrb_state, b: mrb_value, arg: mrb_value) -> mrb_value;
}
extern "C" {
    pub fn mrb_yield_argv(
        mrb: *mut mrb_state,
        b: mrb_value,
        argc: mrb_int,
        argv: *const mrb_value,
    ) -> mrb_value;
}
extern "C" {
    pub fn mrb_yield_with_class(
        mrb: *mut mrb_state,
        b: mrb_value,
        argc: mrb_int,
        argv: *const mrb_value,
        self_: mrb_value,
        c: *mut RClass,
    ) -> mrb_value;
}
extern "C" {
    pub fn mrb_yield_cont(
        mrb: *mut mrb_state,
        b: mrb_value,
        self_: mrb_value,
        argc: mrb_int,
        argv: *const mrb_value,
    ) -> mrb_value;
}
extern "C" {
    pub fn mrb_gc_protect(mrb: *mut mrb_state, obj: mrb_value);
}
extern "C" {
    pub fn mrb_gc_register(mrb: *mut mrb_state, obj: mrb_value);
}
extern "C" {
    pub fn mrb_gc_unregister(mrb: *mut mrb_state, obj: mrb_value);
}
extern "C" {
    pub fn mrb_ensure_array_type(mrb: *mut mrb_state, self_: mrb_value) -> mrb_value;
}
extern "C" {
    pub fn mrb_check_array_type(mrb: *mut mrb_state, self_: mrb_value) -> mrb_value;
}
extern "C" {
    pub fn mrb_ensure_hash_type(mrb: *mut mrb_state, hash: mrb_value) -> mrb_value;
}
extern "C" {
    pub fn mrb_check_hash_type(mrb: *mut mrb_state, hash: mrb_value) -> mrb_value;
}
extern "C" {
    pub fn mrb_ensure_string_type(mrb: *mut mrb_state, str_: mrb_value) -> mrb_value;
}
extern "C" {
    pub fn mrb_check_string_type(mrb: *mut mrb_state, str_: mrb_value) -> mrb_value;
}
extern "C" {
    pub fn mrb_ensure_int_type(mrb: *mut mrb_state, val: mrb_value) -> mrb_value;
}
extern "C" {
    pub fn mrb_check_type(mrb: *mut mrb_state, x: mrb_value, t: mrb_vtype);
}
extern "C" {
    pub fn mrb_define_alias(
        mrb: *mut mrb_state,
        c: *mut RClass,
        a: *const ::std::os::raw::c_char,
        b: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn mrb_define_alias_id(mrb: *mut mrb_state, c: *mut RClass, a: mrb_sym, b: mrb_sym);
}
extern "C" {
    pub fn mrb_class_name(mrb: *mut mrb_state, klass: *mut RClass)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn mrb_define_global_const(
        mrb: *mut mrb_state,
        name: *const ::std::os::raw::c_char,
        val: mrb_value,
    );
}
extern "C" {
    pub fn mrb_attr_get(mrb: *mut mrb_state, obj: mrb_value, id: mrb_sym) -> mrb_value;
}
extern "C" {
    pub fn mrb_respond_to(mrb: *mut mrb_state, obj: mrb_value, mid: mrb_sym) -> mrb_bool;
}
extern "C" {
    pub fn mrb_obj_is_instance_of(mrb: *mut mrb_state, obj: mrb_value, c: *mut RClass) -> mrb_bool;
}
extern "C" {
    pub fn mrb_func_basic_p(
        mrb: *mut mrb_state,
        obj: mrb_value,
        mid: mrb_sym,
        func: mrb_func_t,
    ) -> mrb_bool;
}
extern "C" {
    #[doc = " Resume a Fiber"]
    #[doc = ""]
    #[doc = " Implemented in mruby-fiber"]
    pub fn mrb_fiber_resume(
        mrb: *mut mrb_state,
        fib: mrb_value,
        argc: mrb_int,
        argv: *const mrb_value,
    ) -> mrb_value;
}
extern "C" {
    #[doc = " Yield a Fiber"]
    #[doc = ""]
    #[doc = " Implemented in mruby-fiber"]
    pub fn mrb_fiber_yield(mrb: *mut mrb_state, argc: mrb_int, argv: *const mrb_value)
        -> mrb_value;
}
extern "C" {
    #[doc = " Check if a Fiber is alive"]
    #[doc = ""]
    #[doc = " Implemented in mruby-fiber"]
    pub fn mrb_fiber_alive_p(mrb: *mut mrb_state, fib: mrb_value) -> mrb_value;
}
extern "C" {
    pub fn mrb_stack_extend(arg1: *mut mrb_state, arg2: mrb_int);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mrb_pool {
    _unused: [u8; 0],
}
extern "C" {
    pub fn mrb_pool_open(arg1: *mut mrb_state) -> *mut mrb_pool;
}
extern "C" {
    pub fn mrb_pool_close(arg1: *mut mrb_pool);
}
extern "C" {
    pub fn mrb_pool_alloc(arg1: *mut mrb_pool, arg2: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mrb_pool_realloc(
        arg1: *mut mrb_pool,
        arg2: *mut ::std::os::raw::c_void,
        oldlen: size_t,
        newlen: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mrb_pool_can_realloc(
        arg1: *mut mrb_pool,
        arg2: *mut ::std::os::raw::c_void,
        arg3: size_t,
    ) -> mrb_bool;
}
extern "C" {
    pub fn mrb_alloca(mrb: *mut mrb_state, arg1: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mrb_state_atexit(mrb: *mut mrb_state, func: mrb_atexit_func);
}
extern "C" {
    pub fn mrb_show_version(mrb: *mut mrb_state);
}
extern "C" {
    pub fn mrb_show_copyright(mrb: *mut mrb_state);
}
extern "C" {
    pub fn mrb_format(mrb: *mut mrb_state, format: *const ::std::os::raw::c_char, ...)
        -> mrb_value;
}
#[doc = " Custom data type description."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mrb_data_type {
    #[doc = " data type name"]
    pub struct_name: *const ::std::os::raw::c_char,
    #[doc = " data type release function pointer"]
    pub dfree: ::std::option::Option<
        unsafe extern "C" fn(mrb: *mut mrb_state, arg1: *mut ::std::os::raw::c_void),
    >,
}
#[test]
fn bindgen_test_layout_mrb_data_type() {
    assert_eq!(
        ::std::mem::size_of::<mrb_data_type>(),
        16usize,
        concat!("Size of: ", stringify!(mrb_data_type))
    );
    assert_eq!(
        ::std::mem::align_of::<mrb_data_type>(),
        8usize,
        concat!("Alignment of ", stringify!(mrb_data_type))
    );
    fn test_field_struct_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_data_type>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).struct_name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_data_type),
                "::",
                stringify!(struct_name)
            )
        );
    }
    test_field_struct_name();
    fn test_field_dfree() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_data_type>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dfree) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_data_type),
                "::",
                stringify!(dfree)
            )
        );
    }
    test_field_dfree();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RData {
    pub c: *mut RClass,
    pub gcnext: *mut RBasic,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub iv: *mut iv_tbl,
    pub type_: *const mrb_data_type,
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_RData() {
    assert_eq!(
        ::std::mem::size_of::<RData>(),
        48usize,
        concat!("Size of: ", stringify!(RData))
    );
    assert_eq!(
        ::std::mem::align_of::<RData>(),
        8usize,
        concat!("Alignment of ", stringify!(RData))
    );
    fn test_field_c() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RData>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).c) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(RData), "::", stringify!(c))
        );
    }
    test_field_c();
    fn test_field_gcnext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RData>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gcnext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(RData),
                "::",
                stringify!(gcnext)
            )
        );
    }
    test_field_gcnext();
    fn test_field_iv() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RData>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).iv) as usize - ptr as usize
            },
            24usize,
            concat!("Offset of field: ", stringify!(RData), "::", stringify!(iv))
        );
    }
    test_field_iv();
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RData>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(RData),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RData>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(RData),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
}
impl RData {
    #[inline]
    pub fn tt(&self) -> mrb_vtype {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_tt(&mut self, val: mrb_vtype) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn color(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_color(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn flags(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 21u8) as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 21u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tt: mrb_vtype,
        color: u32,
        flags: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let tt: u32 = unsafe { ::std::mem::transmute(tt) };
            tt as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let color: u32 = unsafe { ::std::mem::transmute(color) };
            color as u64
        });
        __bindgen_bitfield_unit.set(11usize, 21u8, {
            let flags: u32 = unsafe { ::std::mem::transmute(flags) };
            flags as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn mrb_data_object_alloc(
        mrb: *mut mrb_state,
        klass: *mut RClass,
        datap: *mut ::std::os::raw::c_void,
        type_: *const mrb_data_type,
    ) -> *mut RData;
}
extern "C" {
    pub fn mrb_data_check_type(mrb: *mut mrb_state, arg1: mrb_value, arg2: *const mrb_data_type);
}
extern "C" {
    pub fn mrb_data_get_ptr(
        mrb: *mut mrb_state,
        arg1: mrb_value,
        arg2: *const mrb_data_type,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mrb_data_check_get_ptr(
        mrb: *mut mrb_state,
        arg1: mrb_value,
        arg2: *const mrb_data_type,
    ) -> *mut ::std::os::raw::c_void;
}
pub type __builtin_va_list = *mut ::std::os::raw::c_char;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iv_tbl {
    pub _address: u8,
}
pub type __uint128_t = u128;
