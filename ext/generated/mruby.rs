/* automatically generated by rust-bindgen 0.60.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub type va_list = __builtin_va_list;
pub type size_t = ::std::os::raw::c_ulong;
#[doc = " mruby Symbol."]
#[doc = " @class mrb_sym"]
#[doc = ""]
#[doc = " You can create an mrb_sym by simply using mrb_str_intern() or mrb_intern_cstr()"]
pub type mrb_sym = u32;
pub type mrb_bool = bool;
pub type mrb_int = i64;
extern "C" {
    pub fn mrb_int_read(
        p: *const ::std::os::raw::c_char,
        e: *const ::std::os::raw::c_char,
        endp: *mut *mut ::std::os::raw::c_char,
    ) -> mrb_int;
}
extern "C" {
    pub fn mrb_float_read(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
pub type mrb_float = f64;
pub const mrb_vtype_MRB_TT_FALSE: mrb_vtype = 0;
pub const mrb_vtype_MRB_TT_TRUE: mrb_vtype = 1;
pub const mrb_vtype_MRB_TT_SYMBOL: mrb_vtype = 2;
pub const mrb_vtype_MRB_TT_UNDEF: mrb_vtype = 3;
pub const mrb_vtype_MRB_TT_FREE: mrb_vtype = 4;
pub const mrb_vtype_MRB_TT_FLOAT: mrb_vtype = 5;
pub const mrb_vtype_MRB_TT_INTEGER: mrb_vtype = 6;
pub const mrb_vtype_MRB_TT_CPTR: mrb_vtype = 7;
pub const mrb_vtype_MRB_TT_OBJECT: mrb_vtype = 8;
pub const mrb_vtype_MRB_TT_CLASS: mrb_vtype = 9;
pub const mrb_vtype_MRB_TT_MODULE: mrb_vtype = 10;
pub const mrb_vtype_MRB_TT_ICLASS: mrb_vtype = 11;
pub const mrb_vtype_MRB_TT_SCLASS: mrb_vtype = 12;
pub const mrb_vtype_MRB_TT_PROC: mrb_vtype = 13;
pub const mrb_vtype_MRB_TT_ARRAY: mrb_vtype = 14;
pub const mrb_vtype_MRB_TT_HASH: mrb_vtype = 15;
pub const mrb_vtype_MRB_TT_STRING: mrb_vtype = 16;
pub const mrb_vtype_MRB_TT_RANGE: mrb_vtype = 17;
pub const mrb_vtype_MRB_TT_EXCEPTION: mrb_vtype = 18;
pub const mrb_vtype_MRB_TT_ENV: mrb_vtype = 19;
pub const mrb_vtype_MRB_TT_DATA: mrb_vtype = 20;
pub const mrb_vtype_MRB_TT_FIBER: mrb_vtype = 21;
pub const mrb_vtype_MRB_TT_STRUCT: mrb_vtype = 22;
pub const mrb_vtype_MRB_TT_ISTRUCT: mrb_vtype = 23;
pub const mrb_vtype_MRB_TT_BREAK: mrb_vtype = 24;
pub const mrb_vtype_MRB_TT_COMPLEX: mrb_vtype = 25;
pub const mrb_vtype_MRB_TT_RATIONAL: mrb_vtype = 26;
pub const mrb_vtype_MRB_TT_MAXDEFINE: mrb_vtype = 27;
pub type mrb_vtype = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RClass {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RProc {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct REnv {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RBasic {
    pub c: *mut RClass,
    pub gcnext: *mut RBasic,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub __bindgen_padding_0: u32,
}
#[test]
fn bindgen_test_layout_RBasic() {
    assert_eq!(
        ::std::mem::size_of::<RBasic>(),
        24usize,
        concat!("Size of: ", stringify!(RBasic))
    );
    assert_eq!(
        ::std::mem::align_of::<RBasic>(),
        8usize,
        concat!("Alignment of ", stringify!(RBasic))
    );
    fn test_field_c() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RBasic>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).c) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(RBasic), "::", stringify!(c))
        );
    }
    test_field_c();
    fn test_field_gcnext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RBasic>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gcnext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(RBasic),
                "::",
                stringify!(gcnext)
            )
        );
    }
    test_field_gcnext();
}
impl RBasic {
    #[inline]
    pub fn tt(&self) -> mrb_vtype {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_tt(&mut self, val: mrb_vtype) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn color(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_color(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn flags(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 21u8) as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 21u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tt: mrb_vtype,
        color: u32,
        flags: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let tt: u32 = unsafe { ::std::mem::transmute(tt) };
            tt as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let color: u32 = unsafe { ::std::mem::transmute(color) };
            color as u64
        });
        __bindgen_bitfield_unit.set(11usize, 21u8, {
            let flags: u32 = unsafe { ::std::mem::transmute(flags) };
            flags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RObject {
    pub c: *mut RClass,
    pub gcnext: *mut RBasic,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub iv: *mut iv_tbl,
}
#[test]
fn bindgen_test_layout_RObject() {
    assert_eq!(
        ::std::mem::size_of::<RObject>(),
        32usize,
        concat!("Size of: ", stringify!(RObject))
    );
    assert_eq!(
        ::std::mem::align_of::<RObject>(),
        8usize,
        concat!("Alignment of ", stringify!(RObject))
    );
    fn test_field_c() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RObject>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).c) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(RObject),
                "::",
                stringify!(c)
            )
        );
    }
    test_field_c();
    fn test_field_gcnext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RObject>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gcnext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(RObject),
                "::",
                stringify!(gcnext)
            )
        );
    }
    test_field_gcnext();
    fn test_field_iv() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RObject>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).iv) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(RObject),
                "::",
                stringify!(iv)
            )
        );
    }
    test_field_iv();
}
impl RObject {
    #[inline]
    pub fn tt(&self) -> mrb_vtype {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_tt(&mut self, val: mrb_vtype) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn color(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_color(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn flags(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 21u8) as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 21u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tt: mrb_vtype,
        color: u32,
        flags: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let tt: u32 = unsafe { ::std::mem::transmute(tt) };
            tt as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let color: u32 = unsafe { ::std::mem::transmute(color) };
            color as u64
        });
        __bindgen_bitfield_unit.set(11usize, 21u8, {
            let flags: u32 = unsafe { ::std::mem::transmute(flags) };
            flags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RFiber {
    pub c: *mut RClass,
    pub gcnext: *mut RBasic,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub cxt: *mut mrb_context,
}
#[test]
fn bindgen_test_layout_RFiber() {
    assert_eq!(
        ::std::mem::size_of::<RFiber>(),
        32usize,
        concat!("Size of: ", stringify!(RFiber))
    );
    assert_eq!(
        ::std::mem::align_of::<RFiber>(),
        8usize,
        concat!("Alignment of ", stringify!(RFiber))
    );
    fn test_field_c() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RFiber>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).c) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(RFiber), "::", stringify!(c))
        );
    }
    test_field_c();
    fn test_field_gcnext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RFiber>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gcnext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(RFiber),
                "::",
                stringify!(gcnext)
            )
        );
    }
    test_field_gcnext();
    fn test_field_cxt() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RFiber>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cxt) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(RFiber),
                "::",
                stringify!(cxt)
            )
        );
    }
    test_field_cxt();
}
impl RFiber {
    #[inline]
    pub fn tt(&self) -> mrb_vtype {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_tt(&mut self, val: mrb_vtype) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn color(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_color(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn flags(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 21u8) as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 21u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tt: mrb_vtype,
        color: u32,
        flags: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let tt: u32 = unsafe { ::std::mem::transmute(tt) };
            tt as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let color: u32 = unsafe { ::std::mem::transmute(color) };
            color as u64
        });
        __bindgen_bitfield_unit.set(11usize, 21u8, {
            let flags: u32 = unsafe { ::std::mem::transmute(flags) };
            flags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mrb_value {
    pub w: usize,
}
#[test]
fn bindgen_test_layout_mrb_value() {
    assert_eq!(
        ::std::mem::size_of::<mrb_value>(),
        8usize,
        concat!("Size of: ", stringify!(mrb_value))
    );
    assert_eq!(
        ::std::mem::align_of::<mrb_value>(),
        8usize,
        concat!("Alignment of ", stringify!(mrb_value))
    );
    fn test_field_w() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_value>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_value),
                "::",
                stringify!(w)
            )
        );
    }
    test_field_w();
}
extern "C" {
    pub fn mrb_word_boxing_cptr_value(
        arg1: *mut mrb_state,
        arg2: *mut ::std::os::raw::c_void,
    ) -> mrb_value;
}
extern "C" {
    pub fn mrb_word_boxing_float_value(arg1: *mut mrb_state, arg2: mrb_float) -> mrb_value;
}
extern "C" {
    pub fn mrb_boxing_int_value(arg1: *mut mrb_state, arg2: mrb_int) -> mrb_value;
}
extern "C" {
    pub fn mrb_word_boxing_value_float(v: mrb_value) -> mrb_float;
}
pub type mrb_each_object_callback = ::std::option::Option<
    unsafe extern "C" fn(
        mrb: *mut mrb_state,
        obj: *mut RBasic,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn mrb_objspace_each_objects(
        mrb: *mut mrb_state,
        callback: mrb_each_object_callback,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn mrb_objspace_page_slot_size() -> size_t;
}
extern "C" {
    pub fn mrb_free_context(mrb: *mut mrb_state, c: *mut mrb_context);
}
pub const mrb_gc_state_MRB_GC_STATE_ROOT: mrb_gc_state = 0;
pub const mrb_gc_state_MRB_GC_STATE_MARK: mrb_gc_state = 1;
pub const mrb_gc_state_MRB_GC_STATE_SWEEP: mrb_gc_state = 2;
pub type mrb_gc_state = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug)]
pub struct mrb_heap_page {
    pub freelist: *mut RBasic,
    pub prev: *mut mrb_heap_page,
    pub next: *mut mrb_heap_page,
    pub free_next: *mut mrb_heap_page,
    pub free_prev: *mut mrb_heap_page,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub objects: __IncompleteArrayField<*mut ::std::os::raw::c_void>,
}
#[test]
fn bindgen_test_layout_mrb_heap_page() {
    assert_eq!(
        ::std::mem::size_of::<mrb_heap_page>(),
        48usize,
        concat!("Size of: ", stringify!(mrb_heap_page))
    );
    assert_eq!(
        ::std::mem::align_of::<mrb_heap_page>(),
        8usize,
        concat!("Alignment of ", stringify!(mrb_heap_page))
    );
    fn test_field_freelist() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_heap_page>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).freelist) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_heap_page),
                "::",
                stringify!(freelist)
            )
        );
    }
    test_field_freelist();
    fn test_field_prev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_heap_page>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_heap_page),
                "::",
                stringify!(prev)
            )
        );
    }
    test_field_prev();
    fn test_field_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_heap_page>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_heap_page),
                "::",
                stringify!(next)
            )
        );
    }
    test_field_next();
    fn test_field_free_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_heap_page>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).free_next) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_heap_page),
                "::",
                stringify!(free_next)
            )
        );
    }
    test_field_free_next();
    fn test_field_free_prev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_heap_page>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).free_prev) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_heap_page),
                "::",
                stringify!(free_prev)
            )
        );
    }
    test_field_free_prev();
    fn test_field_objects() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_heap_page>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).objects) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_heap_page),
                "::",
                stringify!(objects)
            )
        );
    }
    test_field_objects();
}
impl mrb_heap_page {
    #[inline]
    pub fn old(&self) -> mrb_bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_old(&mut self, val: mrb_bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(old: mrb_bool) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let old: u8 = unsafe { ::std::mem::transmute(old) };
            old as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mrb_gc {
    pub heaps: *mut mrb_heap_page,
    pub sweeps: *mut mrb_heap_page,
    pub free_heaps: *mut mrb_heap_page,
    pub live: size_t,
    pub arena: *mut *mut RBasic,
    pub arena_capa: ::std::os::raw::c_int,
    pub arena_idx: ::std::os::raw::c_int,
    pub state: mrb_gc_state,
    pub current_white_part: ::std::os::raw::c_int,
    pub gray_list: *mut RBasic,
    pub atomic_gray_list: *mut RBasic,
    pub live_after_mark: size_t,
    pub threshold: size_t,
    pub interval_ratio: ::std::os::raw::c_int,
    pub step_ratio: ::std::os::raw::c_int,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub majorgc_old_threshold: size_t,
}
#[test]
fn bindgen_test_layout_mrb_gc() {
    assert_eq!(
        ::std::mem::size_of::<mrb_gc>(),
        112usize,
        concat!("Size of: ", stringify!(mrb_gc))
    );
    assert_eq!(
        ::std::mem::align_of::<mrb_gc>(),
        8usize,
        concat!("Alignment of ", stringify!(mrb_gc))
    );
    fn test_field_heaps() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_gc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).heaps) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_gc),
                "::",
                stringify!(heaps)
            )
        );
    }
    test_field_heaps();
    fn test_field_sweeps() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_gc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sweeps) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_gc),
                "::",
                stringify!(sweeps)
            )
        );
    }
    test_field_sweeps();
    fn test_field_free_heaps() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_gc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).free_heaps) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_gc),
                "::",
                stringify!(free_heaps)
            )
        );
    }
    test_field_free_heaps();
    fn test_field_live() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_gc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).live) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_gc),
                "::",
                stringify!(live)
            )
        );
    }
    test_field_live();
    fn test_field_arena() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_gc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).arena) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_gc),
                "::",
                stringify!(arena)
            )
        );
    }
    test_field_arena();
    fn test_field_arena_capa() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_gc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).arena_capa) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_gc),
                "::",
                stringify!(arena_capa)
            )
        );
    }
    test_field_arena_capa();
    fn test_field_arena_idx() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_gc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).arena_idx) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_gc),
                "::",
                stringify!(arena_idx)
            )
        );
    }
    test_field_arena_idx();
    fn test_field_state() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_gc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_gc),
                "::",
                stringify!(state)
            )
        );
    }
    test_field_state();
    fn test_field_current_white_part() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_gc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).current_white_part) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_gc),
                "::",
                stringify!(current_white_part)
            )
        );
    }
    test_field_current_white_part();
    fn test_field_gray_list() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_gc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gray_list) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_gc),
                "::",
                stringify!(gray_list)
            )
        );
    }
    test_field_gray_list();
    fn test_field_atomic_gray_list() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_gc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).atomic_gray_list) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_gc),
                "::",
                stringify!(atomic_gray_list)
            )
        );
    }
    test_field_atomic_gray_list();
    fn test_field_live_after_mark() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_gc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).live_after_mark) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_gc),
                "::",
                stringify!(live_after_mark)
            )
        );
    }
    test_field_live_after_mark();
    fn test_field_threshold() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_gc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).threshold) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_gc),
                "::",
                stringify!(threshold)
            )
        );
    }
    test_field_threshold();
    fn test_field_interval_ratio() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_gc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).interval_ratio) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_gc),
                "::",
                stringify!(interval_ratio)
            )
        );
    }
    test_field_interval_ratio();
    fn test_field_step_ratio() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_gc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).step_ratio) as usize - ptr as usize
            },
            92usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_gc),
                "::",
                stringify!(step_ratio)
            )
        );
    }
    test_field_step_ratio();
    fn test_field_majorgc_old_threshold() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_gc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).majorgc_old_threshold) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_gc),
                "::",
                stringify!(majorgc_old_threshold)
            )
        );
    }
    test_field_majorgc_old_threshold();
}
impl mrb_gc {
    #[inline]
    pub fn iterating(&self) -> mrb_bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_iterating(&mut self, val: mrb_bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disabled(&self) -> mrb_bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_disabled(&mut self, val: mrb_bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn full(&self) -> mrb_bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_full(&mut self, val: mrb_bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn generational(&self) -> mrb_bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_generational(&mut self, val: mrb_bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_of_memory(&self) -> mrb_bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_out_of_memory(&mut self, val: mrb_bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        iterating: mrb_bool,
        disabled: mrb_bool,
        full: mrb_bool,
        generational: mrb_bool,
        out_of_memory: mrb_bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let iterating: u8 = unsafe { ::std::mem::transmute(iterating) };
            iterating as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let disabled: u8 = unsafe { ::std::mem::transmute(disabled) };
            disabled as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let full: u8 = unsafe { ::std::mem::transmute(full) };
            full as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let generational: u8 = unsafe { ::std::mem::transmute(generational) };
            generational as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let out_of_memory: u8 = unsafe { ::std::mem::transmute(out_of_memory) };
            out_of_memory as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn mrb_object_dead_p(mrb: *mut mrb_state, object: *mut RBasic) -> mrb_bool;
}
#[doc = " MRuby C API entry point"]
pub type mrb_code = u8;
#[doc = " \\class mrb_aspec"]
#[doc = ""]
#[doc = " Specifies the number of arguments a function takes"]
#[doc = ""]
#[doc = " Example: `MRB_ARGS_REQ(2) | MRB_ARGS_OPT(1)` for a method that expects 2..3 arguments"]
pub type mrb_aspec = u32;
#[doc = " Function pointer type of custom allocator used in @see mrb_open_allocf."]
#[doc = ""]
#[doc = " The function pointing it must behave similarly as realloc except:"]
#[doc = " - If ptr is NULL it must allocate new space."]
#[doc = " - If s is NULL, ptr must be freed."]
#[doc = ""]
#[doc = " See @see mrb_default_allocf for the default implementation."]
pub type mrb_allocf = ::std::option::Option<
    unsafe extern "C" fn(
        mrb: *mut mrb_state,
        arg1: *mut ::std::os::raw::c_void,
        arg2: size_t,
        ud: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mrb_callinfo {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub cci: u8,
    pub mid: mrb_sym,
    pub proc_: *const RProc,
    pub stack: *mut mrb_value,
    pub pc: *const mrb_code,
    pub u: mrb_callinfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mrb_callinfo__bindgen_ty_1 {
    pub env: *mut REnv,
    pub target_class: *mut RClass,
}
#[test]
fn bindgen_test_layout_mrb_callinfo__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<mrb_callinfo__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(mrb_callinfo__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<mrb_callinfo__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(mrb_callinfo__bindgen_ty_1))
    );
    fn test_field_env() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_callinfo__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).env) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_callinfo__bindgen_ty_1),
                "::",
                stringify!(env)
            )
        );
    }
    test_field_env();
    fn test_field_target_class() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_callinfo__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).target_class) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_callinfo__bindgen_ty_1),
                "::",
                stringify!(target_class)
            )
        );
    }
    test_field_target_class();
}
#[test]
fn bindgen_test_layout_mrb_callinfo() {
    assert_eq!(
        ::std::mem::size_of::<mrb_callinfo>(),
        40usize,
        concat!("Size of: ", stringify!(mrb_callinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<mrb_callinfo>(),
        8usize,
        concat!("Alignment of ", stringify!(mrb_callinfo))
    );
    fn test_field_cci() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_callinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cci) as usize - ptr as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_callinfo),
                "::",
                stringify!(cci)
            )
        );
    }
    test_field_cci();
    fn test_field_mid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_callinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mid) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_callinfo),
                "::",
                stringify!(mid)
            )
        );
    }
    test_field_mid();
    fn test_field_proc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_callinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).proc_) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_callinfo),
                "::",
                stringify!(proc_)
            )
        );
    }
    test_field_proc();
    fn test_field_stack() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_callinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stack) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_callinfo),
                "::",
                stringify!(stack)
            )
        );
    }
    test_field_stack();
    fn test_field_pc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_callinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pc) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_callinfo),
                "::",
                stringify!(pc)
            )
        );
    }
    test_field_pc();
    fn test_field_u() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_callinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).u) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_callinfo),
                "::",
                stringify!(u)
            )
        );
    }
    test_field_u();
}
impl mrb_callinfo {
    #[inline]
    pub fn n(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_n(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn nk(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_nk(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(n: u8, nk: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let n: u8 = unsafe { ::std::mem::transmute(n) };
            n as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let nk: u8 = unsafe { ::std::mem::transmute(nk) };
            nk as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const mrb_fiber_state_MRB_FIBER_CREATED: mrb_fiber_state = 0;
pub const mrb_fiber_state_MRB_FIBER_RUNNING: mrb_fiber_state = 1;
pub const mrb_fiber_state_MRB_FIBER_RESUMED: mrb_fiber_state = 2;
pub const mrb_fiber_state_MRB_FIBER_SUSPENDED: mrb_fiber_state = 3;
pub const mrb_fiber_state_MRB_FIBER_TRANSFERRED: mrb_fiber_state = 4;
pub const mrb_fiber_state_MRB_FIBER_TERMINATED: mrb_fiber_state = 5;
pub type mrb_fiber_state = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mrb_context {
    pub prev: *mut mrb_context,
    pub stbase: *mut mrb_value,
    pub stend: *mut mrb_value,
    pub ci: *mut mrb_callinfo,
    pub cibase: *mut mrb_callinfo,
    pub ciend: *mut mrb_callinfo,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub fib: *mut RFiber,
}
#[test]
fn bindgen_test_layout_mrb_context() {
    assert_eq!(
        ::std::mem::size_of::<mrb_context>(),
        64usize,
        concat!("Size of: ", stringify!(mrb_context))
    );
    assert_eq!(
        ::std::mem::align_of::<mrb_context>(),
        8usize,
        concat!("Alignment of ", stringify!(mrb_context))
    );
    fn test_field_prev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_context>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_context),
                "::",
                stringify!(prev)
            )
        );
    }
    test_field_prev();
    fn test_field_stbase() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_context>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stbase) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_context),
                "::",
                stringify!(stbase)
            )
        );
    }
    test_field_stbase();
    fn test_field_stend() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_context>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stend) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_context),
                "::",
                stringify!(stend)
            )
        );
    }
    test_field_stend();
    fn test_field_ci() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_context>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ci) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_context),
                "::",
                stringify!(ci)
            )
        );
    }
    test_field_ci();
    fn test_field_cibase() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_context>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cibase) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_context),
                "::",
                stringify!(cibase)
            )
        );
    }
    test_field_cibase();
    fn test_field_ciend() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_context>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ciend) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_context),
                "::",
                stringify!(ciend)
            )
        );
    }
    test_field_ciend();
    fn test_field_fib() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_context>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fib) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_context),
                "::",
                stringify!(fib)
            )
        );
    }
    test_field_fib();
}
impl mrb_context {
    #[inline]
    pub fn status(&self) -> mrb_fiber_state {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_status(&mut self, val: mrb_fiber_state) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn vmexec(&self) -> mrb_bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_vmexec(&mut self, val: mrb_bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        status: mrb_fiber_state,
        vmexec: mrb_bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let status: u32 = unsafe { ::std::mem::transmute(status) };
            status as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let vmexec: u8 = unsafe { ::std::mem::transmute(vmexec) };
            vmexec as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Function pointer type for a function callable by mruby."]
#[doc = ""]
#[doc = " The arguments to the function are stored on the mrb_state. To get them see mrb_get_args"]
#[doc = ""]
#[doc = " @param mrb The mruby state"]
#[doc = " @param self The self object"]
#[doc = " @return [mrb_value] The function's return value"]
pub type mrb_func_t =
    ::std::option::Option<unsafe extern "C" fn(mrb: *mut mrb_state, self_: mrb_value) -> mrb_value>;
pub type mrb_method_t = usize;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mrb_cache_entry {
    pub c: *mut RClass,
    pub c0: *mut RClass,
    pub mid: mrb_sym,
    pub m: mrb_method_t,
}
#[test]
fn bindgen_test_layout_mrb_cache_entry() {
    assert_eq!(
        ::std::mem::size_of::<mrb_cache_entry>(),
        32usize,
        concat!("Size of: ", stringify!(mrb_cache_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<mrb_cache_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(mrb_cache_entry))
    );
    fn test_field_c() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_cache_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).c) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_cache_entry),
                "::",
                stringify!(c)
            )
        );
    }
    test_field_c();
    fn test_field_c0() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_cache_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).c0) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_cache_entry),
                "::",
                stringify!(c0)
            )
        );
    }
    test_field_c0();
    fn test_field_mid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_cache_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mid) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_cache_entry),
                "::",
                stringify!(mid)
            )
        );
    }
    test_field_mid();
    fn test_field_m() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_cache_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).m) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_cache_entry),
                "::",
                stringify!(m)
            )
        );
    }
    test_field_m();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mrb_jmpbuf {
    _unused: [u8; 0],
}
pub type mrb_atexit_func = ::std::option::Option<unsafe extern "C" fn(arg1: *mut mrb_state)>;
#[doc = " Uncommon memory management stuffs."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mrb_state {
    pub jmp: *mut mrb_jmpbuf,
    pub allocf: mrb_allocf,
    pub allocf_ud: *mut ::std::os::raw::c_void,
    pub c: *mut mrb_context,
    pub root_c: *mut mrb_context,
    pub globals: *mut iv_tbl,
    pub exc: *mut RObject,
    pub top_self: *mut RObject,
    pub object_class: *mut RClass,
    pub class_class: *mut RClass,
    pub module_class: *mut RClass,
    pub proc_class: *mut RClass,
    pub string_class: *mut RClass,
    pub array_class: *mut RClass,
    pub hash_class: *mut RClass,
    pub range_class: *mut RClass,
    pub float_class: *mut RClass,
    pub integer_class: *mut RClass,
    pub true_class: *mut RClass,
    pub false_class: *mut RClass,
    pub nil_class: *mut RClass,
    pub symbol_class: *mut RClass,
    pub kernel_module: *mut RClass,
    pub gc: mrb_gc,
    pub cache: [mrb_cache_entry; 256usize],
    pub symidx: mrb_sym,
    pub symtbl: *mut *const ::std::os::raw::c_char,
    pub symlink: *mut u8,
    pub symflags: *mut u8,
    pub symhash: [mrb_sym; 256usize],
    pub symcapa: size_t,
    pub symbuf: [::std::os::raw::c_char; 8usize],
    pub eException_class: *mut RClass,
    pub eStandardError_class: *mut RClass,
    pub nomem_err: *mut RObject,
    pub stack_err: *mut RObject,
    pub ud: *mut ::std::os::raw::c_void,
    pub atexit_stack: *mut mrb_atexit_func,
    pub atexit_stack_len: u16,
}
#[test]
fn bindgen_test_layout_mrb_state() {
    assert_eq!(
        ::std::mem::size_of::<mrb_state>(),
        9616usize,
        concat!("Size of: ", stringify!(mrb_state))
    );
    assert_eq!(
        ::std::mem::align_of::<mrb_state>(),
        8usize,
        concat!("Alignment of ", stringify!(mrb_state))
    );
    fn test_field_jmp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).jmp) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(jmp)
            )
        );
    }
    test_field_jmp();
    fn test_field_allocf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).allocf) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(allocf)
            )
        );
    }
    test_field_allocf();
    fn test_field_allocf_ud() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).allocf_ud) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(allocf_ud)
            )
        );
    }
    test_field_allocf_ud();
    fn test_field_c() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).c) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(c)
            )
        );
    }
    test_field_c();
    fn test_field_root_c() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).root_c) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(root_c)
            )
        );
    }
    test_field_root_c();
    fn test_field_globals() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).globals) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(globals)
            )
        );
    }
    test_field_globals();
    fn test_field_exc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).exc) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(exc)
            )
        );
    }
    test_field_exc();
    fn test_field_top_self() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).top_self) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(top_self)
            )
        );
    }
    test_field_top_self();
    fn test_field_object_class() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).object_class) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(object_class)
            )
        );
    }
    test_field_object_class();
    fn test_field_class_class() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).class_class) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(class_class)
            )
        );
    }
    test_field_class_class();
    fn test_field_module_class() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).module_class) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(module_class)
            )
        );
    }
    test_field_module_class();
    fn test_field_proc_class() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).proc_class) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(proc_class)
            )
        );
    }
    test_field_proc_class();
    fn test_field_string_class() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).string_class) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(string_class)
            )
        );
    }
    test_field_string_class();
    fn test_field_array_class() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).array_class) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(array_class)
            )
        );
    }
    test_field_array_class();
    fn test_field_hash_class() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hash_class) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(hash_class)
            )
        );
    }
    test_field_hash_class();
    fn test_field_range_class() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).range_class) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(range_class)
            )
        );
    }
    test_field_range_class();
    fn test_field_float_class() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).float_class) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(float_class)
            )
        );
    }
    test_field_float_class();
    fn test_field_integer_class() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).integer_class) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(integer_class)
            )
        );
    }
    test_field_integer_class();
    fn test_field_true_class() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).true_class) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(true_class)
            )
        );
    }
    test_field_true_class();
    fn test_field_false_class() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).false_class) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(false_class)
            )
        );
    }
    test_field_false_class();
    fn test_field_nil_class() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nil_class) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(nil_class)
            )
        );
    }
    test_field_nil_class();
    fn test_field_symbol_class() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).symbol_class) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(symbol_class)
            )
        );
    }
    test_field_symbol_class();
    fn test_field_kernel_module() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).kernel_module) as usize - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(kernel_module)
            )
        );
    }
    test_field_kernel_module();
    fn test_field_gc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gc) as usize - ptr as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(gc)
            )
        );
    }
    test_field_gc();
    fn test_field_cache() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cache) as usize - ptr as usize
            },
            296usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(cache)
            )
        );
    }
    test_field_cache();
    fn test_field_symidx() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).symidx) as usize - ptr as usize
            },
            8488usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(symidx)
            )
        );
    }
    test_field_symidx();
    fn test_field_symtbl() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).symtbl) as usize - ptr as usize
            },
            8496usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(symtbl)
            )
        );
    }
    test_field_symtbl();
    fn test_field_symlink() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).symlink) as usize - ptr as usize
            },
            8504usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(symlink)
            )
        );
    }
    test_field_symlink();
    fn test_field_symflags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).symflags) as usize - ptr as usize
            },
            8512usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(symflags)
            )
        );
    }
    test_field_symflags();
    fn test_field_symhash() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).symhash) as usize - ptr as usize
            },
            8520usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(symhash)
            )
        );
    }
    test_field_symhash();
    fn test_field_symcapa() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).symcapa) as usize - ptr as usize
            },
            9544usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(symcapa)
            )
        );
    }
    test_field_symcapa();
    fn test_field_symbuf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).symbuf) as usize - ptr as usize
            },
            9552usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(symbuf)
            )
        );
    }
    test_field_symbuf();
    fn test_field_eException_class() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).eException_class) as usize - ptr as usize
            },
            9560usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(eException_class)
            )
        );
    }
    test_field_eException_class();
    fn test_field_eStandardError_class() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).eStandardError_class) as usize - ptr as usize
            },
            9568usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(eStandardError_class)
            )
        );
    }
    test_field_eStandardError_class();
    fn test_field_nomem_err() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nomem_err) as usize - ptr as usize
            },
            9576usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(nomem_err)
            )
        );
    }
    test_field_nomem_err();
    fn test_field_stack_err() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stack_err) as usize - ptr as usize
            },
            9584usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(stack_err)
            )
        );
    }
    test_field_stack_err();
    fn test_field_ud() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ud) as usize - ptr as usize
            },
            9592usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(ud)
            )
        );
    }
    test_field_ud();
    fn test_field_atexit_stack() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).atexit_stack) as usize - ptr as usize
            },
            9600usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(atexit_stack)
            )
        );
    }
    test_field_atexit_stack();
    fn test_field_atexit_stack_len() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).atexit_stack_len) as usize - ptr as usize
            },
            9608usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_state),
                "::",
                stringify!(atexit_stack_len)
            )
        );
    }
    test_field_atexit_stack_len();
}
extern "C" {
    #[doc = " Defines a new class."]
    #[doc = ""]
    #[doc = " If you're creating a gem it may look something like this:"]
    #[doc = ""]
    #[doc = "      !!!c"]
    #[doc = "      void mrb_example_gem_init(mrb_state* mrb) {"]
    #[doc = "          struct RClass *example_class;"]
    #[doc = "          example_class = mrb_define_class(mrb, \"Example_Class\", mrb->object_class);"]
    #[doc = "      }"]
    #[doc = ""]
    #[doc = "      void mrb_example_gem_final(mrb_state* mrb) {"]
    #[doc = "          //free(TheAnimals);"]
    #[doc = "      }"]
    #[doc = ""]
    #[doc = " @param mrb The current mruby state."]
    #[doc = " @param name The name of the defined class."]
    #[doc = " @param super The new class parent."]
    #[doc = " @return [struct RClass *] Reference to the newly defined class."]
    #[doc = " @see mrb_define_class_under"]
    pub fn mrb_define_class(
        mrb: *mut mrb_state,
        name: *const ::std::os::raw::c_char,
        super_: *mut RClass,
    ) -> *mut RClass;
}
extern "C" {
    pub fn mrb_define_class_id(
        mrb: *mut mrb_state,
        name: mrb_sym,
        super_: *mut RClass,
    ) -> *mut RClass;
}
extern "C" {
    #[doc = " Defines a new module."]
    #[doc = ""]
    #[doc = " @param mrb The current mruby state."]
    #[doc = " @param name The name of the module."]
    #[doc = " @return [struct RClass *] Reference to the newly defined module."]
    pub fn mrb_define_module(
        mrb: *mut mrb_state,
        name: *const ::std::os::raw::c_char,
    ) -> *mut RClass;
}
extern "C" {
    pub fn mrb_define_module_id(mrb: *mut mrb_state, name: mrb_sym) -> *mut RClass;
}
extern "C" {
    pub fn mrb_singleton_class(mrb: *mut mrb_state, val: mrb_value) -> mrb_value;
}
extern "C" {
    pub fn mrb_singleton_class_ptr(mrb: *mut mrb_state, val: mrb_value) -> *mut RClass;
}
extern "C" {
    #[doc = " Include a module in another class or module."]
    #[doc = " Equivalent to:"]
    #[doc = ""]
    #[doc = "   module B"]
    #[doc = "     include A"]
    #[doc = "   end"]
    #[doc = " @param mrb The current mruby state."]
    #[doc = " @param cla A reference to module or a class."]
    #[doc = " @param included A reference to the module to be included."]
    pub fn mrb_include_module(mrb: *mut mrb_state, cla: *mut RClass, included: *mut RClass);
}
extern "C" {
    #[doc = " Prepends a module in another class or module."]
    #[doc = ""]
    #[doc = " Equivalent to:"]
    #[doc = "  module B"]
    #[doc = "    prepend A"]
    #[doc = "  end"]
    #[doc = " @param mrb The current mruby state."]
    #[doc = " @param cla A reference to module or a class."]
    #[doc = " @param prepended A reference to the module to be prepended."]
    pub fn mrb_prepend_module(mrb: *mut mrb_state, cla: *mut RClass, prepended: *mut RClass);
}
extern "C" {
    #[doc = " Defines a global function in ruby."]
    #[doc = ""]
    #[doc = " If you're creating a gem it may look something like this"]
    #[doc = ""]
    #[doc = " Example:"]
    #[doc = ""]
    #[doc = "     mrb_value example_method(mrb_state* mrb, mrb_value self)"]
    #[doc = "     {"]
    #[doc = "          puts(\"Executing example command!\");"]
    #[doc = "          return self;"]
    #[doc = "     }"]
    #[doc = ""]
    #[doc = "     void mrb_example_gem_init(mrb_state* mrb)"]
    #[doc = "     {"]
    #[doc = "           mrb_define_method(mrb, mrb->kernel_module, \"example_method\", example_method, MRB_ARGS_NONE());"]
    #[doc = "     }"]
    #[doc = ""]
    #[doc = " @param mrb The MRuby state reference."]
    #[doc = " @param cla The class pointer where the method will be defined."]
    #[doc = " @param name The name of the method being defined."]
    #[doc = " @param func The function pointer to the method definition."]
    #[doc = " @param aspec The method parameters declaration."]
    pub fn mrb_define_method(
        mrb: *mut mrb_state,
        cla: *mut RClass,
        name: *const ::std::os::raw::c_char,
        func: mrb_func_t,
        aspec: mrb_aspec,
    );
}
extern "C" {
    pub fn mrb_define_method_id(
        mrb: *mut mrb_state,
        c: *mut RClass,
        mid: mrb_sym,
        func: mrb_func_t,
        aspec: mrb_aspec,
    );
}
extern "C" {
    #[doc = " Defines a class method."]
    #[doc = ""]
    #[doc = " Example:"]
    #[doc = ""]
    #[doc = "     # Ruby style"]
    #[doc = "     class Foo"]
    #[doc = "       def Foo.bar"]
    #[doc = "       end"]
    #[doc = "     end"]
    #[doc = "     // C style"]
    #[doc = "     mrb_value bar_method(mrb_state* mrb, mrb_value self){"]
    #[doc = "       return mrb_nil_value();"]
    #[doc = "     }"]
    #[doc = "     void mrb_example_gem_init(mrb_state* mrb){"]
    #[doc = "       struct RClass *foo;"]
    #[doc = "       foo = mrb_define_class(mrb, \"Foo\", mrb->object_class);"]
    #[doc = "       mrb_define_class_method(mrb, foo, \"bar\", bar_method, MRB_ARGS_NONE());"]
    #[doc = "     }"]
    #[doc = " @param mrb The MRuby state reference."]
    #[doc = " @param cla The class where the class method will be defined."]
    #[doc = " @param name The name of the class method being defined."]
    #[doc = " @param fun The function pointer to the class method definition."]
    #[doc = " @param aspec The method parameters declaration."]
    pub fn mrb_define_class_method(
        mrb: *mut mrb_state,
        cla: *mut RClass,
        name: *const ::std::os::raw::c_char,
        fun: mrb_func_t,
        aspec: mrb_aspec,
    );
}
extern "C" {
    pub fn mrb_define_class_method_id(
        mrb: *mut mrb_state,
        cla: *mut RClass,
        name: mrb_sym,
        fun: mrb_func_t,
        aspec: mrb_aspec,
    );
}
extern "C" {
    #[doc = " Defines a singleton method"]
    #[doc = ""]
    #[doc = " @see mrb_define_class_method"]
    pub fn mrb_define_singleton_method(
        mrb: *mut mrb_state,
        cla: *mut RObject,
        name: *const ::std::os::raw::c_char,
        fun: mrb_func_t,
        aspec: mrb_aspec,
    );
}
extern "C" {
    pub fn mrb_define_singleton_method_id(
        mrb: *mut mrb_state,
        cla: *mut RObject,
        name: mrb_sym,
        fun: mrb_func_t,
        aspec: mrb_aspec,
    );
}
extern "C" {
    #[doc = "  Defines a module function."]
    #[doc = ""]
    #[doc = " Example:"]
    #[doc = ""]
    #[doc = "        # Ruby style"]
    #[doc = "        module Foo"]
    #[doc = "          def Foo.bar"]
    #[doc = "          end"]
    #[doc = "        end"]
    #[doc = "        // C style"]
    #[doc = "        mrb_value bar_method(mrb_state* mrb, mrb_value self){"]
    #[doc = "          return mrb_nil_value();"]
    #[doc = "        }"]
    #[doc = "        void mrb_example_gem_init(mrb_state* mrb){"]
    #[doc = "          struct RClass *foo;"]
    #[doc = "          foo = mrb_define_module(mrb, \"Foo\");"]
    #[doc = "          mrb_define_module_function(mrb, foo, \"bar\", bar_method, MRB_ARGS_NONE());"]
    #[doc = "        }"]
    #[doc = "  @param mrb The MRuby state reference."]
    #[doc = "  @param cla The module where the module function will be defined."]
    #[doc = "  @param name The name of the module function being defined."]
    #[doc = "  @param fun The function pointer to the module function definition."]
    #[doc = "  @param aspec The method parameters declaration."]
    pub fn mrb_define_module_function(
        mrb: *mut mrb_state,
        cla: *mut RClass,
        name: *const ::std::os::raw::c_char,
        fun: mrb_func_t,
        aspec: mrb_aspec,
    );
}
extern "C" {
    pub fn mrb_define_module_function_id(
        mrb: *mut mrb_state,
        cla: *mut RClass,
        name: mrb_sym,
        fun: mrb_func_t,
        aspec: mrb_aspec,
    );
}
extern "C" {
    #[doc = "  Defines a constant."]
    #[doc = ""]
    #[doc = " Example:"]
    #[doc = ""]
    #[doc = "          # Ruby style"]
    #[doc = "          class ExampleClass"]
    #[doc = "            AGE = 22"]
    #[doc = "          end"]
    #[doc = "          // C style"]
    #[doc = "          #include <stdio.h>"]
    #[doc = "          #include <mruby.h>"]
    #[doc = ""]
    #[doc = "          void"]
    #[doc = "          mrb_example_gem_init(mrb_state* mrb){"]
    #[doc = "            mrb_define_const(mrb, mrb->kernel_module, \"AGE\", mrb_fixnum_value(22));"]
    #[doc = "          }"]
    #[doc = ""]
    #[doc = "          mrb_value"]
    #[doc = "          mrb_example_gem_final(mrb_state* mrb){"]
    #[doc = "          }"]
    #[doc = "  @param mrb The MRuby state reference."]
    #[doc = "  @param cla A class or module the constant is defined in."]
    #[doc = "  @param name The name of the constant being defined."]
    #[doc = "  @param val The value for the constant."]
    pub fn mrb_define_const(
        mrb: *mut mrb_state,
        cla: *mut RClass,
        name: *const ::std::os::raw::c_char,
        val: mrb_value,
    );
}
extern "C" {
    pub fn mrb_define_const_id(
        mrb: *mut mrb_state,
        cla: *mut RClass,
        name: mrb_sym,
        val: mrb_value,
    );
}
extern "C" {
    #[doc = " Undefines a method."]
    #[doc = ""]
    #[doc = " Example:"]
    #[doc = ""]
    #[doc = "     # Ruby style"]
    #[doc = ""]
    #[doc = "     class ExampleClassA"]
    #[doc = "       def example_method"]
    #[doc = "         \"example\""]
    #[doc = "       end"]
    #[doc = "     end"]
    #[doc = "     ExampleClassA.new.example_method # => example"]
    #[doc = ""]
    #[doc = "     class ExampleClassB < ExampleClassA"]
    #[doc = "       undef_method :example_method"]
    #[doc = "     end"]
    #[doc = ""]
    #[doc = "     ExampleClassB.new.example_method # => undefined method 'example_method' for ExampleClassB (NoMethodError)"]
    #[doc = ""]
    #[doc = "     // C style"]
    #[doc = "     #include <stdio.h>"]
    #[doc = "     #include <mruby.h>"]
    #[doc = ""]
    #[doc = "     mrb_value"]
    #[doc = "     mrb_example_method(mrb_state *mrb){"]
    #[doc = "       return mrb_str_new_lit(mrb, \"example\");"]
    #[doc = "     }"]
    #[doc = ""]
    #[doc = "     void"]
    #[doc = "     mrb_example_gem_init(mrb_state* mrb){"]
    #[doc = "       struct RClass *example_class_a;"]
    #[doc = "       struct RClass *example_class_b;"]
    #[doc = "       struct RClass *example_class_c;"]
    #[doc = ""]
    #[doc = "       example_class_a = mrb_define_class(mrb, \"ExampleClassA\", mrb->object_class);"]
    #[doc = "       mrb_define_method(mrb, example_class_a, \"example_method\", mrb_example_method, MRB_ARGS_NONE());"]
    #[doc = "       example_class_b = mrb_define_class(mrb, \"ExampleClassB\", example_class_a);"]
    #[doc = "       example_class_c = mrb_define_class(mrb, \"ExampleClassC\", example_class_b);"]
    #[doc = "       mrb_undef_method(mrb, example_class_c, \"example_method\");"]
    #[doc = "     }"]
    #[doc = ""]
    #[doc = "     mrb_example_gem_final(mrb_state* mrb){"]
    #[doc = "     }"]
    #[doc = " @param mrb The mruby state reference."]
    #[doc = " @param cla The class the method will be undefined from."]
    #[doc = " @param name The name of the method to be undefined."]
    pub fn mrb_undef_method(
        mrb: *mut mrb_state,
        cla: *mut RClass,
        name: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn mrb_undef_method_id(arg1: *mut mrb_state, arg2: *mut RClass, arg3: mrb_sym);
}
extern "C" {
    #[doc = " Undefine a class method."]
    #[doc = " Example:"]
    #[doc = ""]
    #[doc = "      # Ruby style"]
    #[doc = "      class ExampleClass"]
    #[doc = "        def self.example_method"]
    #[doc = "          \"example\""]
    #[doc = "        end"]
    #[doc = "      end"]
    #[doc = ""]
    #[doc = "     ExampleClass.example_method"]
    #[doc = ""]
    #[doc = "     // C style"]
    #[doc = "     #include <stdio.h>"]
    #[doc = "     #include <mruby.h>"]
    #[doc = ""]
    #[doc = "     mrb_value"]
    #[doc = "     mrb_example_method(mrb_state *mrb){"]
    #[doc = "       return mrb_str_new_lit(mrb, \"example\");"]
    #[doc = "     }"]
    #[doc = ""]
    #[doc = "     void"]
    #[doc = "     mrb_example_gem_init(mrb_state* mrb){"]
    #[doc = "       struct RClass *example_class;"]
    #[doc = "       example_class = mrb_define_class(mrb, \"ExampleClass\", mrb->object_class);"]
    #[doc = "       mrb_define_class_method(mrb, example_class, \"example_method\", mrb_example_method, MRB_ARGS_NONE());"]
    #[doc = "       mrb_undef_class_method(mrb, example_class, \"example_method\");"]
    #[doc = "      }"]
    #[doc = ""]
    #[doc = "      void"]
    #[doc = "      mrb_example_gem_final(mrb_state* mrb){"]
    #[doc = "      }"]
    #[doc = " @param mrb The mruby state reference."]
    #[doc = " @param cls A class the class method will be undefined from."]
    #[doc = " @param name The name of the class method to be undefined."]
    pub fn mrb_undef_class_method(
        mrb: *mut mrb_state,
        cls: *mut RClass,
        name: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn mrb_undef_class_method_id(mrb: *mut mrb_state, cls: *mut RClass, name: mrb_sym);
}
extern "C" {
    #[doc = " Initialize a new object instance of c class."]
    #[doc = ""]
    #[doc = " Example:"]
    #[doc = ""]
    #[doc = "     # Ruby style"]
    #[doc = "     class ExampleClass"]
    #[doc = "     end"]
    #[doc = ""]
    #[doc = "     p ExampleClass # => #<ExampleClass:0x9958588>"]
    #[doc = "     // C style"]
    #[doc = "     #include <stdio.h>"]
    #[doc = "     #include <mruby.h>"]
    #[doc = ""]
    #[doc = "     void"]
    #[doc = "     mrb_example_gem_init(mrb_state* mrb) {"]
    #[doc = "       struct RClass *example_class;"]
    #[doc = "       mrb_value obj;"]
    #[doc = "       example_class = mrb_define_class(mrb, \"ExampleClass\", mrb->object_class); # => class ExampleClass; end"]
    #[doc = "       obj = mrb_obj_new(mrb, example_class, 0, NULL); # => ExampleClass.new"]
    #[doc = "       mrb_p(mrb, obj); // => Kernel#p"]
    #[doc = "      }"]
    #[doc = " @param mrb The current mruby state."]
    #[doc = " @param c Reference to the class of the new object."]
    #[doc = " @param argc Number of arguments in argv"]
    #[doc = " @param argv Array of mrb_value to initialize the object"]
    #[doc = " @return [mrb_value] The newly initialized object"]
    pub fn mrb_obj_new(
        mrb: *mut mrb_state,
        c: *mut RClass,
        argc: mrb_int,
        argv: *const mrb_value,
    ) -> mrb_value;
}
extern "C" {
    #[doc = " Creates a new instance of Class, Class."]
    #[doc = ""]
    #[doc = " Example:"]
    #[doc = ""]
    #[doc = "      void"]
    #[doc = "      mrb_example_gem_init(mrb_state* mrb) {"]
    #[doc = "        struct RClass *example_class;"]
    #[doc = ""]
    #[doc = "        mrb_value obj;"]
    #[doc = "        example_class = mrb_class_new(mrb, mrb->object_class);"]
    #[doc = "        obj = mrb_obj_new(mrb, example_class, 0, NULL); // => #<#<Class:0x9a945b8>:0x9a94588>"]
    #[doc = "        mrb_p(mrb, obj); // => Kernel#p"]
    #[doc = "       }"]
    #[doc = ""]
    #[doc = " @param mrb The current mruby state."]
    #[doc = " @param super The super class or parent."]
    #[doc = " @return [struct RClass *] Reference to the new class."]
    pub fn mrb_class_new(mrb: *mut mrb_state, super_: *mut RClass) -> *mut RClass;
}
extern "C" {
    #[doc = " Creates a new module, Module."]
    #[doc = ""]
    #[doc = " Example:"]
    #[doc = "      void"]
    #[doc = "      mrb_example_gem_init(mrb_state* mrb) {"]
    #[doc = "        struct RClass *example_module;"]
    #[doc = ""]
    #[doc = "        example_module = mrb_module_new(mrb);"]
    #[doc = "      }"]
    #[doc = ""]
    #[doc = " @param mrb The current mruby state."]
    #[doc = " @return [struct RClass *] Reference to the new module."]
    pub fn mrb_module_new(mrb: *mut mrb_state) -> *mut RClass;
}
extern "C" {
    #[doc = " Returns an mrb_bool. True if class was defined, and false if the class was not defined."]
    #[doc = ""]
    #[doc = " Example:"]
    #[doc = "     void"]
    #[doc = "     mrb_example_gem_init(mrb_state* mrb) {"]
    #[doc = "       struct RClass *example_class;"]
    #[doc = "       mrb_bool cd;"]
    #[doc = ""]
    #[doc = "       example_class = mrb_define_class(mrb, \"ExampleClass\", mrb->object_class);"]
    #[doc = "       cd = mrb_class_defined(mrb, \"ExampleClass\");"]
    #[doc = ""]
    #[doc = "       // If mrb_class_defined returns 1 then puts \"True\""]
    #[doc = "       // If mrb_class_defined returns 0 then puts \"False\""]
    #[doc = "       if (cd == 1){"]
    #[doc = "         puts(\"True\");"]
    #[doc = "       }"]
    #[doc = "       else {"]
    #[doc = "         puts(\"False\");"]
    #[doc = "       }"]
    #[doc = "      }"]
    #[doc = ""]
    #[doc = " @param mrb The current mruby state."]
    #[doc = " @param name A string representing the name of the class."]
    #[doc = " @return [mrb_bool] A boolean value."]
    pub fn mrb_class_defined(mrb: *mut mrb_state, name: *const ::std::os::raw::c_char) -> mrb_bool;
}
extern "C" {
    pub fn mrb_class_defined_id(mrb: *mut mrb_state, name: mrb_sym) -> mrb_bool;
}
extern "C" {
    #[doc = " Gets a class."]
    #[doc = " @param mrb The current mruby state."]
    #[doc = " @param name The name of the class."]
    #[doc = " @return [struct RClass *] A reference to the class."]
    pub fn mrb_class_get(mrb: *mut mrb_state, name: *const ::std::os::raw::c_char) -> *mut RClass;
}
extern "C" {
    pub fn mrb_class_get_id(mrb: *mut mrb_state, name: mrb_sym) -> *mut RClass;
}
extern "C" {
    #[doc = " Gets a exception class."]
    #[doc = " @param mrb The current mruby state."]
    #[doc = " @param name The name of the class."]
    #[doc = " @return [struct RClass *] A reference to the class."]
    pub fn mrb_exc_get_id(mrb: *mut mrb_state, name: mrb_sym) -> *mut RClass;
}
extern "C" {
    #[doc = " Returns an mrb_bool. True if inner class was defined, and false if the inner class was not defined."]
    #[doc = ""]
    #[doc = " Example:"]
    #[doc = "     void"]
    #[doc = "     mrb_example_gem_init(mrb_state* mrb) {"]
    #[doc = "       struct RClass *example_outer, *example_inner;"]
    #[doc = "       mrb_bool cd;"]
    #[doc = ""]
    #[doc = "       example_outer = mrb_define_module(mrb, \"ExampleOuter\");"]
    #[doc = ""]
    #[doc = "       example_inner = mrb_define_class_under(mrb, example_outer, \"ExampleInner\", mrb->object_class);"]
    #[doc = "       cd = mrb_class_defined_under(mrb, example_outer, \"ExampleInner\");"]
    #[doc = ""]
    #[doc = "       // If mrb_class_defined_under returns 1 then puts \"True\""]
    #[doc = "       // If mrb_class_defined_under returns 0 then puts \"False\""]
    #[doc = "       if (cd == 1){"]
    #[doc = "         puts(\"True\");"]
    #[doc = "       }"]
    #[doc = "       else {"]
    #[doc = "         puts(\"False\");"]
    #[doc = "       }"]
    #[doc = "      }"]
    #[doc = ""]
    #[doc = " @param mrb The current mruby state."]
    #[doc = " @param outer The name of the outer class."]
    #[doc = " @param name A string representing the name of the inner class."]
    #[doc = " @return [mrb_bool] A boolean value."]
    pub fn mrb_class_defined_under(
        mrb: *mut mrb_state,
        outer: *mut RClass,
        name: *const ::std::os::raw::c_char,
    ) -> mrb_bool;
}
extern "C" {
    pub fn mrb_class_defined_under_id(
        mrb: *mut mrb_state,
        outer: *mut RClass,
        name: mrb_sym,
    ) -> mrb_bool;
}
extern "C" {
    #[doc = " Gets a child class."]
    #[doc = " @param mrb The current mruby state."]
    #[doc = " @param outer The name of the parent class."]
    #[doc = " @param name The name of the class."]
    #[doc = " @return [struct RClass *] A reference to the class."]
    pub fn mrb_class_get_under(
        mrb: *mut mrb_state,
        outer: *mut RClass,
        name: *const ::std::os::raw::c_char,
    ) -> *mut RClass;
}
extern "C" {
    pub fn mrb_class_get_under_id(
        mrb: *mut mrb_state,
        outer: *mut RClass,
        name: mrb_sym,
    ) -> *mut RClass;
}
extern "C" {
    #[doc = " Gets a module."]
    #[doc = " @param mrb The current mruby state."]
    #[doc = " @param name The name of the module."]
    #[doc = " @return [struct RClass *] A reference to the module."]
    pub fn mrb_module_get(mrb: *mut mrb_state, name: *const ::std::os::raw::c_char) -> *mut RClass;
}
extern "C" {
    pub fn mrb_module_get_id(mrb: *mut mrb_state, name: mrb_sym) -> *mut RClass;
}
extern "C" {
    #[doc = " Gets a module defined under another module."]
    #[doc = " @param mrb The current mruby state."]
    #[doc = " @param outer The name of the outer module."]
    #[doc = " @param name The name of the module."]
    #[doc = " @return [struct RClass *] A reference to the module."]
    pub fn mrb_module_get_under(
        mrb: *mut mrb_state,
        outer: *mut RClass,
        name: *const ::std::os::raw::c_char,
    ) -> *mut RClass;
}
extern "C" {
    pub fn mrb_module_get_under_id(
        mrb: *mut mrb_state,
        outer: *mut RClass,
        name: mrb_sym,
    ) -> *mut RClass;
}
extern "C" {
    pub fn mrb_notimplement(arg1: *mut mrb_state);
}
extern "C" {
    pub fn mrb_notimplement_m(arg1: *mut mrb_state, arg2: mrb_value) -> mrb_value;
}
extern "C" {
    #[doc = " Duplicate an object."]
    #[doc = ""]
    #[doc = " Equivalent to:"]
    #[doc = "   Object#dup"]
    #[doc = " @param mrb The current mruby state."]
    #[doc = " @param obj Object to be duplicate."]
    #[doc = " @return [mrb_value] The newly duplicated object."]
    pub fn mrb_obj_dup(mrb: *mut mrb_state, obj: mrb_value) -> mrb_value;
}
extern "C" {
    #[doc = " Returns true if obj responds to the given method. If the method was defined for that"]
    #[doc = " class it returns true, it returns false otherwise."]
    #[doc = ""]
    #[doc = "      Example:"]
    #[doc = "      # Ruby style"]
    #[doc = "      class ExampleClass"]
    #[doc = "        def example_method"]
    #[doc = "        end"]
    #[doc = "      end"]
    #[doc = ""]
    #[doc = "      ExampleClass.new.respond_to?(:example_method) # => true"]
    #[doc = ""]
    #[doc = "      // C style"]
    #[doc = "      void"]
    #[doc = "      mrb_example_gem_init(mrb_state* mrb) {"]
    #[doc = "        struct RClass *example_class;"]
    #[doc = "        mrb_sym mid;"]
    #[doc = "        mrb_bool obj_resp;"]
    #[doc = ""]
    #[doc = "        example_class = mrb_define_class(mrb, \"ExampleClass\", mrb->object_class);"]
    #[doc = "        mrb_define_method(mrb, example_class, \"example_method\", exampleMethod, MRB_ARGS_NONE());"]
    #[doc = "        mid = mrb_intern_str(mrb, mrb_str_new_lit(mrb, \"example_method\" ));"]
    #[doc = "        obj_resp = mrb_obj_respond_to(mrb, example_class, mid); // => 1(true in Ruby world)"]
    #[doc = ""]
    #[doc = "        // If mrb_obj_respond_to returns 1 then puts \"True\""]
    #[doc = "        // If mrb_obj_respond_to returns 0 then puts \"False\""]
    #[doc = "        if (obj_resp == 1) {"]
    #[doc = "          puts(\"True\");"]
    #[doc = "        }"]
    #[doc = "        else if (obj_resp == 0) {"]
    #[doc = "          puts(\"False\");"]
    #[doc = "        }"]
    #[doc = "      }"]
    #[doc = ""]
    #[doc = " @param mrb The current mruby state."]
    #[doc = " @param c A reference to a class."]
    #[doc = " @param mid A symbol referencing a method id."]
    #[doc = " @return [mrb_bool] A boolean value."]
    pub fn mrb_obj_respond_to(mrb: *mut mrb_state, c: *mut RClass, mid: mrb_sym) -> mrb_bool;
}
extern "C" {
    #[doc = " Defines a new class under a given module"]
    #[doc = ""]
    #[doc = " @param mrb The current mruby state."]
    #[doc = " @param outer Reference to the module under which the new class will be defined"]
    #[doc = " @param name The name of the defined class"]
    #[doc = " @param super The new class parent"]
    #[doc = " @return [struct RClass *] Reference to the newly defined class"]
    #[doc = " @see mrb_define_class"]
    pub fn mrb_define_class_under(
        mrb: *mut mrb_state,
        outer: *mut RClass,
        name: *const ::std::os::raw::c_char,
        super_: *mut RClass,
    ) -> *mut RClass;
}
extern "C" {
    pub fn mrb_define_class_under_id(
        mrb: *mut mrb_state,
        outer: *mut RClass,
        name: mrb_sym,
        super_: *mut RClass,
    ) -> *mut RClass;
}
extern "C" {
    pub fn mrb_define_module_under(
        mrb: *mut mrb_state,
        outer: *mut RClass,
        name: *const ::std::os::raw::c_char,
    ) -> *mut RClass;
}
extern "C" {
    pub fn mrb_define_module_under_id(
        mrb: *mut mrb_state,
        outer: *mut RClass,
        name: mrb_sym,
    ) -> *mut RClass;
}
#[doc = " Format specifiers for {mrb_get_args} function"]
#[doc = ""]
#[doc = " Must be a C string composed of the following format specifiers:"]
#[doc = ""]
#[doc = " | char | Ruby type      | C types           | Notes                                              |"]
#[doc = " |:----:|----------------|-------------------|----------------------------------------------------|"]
#[doc = " | `o`  | {Object}       | {mrb_value}       | Could be used to retrieve any type of argument     |"]
#[doc = " | `C`  | {Class}/{Module} | {mrb_value}     | when `!` follows, the value may be `nil`           |"]
#[doc = " | `S`  | {String}       | {mrb_value}       | when `!` follows, the value may be `nil`           |"]
#[doc = " | `A`  | {Array}        | {mrb_value}       | when `!` follows, the value may be `nil`           |"]
#[doc = " | `H`  | {Hash}         | {mrb_value}       | when `!` follows, the value may be `nil`           |"]
#[doc = " | `s`  | {String}       | const char *, {mrb_int} | Receive two arguments; `s!` gives (`NULL`,`0`) for `nil` |"]
#[doc = " | `z`  | {String}       | const char *      | `NULL` terminated string; `z!` gives `NULL` for `nil` |"]
#[doc = " | `a`  | {Array}        | const {mrb_value} *, {mrb_int} | Receive two arguments; `a!` gives (`NULL`,`0`) for `nil` |"]
#[doc = " | `c`  | {Class}/{Module} | strcut RClass * | `c!` gives `NULL` for `nil`                        |"]
#[doc = " | `f`  | {Integer}/{Float} | {mrb_float}    |                                                    |"]
#[doc = " | `i`  | {Integer}/{Float} | {mrb_int}      |                                                    |"]
#[doc = " | `b`  | boolean        | {mrb_bool}        |                                                    |"]
#[doc = " | `n`  | {String}/{Symbol} | {mrb_sym}         |                                                    |"]
#[doc = " | `d`  | data           | void *, {mrb_data_type} const | 2nd argument will be used to check data type so it won't be modified; when `!` follows, the value may be `nil` |"]
#[doc = " | `I`  | inline struct  | void *, struct RClass | `I!` gives `NULL` for `nil`                    |"]
#[doc = " | `&`  | block          | {mrb_value}       | &! raises exception if no block given.             |"]
#[doc = " | `*`  | rest arguments | const {mrb_value} *, {mrb_int} | Receive the rest of arguments as an array; `*!` avoid copy of the stack.  |"]
#[doc = " | <code>\\|</code> | optional     |                   | After this spec following specs would be optional. |"]
#[doc = " | `?`  | optional given | {mrb_bool}        | `TRUE` if preceding argument is given. Used to check optional argument is given. |"]
#[doc = " | `:`  | keyword args   | {mrb_kwargs} const | Get keyword arguments. @see mrb_kwargs |"]
#[doc = ""]
#[doc = " @see mrb_get_args"]
#[doc = ""]
#[doc = " Immediately after format specifiers it can add format modifiers:"]
#[doc = ""]
#[doc = " | char | Notes                                                                                   |"]
#[doc = " |:----:|-----------------------------------------------------------------------------------------|"]
#[doc = " | `!`  | Switch to the alternate mode; The behaviour changes depending on the format specifier   |"]
#[doc = " | `+`  | Request a not frozen object; However, except nil value                                  |"]
pub type mrb_args_format = *const ::std::os::raw::c_char;
extern "C" {
    #[doc = " Retrieve arguments from mrb_state."]
    #[doc = ""]
    #[doc = " @param mrb The current MRuby state."]
    #[doc = " @param format is a list of format specifiers"]
    #[doc = " @param ... The passing variadic arguments must be a pointer of retrieving type."]
    #[doc = " @return the number of arguments retrieved."]
    #[doc = " @see mrb_args_format"]
    #[doc = " @see mrb_kwargs"]
    pub fn mrb_get_args(mrb: *mut mrb_state, format: mrb_args_format, ...) -> mrb_int;
}
extern "C" {
    #[doc = " Retrieve number of arguments from mrb_state."]
    #[doc = ""]
    #[doc = " Correctly handles *splat arguments."]
    pub fn mrb_get_argc(mrb: *mut mrb_state) -> mrb_int;
}
extern "C" {
    #[doc = " Retrieve an array of arguments from mrb_state."]
    #[doc = ""]
    #[doc = " Correctly handles *splat arguments."]
    pub fn mrb_get_argv(mrb: *mut mrb_state) -> *const mrb_value;
}
extern "C" {
    #[doc = " Retrieve the first and only argument from mrb_state."]
    #[doc = " Raises ArgumentError unless the number of arguments is exactly one."]
    #[doc = ""]
    #[doc = " Correctly handles *splat arguments."]
    pub fn mrb_get_arg1(mrb: *mut mrb_state) -> mrb_value;
}
extern "C" {
    #[doc = " Check if a block argument is given from mrb_state."]
    pub fn mrb_block_given_p(mrb: *mut mrb_state) -> mrb_bool;
}
extern "C" {
    #[doc = " Call existing ruby functions."]
    #[doc = ""]
    #[doc = " Example:"]
    #[doc = ""]
    #[doc = "      #include <stdio.h>"]
    #[doc = "      #include <mruby.h>"]
    #[doc = "      #include \"mruby/compile.h\""]
    #[doc = ""]
    #[doc = "      int"]
    #[doc = "      main()"]
    #[doc = "      {"]
    #[doc = "        mrb_int i = 99;"]
    #[doc = "        mrb_state *mrb = mrb_open();"]
    #[doc = ""]
    #[doc = "        if (!mrb) { }"]
    #[doc = "        FILE *fp = fopen(\"test.rb\",\"r\");"]
    #[doc = "        mrb_value obj = mrb_load_file(mrb,fp);"]
    #[doc = "        mrb_funcall(mrb, obj, \"method_name\", 1, mrb_fixnum_value(i));"]
    #[doc = "        mrb_funcall_id(mrb, obj, MRB_SYM(method_name), 1, mrb_fixnum_value(i));"]
    #[doc = "        fclose(fp);"]
    #[doc = "        mrb_close(mrb);"]
    #[doc = "      }"]
    #[doc = ""]
    #[doc = " @param mrb The current mruby state."]
    #[doc = " @param val A reference to an mruby value."]
    #[doc = " @param name The name of the method."]
    #[doc = " @param argc The number of arguments the method has."]
    #[doc = " @param ... Variadic values(not type safe!)."]
    #[doc = " @return [mrb_value] mruby function value."]
    pub fn mrb_funcall(
        mrb: *mut mrb_state,
        val: mrb_value,
        name: *const ::std::os::raw::c_char,
        argc: mrb_int,
        ...
    ) -> mrb_value;
}
extern "C" {
    pub fn mrb_funcall_id(
        mrb: *mut mrb_state,
        val: mrb_value,
        mid: mrb_sym,
        argc: mrb_int,
        ...
    ) -> mrb_value;
}
extern "C" {
    #[doc = " Call existing ruby functions. This is basically the type safe version of mrb_funcall."]
    #[doc = ""]
    #[doc = "      #include <stdio.h>"]
    #[doc = "      #include <mruby.h>"]
    #[doc = "      #include \"mruby/compile.h\""]
    #[doc = "      int"]
    #[doc = "      main()"]
    #[doc = "      {"]
    #[doc = "        mrb_state *mrb = mrb_open();"]
    #[doc = "        mrb_value obj = mrb_fixnum_value(1);"]
    #[doc = ""]
    #[doc = "        if (!mrb) { }"]
    #[doc = ""]
    #[doc = "        FILE *fp = fopen(\"test.rb\",\"r\");"]
    #[doc = "        mrb_value obj = mrb_load_file(mrb,fp);"]
    #[doc = "        mrb_funcall_argv(mrb, obj, MRB_SYM(method_name), 1, &obj); // Calling ruby function from test.rb."]
    #[doc = "        fclose(fp);"]
    #[doc = "        mrb_close(mrb);"]
    #[doc = "       }"]
    #[doc = " @param mrb The current mruby state."]
    #[doc = " @param val A reference to an mruby value."]
    #[doc = " @param name_sym The symbol representing the method."]
    #[doc = " @param argc The number of arguments the method has."]
    #[doc = " @param obj Pointer to the object."]
    #[doc = " @return [mrb_value] mrb_value mruby function value."]
    #[doc = " @see mrb_funcall"]
    pub fn mrb_funcall_argv(
        mrb: *mut mrb_state,
        val: mrb_value,
        name: mrb_sym,
        argc: mrb_int,
        argv: *const mrb_value,
    ) -> mrb_value;
}
extern "C" {
    #[doc = " Call existing ruby functions with a block."]
    pub fn mrb_funcall_with_block(
        mrb: *mut mrb_state,
        val: mrb_value,
        name: mrb_sym,
        argc: mrb_int,
        argv: *const mrb_value,
        block: mrb_value,
    ) -> mrb_value;
}
extern "C" {
    #[doc = " Create a symbol from C string. But usually it's better to use MRB_SYM,"]
    #[doc = " MRB_OPSYM, MRB_CVSYM, MRB_IVSYM, MRB_SYM_B, MRB_SYM_Q, MRB_SYM_E macros."]
    #[doc = ""]
    #[doc = " Example:"]
    #[doc = ""]
    #[doc = "     # Ruby style:"]
    #[doc = "     :pizza # => :pizza"]
    #[doc = ""]
    #[doc = "     // C style:"]
    #[doc = "     mrb_sym sym1 = mrb_intern_lit(mrb, \"pizza\"); //  => :pizza"]
    #[doc = "     mrb_sym sym2 = MRB_SYM(pizza);               //  => :pizza"]
    #[doc = "     mrb_sym sym3 = MRB_SYM_Q(pizza);             //  => :pizza?"]
    #[doc = ""]
    #[doc = " @param mrb The current mruby state."]
    #[doc = " @param str The string to be symbolized"]
    #[doc = " @return [mrb_sym] mrb_sym A symbol."]
    pub fn mrb_intern_cstr(mrb: *mut mrb_state, str_: *const ::std::os::raw::c_char) -> mrb_sym;
}
extern "C" {
    pub fn mrb_intern(
        arg1: *mut mrb_state,
        arg2: *const ::std::os::raw::c_char,
        arg3: size_t,
    ) -> mrb_sym;
}
extern "C" {
    pub fn mrb_intern_static(
        arg1: *mut mrb_state,
        arg2: *const ::std::os::raw::c_char,
        arg3: size_t,
    ) -> mrb_sym;
}
extern "C" {
    pub fn mrb_intern_str(arg1: *mut mrb_state, arg2: mrb_value) -> mrb_sym;
}
extern "C" {
    pub fn mrb_intern_check_cstr(
        arg1: *mut mrb_state,
        arg2: *const ::std::os::raw::c_char,
    ) -> mrb_sym;
}
extern "C" {
    pub fn mrb_intern_check(
        arg1: *mut mrb_state,
        arg2: *const ::std::os::raw::c_char,
        arg3: size_t,
    ) -> mrb_sym;
}
extern "C" {
    pub fn mrb_intern_check_str(arg1: *mut mrb_state, arg2: mrb_value) -> mrb_sym;
}
extern "C" {
    pub fn mrb_check_intern_cstr(
        arg1: *mut mrb_state,
        arg2: *const ::std::os::raw::c_char,
    ) -> mrb_value;
}
extern "C" {
    pub fn mrb_check_intern(
        arg1: *mut mrb_state,
        arg2: *const ::std::os::raw::c_char,
        arg3: size_t,
    ) -> mrb_value;
}
extern "C" {
    pub fn mrb_check_intern_str(arg1: *mut mrb_state, arg2: mrb_value) -> mrb_value;
}
extern "C" {
    pub fn mrb_sym_name(arg1: *mut mrb_state, arg2: mrb_sym) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn mrb_sym_name_len(
        arg1: *mut mrb_state,
        arg2: mrb_sym,
        arg3: *mut mrb_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn mrb_sym_dump(arg1: *mut mrb_state, arg2: mrb_sym) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn mrb_sym_str(arg1: *mut mrb_state, arg2: mrb_sym) -> mrb_value;
}
extern "C" {
    pub fn mrb_malloc(arg1: *mut mrb_state, arg2: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mrb_calloc(
        arg1: *mut mrb_state,
        arg2: size_t,
        arg3: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mrb_realloc(
        arg1: *mut mrb_state,
        arg2: *mut ::std::os::raw::c_void,
        arg3: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mrb_realloc_simple(
        arg1: *mut mrb_state,
        arg2: *mut ::std::os::raw::c_void,
        arg3: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mrb_malloc_simple(arg1: *mut mrb_state, arg2: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mrb_obj_alloc(arg1: *mut mrb_state, arg2: mrb_vtype, arg3: *mut RClass) -> *mut RBasic;
}
extern "C" {
    pub fn mrb_free(arg1: *mut mrb_state, arg2: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn mrb_str_new(
        mrb: *mut mrb_state,
        p: *const ::std::os::raw::c_char,
        len: size_t,
    ) -> mrb_value;
}
extern "C" {
    #[doc = " Turns a C string into a Ruby string value."]
    pub fn mrb_str_new_cstr(arg1: *mut mrb_state, arg2: *const ::std::os::raw::c_char)
        -> mrb_value;
}
extern "C" {
    pub fn mrb_str_new_static(
        mrb: *mut mrb_state,
        p: *const ::std::os::raw::c_char,
        len: size_t,
    ) -> mrb_value;
}
extern "C" {
    pub fn mrb_obj_freeze(arg1: *mut mrb_state, arg2: mrb_value) -> mrb_value;
}
extern "C" {
    #[doc = " Creates new mrb_state."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      Pointer to the newly created mrb_state."]
    pub fn mrb_open() -> *mut mrb_state;
}
extern "C" {
    #[doc = " Create new mrb_state with custom allocators."]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "      Reference to the allocation function."]
    #[doc = " @param ud"]
    #[doc = "      User data will be passed to custom allocator f."]
    #[doc = "      If user data isn't required just pass NULL."]
    #[doc = " @return"]
    #[doc = "      Pointer to the newly created mrb_state."]
    pub fn mrb_open_allocf(f: mrb_allocf, ud: *mut ::std::os::raw::c_void) -> *mut mrb_state;
}
extern "C" {
    #[doc = " Create new mrb_state with just the MRuby core"]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "      Reference to the allocation function."]
    #[doc = "      Use mrb_default_allocf for the default"]
    #[doc = " @param ud"]
    #[doc = "      User data will be passed to custom allocator f."]
    #[doc = "      If user data isn't required just pass NULL."]
    #[doc = " @return"]
    #[doc = "      Pointer to the newly created mrb_state."]
    pub fn mrb_open_core(f: mrb_allocf, ud: *mut ::std::os::raw::c_void) -> *mut mrb_state;
}
extern "C" {
    #[doc = " Closes and frees a mrb_state."]
    #[doc = ""]
    #[doc = " @param mrb"]
    #[doc = "      Pointer to the mrb_state to be closed."]
    pub fn mrb_close(mrb: *mut mrb_state);
}
extern "C" {
    #[doc = " The default allocation function."]
    #[doc = ""]
    #[doc = " @see mrb_allocf"]
    pub fn mrb_default_allocf(
        arg1: *mut mrb_state,
        arg2: *mut ::std::os::raw::c_void,
        arg3: size_t,
        arg4: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mrb_top_self(mrb: *mut mrb_state) -> mrb_value;
}
extern "C" {
    pub fn mrb_top_run(
        mrb: *mut mrb_state,
        proc_: *const RProc,
        self_: mrb_value,
        stack_keep: mrb_int,
    ) -> mrb_value;
}
extern "C" {
    pub fn mrb_vm_run(
        mrb: *mut mrb_state,
        proc_: *const RProc,
        self_: mrb_value,
        stack_keep: mrb_int,
    ) -> mrb_value;
}
extern "C" {
    pub fn mrb_vm_exec(
        mrb: *mut mrb_state,
        proc_: *const RProc,
        iseq: *const mrb_code,
    ) -> mrb_value;
}
extern "C" {
    pub fn mrb_p(arg1: *mut mrb_state, arg2: mrb_value);
}
extern "C" {
    pub fn mrb_obj_id(obj: mrb_value) -> mrb_int;
}
extern "C" {
    pub fn mrb_obj_to_sym(mrb: *mut mrb_state, name: mrb_value) -> mrb_sym;
}
extern "C" {
    pub fn mrb_obj_eq(mrb: *mut mrb_state, a: mrb_value, b: mrb_value) -> mrb_bool;
}
extern "C" {
    pub fn mrb_obj_equal(mrb: *mut mrb_state, a: mrb_value, b: mrb_value) -> mrb_bool;
}
extern "C" {
    pub fn mrb_equal(mrb: *mut mrb_state, obj1: mrb_value, obj2: mrb_value) -> mrb_bool;
}
extern "C" {
    pub fn mrb_ensure_float_type(mrb: *mut mrb_state, val: mrb_value) -> mrb_value;
}
extern "C" {
    pub fn mrb_inspect(mrb: *mut mrb_state, obj: mrb_value) -> mrb_value;
}
extern "C" {
    pub fn mrb_eql(mrb: *mut mrb_state, obj1: mrb_value, obj2: mrb_value) -> mrb_bool;
}
extern "C" {
    pub fn mrb_cmp(mrb: *mut mrb_state, obj1: mrb_value, obj2: mrb_value) -> mrb_int;
}
extern "C" {
    pub fn mrb_garbage_collect(arg1: *mut mrb_state);
}
extern "C" {
    pub fn mrb_full_gc(arg1: *mut mrb_state);
}
extern "C" {
    pub fn mrb_incremental_gc(arg1: *mut mrb_state);
}
extern "C" {
    pub fn mrb_gc_mark(arg1: *mut mrb_state, arg2: *mut RBasic);
}
extern "C" {
    pub fn mrb_field_write_barrier(arg1: *mut mrb_state, arg2: *mut RBasic, arg3: *mut RBasic);
}
extern "C" {
    pub fn mrb_write_barrier(arg1: *mut mrb_state, arg2: *mut RBasic);
}
extern "C" {
    pub fn mrb_type_convert(
        mrb: *mut mrb_state,
        val: mrb_value,
        type_: mrb_vtype,
        method: mrb_sym,
    ) -> mrb_value;
}
extern "C" {
    pub fn mrb_type_convert_check(
        mrb: *mut mrb_state,
        val: mrb_value,
        type_: mrb_vtype,
        method: mrb_sym,
    ) -> mrb_value;
}
extern "C" {
    pub fn mrb_any_to_s(mrb: *mut mrb_state, obj: mrb_value) -> mrb_value;
}
extern "C" {
    pub fn mrb_obj_classname(mrb: *mut mrb_state, obj: mrb_value) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn mrb_obj_class(mrb: *mut mrb_state, obj: mrb_value) -> *mut RClass;
}
extern "C" {
    pub fn mrb_class_path(mrb: *mut mrb_state, c: *mut RClass) -> mrb_value;
}
extern "C" {
    pub fn mrb_obj_is_kind_of(mrb: *mut mrb_state, obj: mrb_value, c: *mut RClass) -> mrb_bool;
}
extern "C" {
    pub fn mrb_obj_inspect(mrb: *mut mrb_state, self_: mrb_value) -> mrb_value;
}
extern "C" {
    pub fn mrb_obj_clone(mrb: *mut mrb_state, self_: mrb_value) -> mrb_value;
}
extern "C" {
    pub fn mrb_exc_new(
        mrb: *mut mrb_state,
        c: *mut RClass,
        ptr: *const ::std::os::raw::c_char,
        len: size_t,
    ) -> mrb_value;
}
extern "C" {
    pub fn mrb_exc_raise(mrb: *mut mrb_state, exc: mrb_value);
}
extern "C" {
    pub fn mrb_raise(mrb: *mut mrb_state, c: *mut RClass, msg: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn mrb_raisef(mrb: *mut mrb_state, c: *mut RClass, fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn mrb_name_error(
        mrb: *mut mrb_state,
        id: mrb_sym,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn mrb_frozen_error(mrb: *mut mrb_state, frozen_obj: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn mrb_argnum_error(
        mrb: *mut mrb_state,
        argc: mrb_int,
        min: ::std::os::raw::c_int,
        max: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn mrb_warn(mrb: *mut mrb_state, fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn mrb_bug(mrb: *mut mrb_state, fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn mrb_print_backtrace(mrb: *mut mrb_state);
}
extern "C" {
    pub fn mrb_print_error(mrb: *mut mrb_state);
}
extern "C" {
    pub fn mrb_vformat(
        mrb: *mut mrb_state,
        format: *const ::std::os::raw::c_char,
        ap: va_list,
    ) -> mrb_value;
}
extern "C" {
    pub fn mrb_yield(mrb: *mut mrb_state, b: mrb_value, arg: mrb_value) -> mrb_value;
}
extern "C" {
    pub fn mrb_yield_argv(
        mrb: *mut mrb_state,
        b: mrb_value,
        argc: mrb_int,
        argv: *const mrb_value,
    ) -> mrb_value;
}
extern "C" {
    pub fn mrb_yield_with_class(
        mrb: *mut mrb_state,
        b: mrb_value,
        argc: mrb_int,
        argv: *const mrb_value,
        self_: mrb_value,
        c: *mut RClass,
    ) -> mrb_value;
}
extern "C" {
    pub fn mrb_yield_cont(
        mrb: *mut mrb_state,
        b: mrb_value,
        self_: mrb_value,
        argc: mrb_int,
        argv: *const mrb_value,
    ) -> mrb_value;
}
extern "C" {
    pub fn mrb_gc_protect(mrb: *mut mrb_state, obj: mrb_value);
}
extern "C" {
    pub fn mrb_gc_register(mrb: *mut mrb_state, obj: mrb_value);
}
extern "C" {
    pub fn mrb_gc_unregister(mrb: *mut mrb_state, obj: mrb_value);
}
extern "C" {
    pub fn mrb_ensure_array_type(mrb: *mut mrb_state, self_: mrb_value) -> mrb_value;
}
extern "C" {
    pub fn mrb_check_array_type(mrb: *mut mrb_state, self_: mrb_value) -> mrb_value;
}
extern "C" {
    pub fn mrb_ensure_hash_type(mrb: *mut mrb_state, hash: mrb_value) -> mrb_value;
}
extern "C" {
    pub fn mrb_check_hash_type(mrb: *mut mrb_state, hash: mrb_value) -> mrb_value;
}
extern "C" {
    pub fn mrb_ensure_string_type(mrb: *mut mrb_state, str_: mrb_value) -> mrb_value;
}
extern "C" {
    pub fn mrb_check_string_type(mrb: *mut mrb_state, str_: mrb_value) -> mrb_value;
}
extern "C" {
    pub fn mrb_ensure_int_type(mrb: *mut mrb_state, val: mrb_value) -> mrb_value;
}
extern "C" {
    pub fn mrb_check_type(mrb: *mut mrb_state, x: mrb_value, t: mrb_vtype);
}
extern "C" {
    pub fn mrb_define_alias(
        mrb: *mut mrb_state,
        c: *mut RClass,
        a: *const ::std::os::raw::c_char,
        b: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn mrb_define_alias_id(mrb: *mut mrb_state, c: *mut RClass, a: mrb_sym, b: mrb_sym);
}
extern "C" {
    pub fn mrb_class_name(mrb: *mut mrb_state, klass: *mut RClass)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn mrb_define_global_const(
        mrb: *mut mrb_state,
        name: *const ::std::os::raw::c_char,
        val: mrb_value,
    );
}
extern "C" {
    pub fn mrb_attr_get(mrb: *mut mrb_state, obj: mrb_value, id: mrb_sym) -> mrb_value;
}
extern "C" {
    pub fn mrb_respond_to(mrb: *mut mrb_state, obj: mrb_value, mid: mrb_sym) -> mrb_bool;
}
extern "C" {
    pub fn mrb_obj_is_instance_of(mrb: *mut mrb_state, obj: mrb_value, c: *mut RClass) -> mrb_bool;
}
extern "C" {
    pub fn mrb_func_basic_p(
        mrb: *mut mrb_state,
        obj: mrb_value,
        mid: mrb_sym,
        func: mrb_func_t,
    ) -> mrb_bool;
}
extern "C" {
    #[doc = " Resume a Fiber"]
    #[doc = ""]
    #[doc = " Implemented in mruby-fiber"]
    pub fn mrb_fiber_resume(
        mrb: *mut mrb_state,
        fib: mrb_value,
        argc: mrb_int,
        argv: *const mrb_value,
    ) -> mrb_value;
}
extern "C" {
    #[doc = " Yield a Fiber"]
    #[doc = ""]
    #[doc = " Implemented in mruby-fiber"]
    pub fn mrb_fiber_yield(mrb: *mut mrb_state, argc: mrb_int, argv: *const mrb_value)
        -> mrb_value;
}
extern "C" {
    #[doc = " Check if a Fiber is alive"]
    #[doc = ""]
    #[doc = " Implemented in mruby-fiber"]
    pub fn mrb_fiber_alive_p(mrb: *mut mrb_state, fib: mrb_value) -> mrb_value;
}
extern "C" {
    pub fn mrb_stack_extend(arg1: *mut mrb_state, arg2: mrb_int);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mrb_pool {
    _unused: [u8; 0],
}
extern "C" {
    pub fn mrb_pool_open(arg1: *mut mrb_state) -> *mut mrb_pool;
}
extern "C" {
    pub fn mrb_pool_close(arg1: *mut mrb_pool);
}
extern "C" {
    pub fn mrb_pool_alloc(arg1: *mut mrb_pool, arg2: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mrb_pool_realloc(
        arg1: *mut mrb_pool,
        arg2: *mut ::std::os::raw::c_void,
        oldlen: size_t,
        newlen: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mrb_pool_can_realloc(
        arg1: *mut mrb_pool,
        arg2: *mut ::std::os::raw::c_void,
        arg3: size_t,
    ) -> mrb_bool;
}
extern "C" {
    pub fn mrb_alloca(mrb: *mut mrb_state, arg1: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mrb_state_atexit(mrb: *mut mrb_state, func: mrb_atexit_func);
}
extern "C" {
    pub fn mrb_show_version(mrb: *mut mrb_state);
}
extern "C" {
    pub fn mrb_show_copyright(mrb: *mut mrb_state);
}
extern "C" {
    pub fn mrb_format(mrb: *mut mrb_state, format: *const ::std::os::raw::c_char, ...)
        -> mrb_value;
}
#[doc = " Custom data type description."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mrb_data_type {
    #[doc = " data type name"]
    pub struct_name: *const ::std::os::raw::c_char,
    #[doc = " data type release function pointer"]
    pub dfree: ::std::option::Option<
        unsafe extern "C" fn(mrb: *mut mrb_state, arg1: *mut ::std::os::raw::c_void),
    >,
}
#[test]
fn bindgen_test_layout_mrb_data_type() {
    assert_eq!(
        ::std::mem::size_of::<mrb_data_type>(),
        16usize,
        concat!("Size of: ", stringify!(mrb_data_type))
    );
    assert_eq!(
        ::std::mem::align_of::<mrb_data_type>(),
        8usize,
        concat!("Alignment of ", stringify!(mrb_data_type))
    );
    fn test_field_struct_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_data_type>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).struct_name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_data_type),
                "::",
                stringify!(struct_name)
            )
        );
    }
    test_field_struct_name();
    fn test_field_dfree() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mrb_data_type>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dfree) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(mrb_data_type),
                "::",
                stringify!(dfree)
            )
        );
    }
    test_field_dfree();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RData {
    pub c: *mut RClass,
    pub gcnext: *mut RBasic,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub iv: *mut iv_tbl,
    pub type_: *const mrb_data_type,
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_RData() {
    assert_eq!(
        ::std::mem::size_of::<RData>(),
        48usize,
        concat!("Size of: ", stringify!(RData))
    );
    assert_eq!(
        ::std::mem::align_of::<RData>(),
        8usize,
        concat!("Alignment of ", stringify!(RData))
    );
    fn test_field_c() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RData>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).c) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(RData), "::", stringify!(c))
        );
    }
    test_field_c();
    fn test_field_gcnext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RData>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gcnext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(RData),
                "::",
                stringify!(gcnext)
            )
        );
    }
    test_field_gcnext();
    fn test_field_iv() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RData>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).iv) as usize - ptr as usize
            },
            24usize,
            concat!("Offset of field: ", stringify!(RData), "::", stringify!(iv))
        );
    }
    test_field_iv();
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RData>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(RData),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RData>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(RData),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
}
impl RData {
    #[inline]
    pub fn tt(&self) -> mrb_vtype {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_tt(&mut self, val: mrb_vtype) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn color(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_color(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn flags(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 21u8) as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 21u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tt: mrb_vtype,
        color: u32,
        flags: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let tt: u32 = unsafe { ::std::mem::transmute(tt) };
            tt as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let color: u32 = unsafe { ::std::mem::transmute(color) };
            color as u64
        });
        __bindgen_bitfield_unit.set(11usize, 21u8, {
            let flags: u32 = unsafe { ::std::mem::transmute(flags) };
            flags as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn mrb_data_object_alloc(
        mrb: *mut mrb_state,
        klass: *mut RClass,
        datap: *mut ::std::os::raw::c_void,
        type_: *const mrb_data_type,
    ) -> *mut RData;
}
extern "C" {
    pub fn mrb_data_check_type(mrb: *mut mrb_state, arg1: mrb_value, arg2: *const mrb_data_type);
}
extern "C" {
    pub fn mrb_data_get_ptr(
        mrb: *mut mrb_state,
        arg1: mrb_value,
        arg2: *const mrb_data_type,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mrb_data_check_get_ptr(
        mrb: *mut mrb_state,
        arg1: mrb_value,
        arg2: *const mrb_data_type,
    ) -> *mut ::std::os::raw::c_void;
}
pub type __builtin_va_list = *mut ::std::os::raw::c_char;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iv_tbl {
    pub _address: u8,
}
